/* ============================================================
   FTG DASHBOARD — COMPLETE RESPONSIVE SCRIPT (PART 1 OF 3)
============================================================ */

/* ------------------------------------------------------------
   SAFE DOM UTILITIES - Prevent null reference errors
------------------------------------------------------------ */
function getEl(id) {
  return document.getElementById(id);
}

function setElText(id, text) {
  const el = document.getElementById(id);
  if (el) el.textContent = text;
}

function setElValue(id, value) {
  const el = document.getElementById(id);
  if (el) el.value = value;
}

function getElValue(id, defaultValue = '') {
  const el = document.getElementById(id);
  return el ? el.value : defaultValue;
}

function getElChecked(id, defaultValue = false) {
  const el = document.getElementById(id);
  return el ? el.checked : defaultValue;
}

function setElClass(id, className) {
  const el = document.getElementById(id);
  if (el) el.className = className;
}

/* ------------------------------------------------------------
   DEBOUNCE UTILITY - Prevent excessive function calls
------------------------------------------------------------ */
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/* ------------------------------------------------------------
   DEBOUNCED CHART UPDATE FUNCTIONS
   Prevents excessive chart redraws during rapid user interaction
------------------------------------------------------------ */
const debouncedUpdateOverviewCharts = debounce(() => {
  if (typeof updateOverviewCharts === 'function') {
    updateOverviewCharts();
  }
}, 150);

const debouncedRenderCashChart = debounce(() => {
  if (typeof renderCashChart === 'function') {
    renderCashChart();
  }
}, 150);

/* ------------------------------------------------------------
   LAZY LOADING UTILITY - Load heavy libraries on-demand
   Reduces initial page load time by ~500KB+
------------------------------------------------------------ */
const LazyLoader = {
  loaded: {},
  loading: {},
  
  libraries: {
    html2canvas: 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js',
    jspdf: 'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
    xlsx: 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js',
    exceljs: 'https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js',
    emailjs: 'https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js'
  },
  
  load(name) {
    if (this.loaded[name]) {
      return Promise.resolve();
    }
    if (this.loading[name]) {
      return this.loading[name];
    }
    
    const url = this.libraries[name];
    if (!url) {
      return Promise.reject(new Error(`Unknown library: ${name}`));
    }
    
    this.loading[name] = new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = () => {
        this.loaded[name] = true;
        delete this.loading[name];
        resolve();
      };
      script.onerror = () => {
        delete this.loading[name];
        reject(new Error(`Failed to load ${name}`));
      };
      document.head.appendChild(script);
    });
    
    return this.loading[name];
  },
  
  async loadMultiple(names) {
    await Promise.all(names.map(name => this.load(name)));
  }
};

/* ------------------------------------------------------------
   PM EXCLUSION CONFIGURATION
   Centralized list of PMs to exclude from analysis/comparisons
   These are typically non-full-time PMs or special cases
------------------------------------------------------------ */
const PM_EXCLUSION_CONFIG = {
  excludedPMs: ['Josh Angelo', 'Greg Baba'],
  
  isExcluded(pmName) {
    if (!pmName) return false;
    return this.excludedPMs.some(excluded => 
      pmName.toLowerCase().trim() === excluded.toLowerCase().trim()
    );
  },
  
  getExclusionNote() {
    return this.excludedPMs.length > 0 
      ? `Excluding ${this.excludedPMs.join(', ')} from analysis.`
      : '';
  },
  
  getAIPromptExclusion() {
    if (this.excludedPMs.length === 0) return '';
    return `IMPORTANT: Disregard ${this.excludedPMs.join(' and ')}'s numbers from your analysis and commentary. Do not include any data or mention of ${this.excludedPMs.join(' or ')} in your response.`;
  }
};

/* ------------------------------------------------------------
   ACTIVE PM LIST HELPER
   Returns only PMs who have active jobs (job_status = 'A')
   Used by PM filter dropdowns across multiple pages
------------------------------------------------------------ */
let _cachedActivePms = null;
let _activePmsCacheTime = 0;
const ACTIVE_PMS_CACHE_TTL = 60000; // 1 minute cache

async function getActivePmsList() {
  // Return cached list if fresh
  if (_cachedActivePms && (Date.now() - _activePmsCacheTime) < ACTIVE_PMS_CACHE_TTL) {
    return _cachedActivePms;
  }
  
  try {
    // Try lightweight PM list API first
    const resp = await fetch('/api/pm-list');
    if (resp.ok) {
      const data = await resp.json();
      if (data.success && data.pms) {
        _cachedActivePms = data.pms;
        _activePmsCacheTime = Date.now();
        return _cachedActivePms;
      }
    }
    
    // Fallback to jobs data
    // Fallback to metrics API
    const metricsData = await DataCache.getJobsMetrics();
    const jobs = metricsData.jobs || [];
    
    // Get unique PMs with active jobs only
    const activePms = [...new Set(
      jobs
        .filter(j => j.job_status === "A" && j.project_manager)
        .map(j => j.project_manager)
    )].sort();
    
    _cachedActivePms = activePms;
    return activePms;
  } catch (e) {
    console.warn('Failed to load active PMs list:', e);
    return [];
  }
}

/**
 * Load and build PM tabs for any page - fetches PM list if needed
 * @param {string} containerId - ID of the tabs container element
 * @param {string} pageKey - Key for pmTabsState (pmr, jo, jb, ja, cc, oub, ara)
 * @param {Function} onSelect - Callback function when a PM is selected
 */
async function loadAndBuildPmTabs(containerId, pageKey, onSelect) {
  const pms = await getActivePmsList();
  buildPmTabs(containerId, pms, pageKey, onSelect);
}

function getActivePmsFromData(dataArray) {
  // Synchronous helper when data is already loaded
  // Guard against undefined/null input
  if (!Array.isArray(dataArray) || dataArray.length === 0) {
    return [];
  }
  return [...new Set(
    dataArray
      .filter(j => j.job_status === 'A' && j.project_manager_name && !PM_EXCLUSION_CONFIG.isExcluded(j.project_manager_name))
      .map(j => j.project_manager_name)
  )].sort();
}

/* ------------------------------------------------------------
   PM TABS BUILDER - Generic function to build PM tabs UI
   Used across PM Report, Job Overview, Job Budgets, Job Actuals, Cost Codes
------------------------------------------------------------ */

// Preferred order for PM tabs (first names) - used for sorting
const PM_TAB_ORDER = ['Rodney', 'Kathy', 'Doris', 'Pedro', 'Jen', 'Daniel', 'Jose'];

// Track selected PM for each page
const pmTabsState = {
  pmr: '__ALL__',   // PM Report
  jo: '__ALL__',    // Job Overview
  jb: '__ALL__',    // Job Budgets
  ja: '__ALL__',    // Job Actuals
  cc: '__ALL__',    // Cost Codes
  oub: '__ALL__',   // Over/Under Billing
  ara: '__ALL__',   // AR Aging
  apa: '__ALL__'    // AP Aging
};

/**
 * Build PM tabs UI for a page
 * @param {string} containerId - ID of the tabs container element
 * @param {Array} pms - Array of full PM names
 * @param {string} pageKey - Key for pmTabsState (pmr, jo, jb, ja, cc)
 * @param {Function} onSelect - Callback function when a PM is selected
 */
function buildPmTabs(containerId, pms, pageKey, onSelect) {
  const container = document.getElementById(containerId);
  if (!container) {
    console.error(`[PM Tabs] Container not found: ${containerId}`);
    return;
  }
  
  // Filter out excluded PMs (e.g., Josh Angelo)
  const filteredPms = (pms || []).filter(pm => !PM_EXCLUSION_CONFIG.isExcluded(pm));
  
  if (filteredPms.length === 0) {
    container.innerHTML = '<button class="pm-tab-btn all-pm active" data-pm="__ALL__">All Project Managers</button>';
    pmTabsState[pageKey] = '__ALL__';
    return;
  }
  
  // Sort PMs: preferred order first by matching first name, then alphabetically
  const sortedPms = [...filteredPms].sort((a, b) => {
    const aFirst = a.split(' ')[0];
    const bFirst = b.split(' ')[0];
    const aIndex = PM_TAB_ORDER.indexOf(aFirst);
    const bIndex = PM_TAB_ORDER.indexOf(bFirst);
    
    if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
    if (aIndex !== -1) return -1;
    if (bIndex !== -1) return 1;
    return a.localeCompare(b);
  });
  
  // Build tabs HTML - "All Project Managers" button first, then PM first names
  let html = '<button class="pm-tab-btn all-pm" data-pm="__ALL__">All Project Managers</button>';
  html += sortedPms.map(pm => {
    const firstName = pm.split(' ')[0];
    return `<button class="pm-tab-btn" data-pm="${pm}">${firstName}</button>`;
  }).join('');
  
  container.innerHTML = html;
  
  // Add click handlers
  container.querySelectorAll('.pm-tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      // Update active state
      container.querySelectorAll('.pm-tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Update state
      const selectedPm = btn.getAttribute('data-pm');
      pmTabsState[pageKey] = selectedPm;
      
      // Apply My PM View if needed
      if (typeof onSelect === 'function') {
        onSelect(selectedPm);
      }
    });
  });
  
  // Set initial selection
  const currentSelection = pmTabsState[pageKey] || '__ALL__';
  let initialBtn = container.querySelector(`[data-pm="${currentSelection}"]`);
  
  // If My PM View is enabled and user is a PM, select their tab
  if (getMyPmViewEnabled && typeof getMyPmViewEnabled === 'function' && getMyPmViewEnabled() && 
      isUserProjectManager && typeof isUserProjectManager === 'function' && isUserProjectManager()) {
    const pmName = getCurrentUserPmName ? getCurrentUserPmName() : null;
    if (pmName) {
      const pmBtn = container.querySelector(`[data-pm="${pmName}"]`);
      if (pmBtn) initialBtn = pmBtn;
    }
  }
  
  // Default to "All" if nothing else selected
  if (!initialBtn) {
    initialBtn = container.querySelector('[data-pm="__ALL__"]');
  }
  
  if (initialBtn) {
    initialBtn.classList.add('active');
    pmTabsState[pageKey] = initialBtn.getAttribute('data-pm');
  }
}

/**
 * Get the selected PM for a page (returns empty string for "All")
 */
function getSelectedPmForPage(pageKey) {
  const pm = pmTabsState[pageKey];
  return pm === '__ALL__' ? '' : pm;
}

/* ------------------------------------------------------------
   DATA CACHE - Centralized caching for financial data
   Reduces redundant network requests across pages
------------------------------------------------------------ */
const DataCache = {
  cache: {},
  loading: {},
  ttl: 5 * 60 * 1000, // 5 minute cache TTL
  
  async get(key, fetchFn) {
    const cached = this.cache[key];
    if (cached && (Date.now() - cached.timestamp) < this.ttl) {
      return cached.data;
    }
    
    if (this.loading[key]) {
      return this.loading[key];
    }
    
    this.loading[key] = fetchFn().then(data => {
      this.cache[key] = { data, timestamp: Date.now() };
      delete this.loading[key];
      return data;
    }).catch(err => {
      delete this.loading[key];
      throw err;
    });
    
    return this.loading[key];
  },
  
  async getGLData() {
    return this.get('gl', async () => {
      const resp = await fetch('data/financials_gl.json');
      const text = await resp.text();
      return JSON.parse(text.replace(/^\uFEFF/, ''));
    });
  },
  
  async getJobsData() {
    return this.get('jobs', async () => {
      const resp = await fetch('data/financials_jobs.json');
      const text = await resp.text();
      return JSON.parse(text.replace(/^\uFEFF/, ''));
    });
  },
  
  async getARData() {
    return this.get('ar', async () => {
      const resp = await fetch('data/ar_invoices.json');
      const text = await resp.text();
      return JSON.parse(text.replace(/^\uFEFF/, ''));
    });
  },
  
  async getAPData() {
    return this.get('ap', async () => {
      const resp = await fetch('data/ap_invoices.json');
      const text = await resp.text();
      return JSON.parse(text.replace(/^\uFEFF/, ''));
    });
  },
  
  async getAccountGroups() {
    return this.get('account_groups', async () => {
      const resp = await fetch('data/account_groups.json');
      const text = await resp.text();
      return JSON.parse(text.replace(/^\uFEFF/, ''));
    });
  },
  
  invalidate(key) {
    if (key) {
      delete this.cache[key];
    } else {
      this.cache = {};
    }
  },
  
  async getJobsMetrics() {
    return this.get('jobs_metrics', async () => {
      const resp = await fetch('/api/metrics/jobs?limit=10000&exclude_josh=false');
      return resp.json();
    });
  },
  
  async getARMetrics() {
    return this.get('ar_metrics', async () => {
      const resp = await fetch('/api/metrics/ar');
      return resp.json();
    });
  },
  
  async getAPMetrics() {
    return this.get('ap_metrics', async () => {
      const resp = await fetch('/api/metrics/ap');
      return resp.json();
    });
  },
  
  async getPMMetrics() {
    return this.get('pm_metrics', async () => {
      const resp = await fetch('/api/metrics/pm');
      return resp.json();
    });
  },
  
  async getMetricsSummary() {
    return this.get('metrics_summary', async () => {
      const resp = await fetch('/api/metrics/summary');
      return resp.json();
    });
  },
  
  preload() {
    this.getGLData().catch(() => {});
    this.getJobsData().catch(() => {});
    this.getJobsMetrics().catch(() => {});
  }
};

/* ------------------------------------------------------------
   MY PM VIEW - Username to PM Name Mapping
   Maps usernames to their full project manager names in the data
------------------------------------------------------------ */
const pmUsernameMapping = {
  'rodney': 'Rodney Terra',
  'kathy': 'Kathy Ross',
  'doris': 'Doris',
  'marcus': 'Mark Alvarado'
};

// Get current user's PM name if they are a project manager
function getCurrentUserPmName() {
  const currentUser = localStorage.getItem('ftg_current_user') || '';
  const username = currentUser.toLowerCase().trim();
  return pmUsernameMapping[username] || null;
}

// Check if current user has a PM name mapping
function isUserProjectManager() {
  return getCurrentUserPmName() !== null;
}

// Get/set My PM View preference
function getMyPmViewEnabled() {
  return localStorage.getItem('ftg_my_pm_view') === 'true';
}

function setMyPmViewEnabled(enabled) {
  localStorage.setItem('ftg_my_pm_view', enabled ? 'true' : 'false');
  updateMyPmViewUI();
  applyMyPmViewFilters();
}

// Update UI to reflect My PM View state
function updateMyPmViewUI() {
  const toggleContainer = document.getElementById('myPmViewToggleContainer');
  const toggle = document.getElementById('myPmViewToggle');
  const isPm = isUserProjectManager();
  const enabled = getMyPmViewEnabled();
  
  // Show/hide toggle in dropdown based on if user is a PM
  if (toggleContainer) {
    if (isPm) {
      toggleContainer.classList.remove('hidden');
    } else {
      toggleContainer.classList.add('hidden');
    }
  }
  
  // Sync toggle state
  if (toggle) {
    toggle.checked = enabled && isPm;
  }
  
  // Update/create the header badge
  updatePmViewBadge(enabled && isPm);
}

// Create/update the PM View badge in header
function updatePmViewBadge(show) {
  const headerRight = document.querySelector('.header-right');
  let badge = document.getElementById('pmViewBadge');
  
  if (show && isUserProjectManager()) {
    const pmName = getCurrentUserPmName();
    if (!badge) {
      badge = document.createElement('span');
      badge.id = 'pmViewBadge';
      badge.className = 'pm-view-badge';
      badge.innerHTML = `<span>My Jobs: ${pmName}</span><span class="close-badge" title="Disable My PM View">×</span>`;
      badge.querySelector('.close-badge').onclick = () => setMyPmViewEnabled(false);
      const darkModeToggle = document.getElementById('darkModeToggle');
      if (darkModeToggle && headerRight) {
        headerRight.insertBefore(badge, darkModeToggle);
      } else if (headerRight) {
        headerRight.prepend(badge);
      }
    } else {
      badge.querySelector('span:first-child').textContent = `My Jobs: ${pmName}`;
    }
  } else if (badge) {
    badge.remove();
  }
}

// Apply PM filters to all relevant pages when My PM View is enabled
function applyMyPmViewFilters() {
  const enabled = getMyPmViewEnabled() && isUserProjectManager();
  const pmName = getCurrentUserPmName();
  
  // Dropdown-based PM filters
  const dropdownFilters = [
    { id: 'joPmFilter', filterFn: filterJobOverview },
    { id: 'jbPmFilter', filterFn: filterJobBudgets },
    { id: 'mbPmFilter', filterFn: filterMissingBudgets },
    { id: 'jcPmFilter', filterFn: filterJobCosts }
  ];
  
  dropdownFilters.forEach(({ id, filterFn }) => {
    const select = document.getElementById(id);
    if (select) {
      if (enabled && pmName) {
        const option = Array.from(select.options).find(opt => 
          opt.value === pmName || opt.textContent === pmName
        );
        if (option) {
          select.value = option.value;
        }
      } else {
        // Reset to All when disabled
        select.value = '';
      }
      // Call the filter function if it exists
      if (typeof filterFn === 'function') {
        try { filterFn(); } catch(e) { console.log('Filter not ready:', id); }
      }
    }
  });
  
  // Job Actuals PM dropdown filter
  const jaPmSelect = document.getElementById('jaPmFilter');
  if (jaPmSelect) {
    if (enabled && pmName) {
      const option = Array.from(jaPmSelect.options).find(opt => opt.value === pmName);
      if (option) {
        jaPmSelect.value = pmName;
      }
    } else {
      jaPmSelect.value = '';
    }
    if (typeof filterJobActuals === 'function') {
      try { filterJobActuals(); } catch(e) { console.log('Job Actuals filter not ready'); }
    }
  }
  
  // Column-based filters (Payments - server-side)
  if (typeof paymentsColumnFilters !== 'undefined') {
    const filterBtn = document.querySelector('#paymentsTable .filter-btn[data-filter="project_manager"]');
    if (enabled && pmName) {
      paymentsColumnFilters['project_manager'] = new Set([pmName]);
      if (filterBtn) filterBtn.classList.add('has-filter');
    } else {
      delete paymentsColumnFilters['project_manager'];
      if (filterBtn) filterBtn.classList.remove('has-filter');
    }
    // Payments uses server-side pagination, reload page
    if (typeof loadPaymentsPage === 'function') {
      try { loadPaymentsPage(); } catch(e) { console.log('Payments not ready'); }
    }
  }
}

// Refresh data for the currently visible section
function refreshCurrentSection() {
  const visibleSection = document.querySelector('.dashboard-section.visible');
  if (!visibleSection) return;
  
  const sectionId = visibleSection.id;
  
  // Trigger appropriate refresh function
  switch (sectionId) {
    case 'jobOverview':
      if (typeof filterJobOverview === 'function') filterJobOverview();
      break;
    case 'jobBudgets':
      if (typeof filterJobBudgets === 'function') filterJobBudgets();
      break;
    case 'jobActuals':
      if (typeof filterJobActuals === 'function') filterJobActuals();
      break;
    case 'overUnderBilling':
      if (typeof initOverUnderBilling === 'function') initOverUnderBilling();
      break;
    case 'costCodes':
      if (typeof updateCostCodes === 'function') updateCostCodes();
      break;
    case 'missingBudgets':
      if (typeof filterMissingBudgets === 'function') filterMissingBudgets();
      break;
    case 'pmReport':
      if (typeof initPmReport === 'function') initPmReport();
      break;
    case 'aiInsights':
      if (typeof initAiInsights === 'function') initAiInsights();
      break;
    case 'payments':
      if (typeof loadPaymentsPage === 'function') loadPaymentsPage();
      break;
  }
}

// Initialize My PM View on page load
function initMyPmView() {
  const toggle = document.getElementById('myPmViewToggle');
  if (toggle) {
    toggle.addEventListener('change', function() {
      setMyPmViewEnabled(this.checked);
    });
  }
  
  // Update UI state
  updateMyPmViewUI();
  
  // Apply filters if enabled (after a small delay to let data load)
  if (getMyPmViewEnabled() && isUserProjectManager()) {
    setTimeout(() => applyMyPmViewFilters(), 500);
  }
}


/* ------------------------------------------------------------
   AUTO-SIZE FIRST COLUMN ON MOBILE
   Dynamically sizes sticky first column based on content width
   Note: On mobile (<768px), CSS handles column widths via table-layout: fixed
------------------------------------------------------------ */
function autoSizeFirstColumn(tableId) {
  // Let CSS handle mobile layout with fixed percentages
  if (window.innerWidth <= 768) return;
  
  const table = document.getElementById(tableId);
  if (!table) return;
  
  const firstCells = table.querySelectorAll("tbody tr td:first-child");
  if (firstCells.length === 0) return;
  
  let maxWidth = 0;
  const tempSpan = document.createElement("span");
  tempSpan.style.cssText = "position:absolute;visibility:hidden;white-space:nowrap;font:inherit;padding:0;";
  document.body.appendChild(tempSpan);
  
  firstCells.forEach(cell => {
    const text = cell.textContent.trim();
    const indent = cell.style.paddingLeft ? parseInt(cell.style.paddingLeft) : 0;
    tempSpan.style.font = window.getComputedStyle(cell).font;
    tempSpan.textContent = text;
    const textWidth = tempSpan.offsetWidth + indent + 24;
    maxWidth = Math.max(maxWidth, textWidth);
  });
  
  document.body.removeChild(tempSpan);
  
  const finalWidth = Math.min(Math.max(maxWidth, 100), 300);
  
  table.querySelectorAll("th:first-child, td:first-child").forEach(cell => {
    cell.style.minWidth = finalWidth + "px";
    cell.style.maxWidth = finalWidth + "px";
    cell.style.width = finalWidth + "px";
  });
}

/* ------------------------------------------------------------
   AUTO-SCALE FONT SIZE TO FILL CONTAINER WIDTH ON MOBILE
   Note: On mobile, CSS clamp() handles responsive font sizing
------------------------------------------------------------ */
function autoScaleFontSize(tableId, containerId) {
  // CSS clamp() handles font scaling on mobile now
  return;
}

/* ------------------------------------------------------------
   ANIMATED NUMBER COUNTER UTILITY
------------------------------------------------------------ */
function animateValue(element, start, end, duration, formatter) {
  if (!element) return;
  
  // Ensure we have valid numbers
  const startVal = typeof start === 'number' && !isNaN(start) ? start : 0;
  const endVal = typeof end === 'number' && !isNaN(end) ? end : 0;
  
  // If values are the same or very small difference, just set it
  if (Math.abs(endVal - startVal) < 0.01) {
    element.textContent = formatter ? formatter(endVal) : endVal;
    return;
  }
  
  const startTime = performance.now();
  const range = endVal - startVal;
  
  function easeOutQuart(t) {
    return 1 - Math.pow(1 - t, 4);
  }
  
  function update(currentTime) {
    const elapsed = currentTime - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const easedProgress = easeOutQuart(progress);
    const currentValue = startVal + (range * easedProgress);
    
    element.textContent = formatter ? formatter(currentValue) : currentValue.toFixed(0);
    
    if (progress < 1) {
      requestAnimationFrame(update);
    }
  }
  
  requestAnimationFrame(update);
}

function animateCurrency(element, endValue, duration = 600) {
  const currentText = element?.textContent || '$0';
  const currentValue = parseFloat(currentText.replace(/[$,KM%()]/g, '')) || 0;
  // Handle K and M suffixes
  let multiplier = 1;
  if (currentText.includes('M')) multiplier = 1000000;
  else if (currentText.includes('K')) multiplier = 1000;
  const startValue = currentValue * multiplier;
  
  animateValue(element, startValue, endValue, duration, (val) => {
    if (Math.abs(val) >= 1000000) return '$' + (val / 1000000).toFixed(1) + 'M';
    if (Math.abs(val) >= 1000) return '$' + (val / 1000).toFixed(0) + 'K';
    return '$' + Math.round(val).toLocaleString();
  });
}

function animatePercent(element, endValue, duration = 600, showPlusSign = true) {
  const currentText = element?.textContent || '0%';
  const currentValue = parseFloat(currentText.replace(/[%+]/g, '')) || 0;
  
  animateValue(element, currentValue, endValue, duration, (val) => {
    const prefix = showPlusSign && val >= 0 ? '+' : '';
    return prefix + val.toFixed(1) + '%';
  });
}

function animateRatio(element, endValue, duration = 600) {
  const currentText = element?.textContent || '0.00';
  const currentValue = parseFloat(currentText.replace('x', '')) || 0;
  
  animateValue(element, currentValue, endValue, duration, (val) => val.toFixed(2) + 'x');
}

/* ------------------------------------------------------------
   CHART FULLSCREEN FUNCTIONALITY
------------------------------------------------------------ */
let fullscreenChartInstance = null;

function setupChartExpandButtons() {
  document.querySelectorAll(".chart-expand-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const chartId = btn.dataset.chart;
      const title = btn.dataset.title;
      openChartFullscreen(chartId, title);
    });
  });
  
  document.querySelectorAll(".chart-close-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const metricCheckboxId = btn.dataset.metric;
      const checkbox = document.getElementById(metricCheckboxId);
      if (checkbox) {
        checkbox.checked = false;
        checkbox.dispatchEvent(new Event("change", { bubbles: true }));
      }
    });
  });
  
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") {
      closeChartFullscreen();
    }
  });
}

function openChartFullscreen(chartId, title) {
  const sourceChart = overviewChartInstances[chartId];
  if (!sourceChart) {
    // Fall back to page charts (revChart, acctChart, cashChart)
    openPageChartFullscreen(chartId, title);
    return;
  }
  
  const modal = document.getElementById("chartFullscreenModal");
  const titleEl = document.getElementById("chartFullscreenTitle");
  const canvas = document.getElementById("chartFullscreenCanvas");
  const statsEl = document.getElementById("chartFullscreenStats");
  
  titleEl.textContent = title;
  modal.classList.remove("hidden");
  document.body.style.overflow = "hidden";
  
  const sourceStatsEl = sourceChart.canvas.closest(".overview-metric-tile")?.querySelector(".metric-stats");
  if (sourceStatsEl) {
    statsEl.innerHTML = sourceStatsEl.innerHTML;
  }
  
  if (fullscreenChartInstance) {
    fullscreenChartInstance.destroy();
  }
  
  const ctx = canvas.getContext("2d");
  const config = JSON.parse(JSON.stringify(sourceChart.config));
  
  config.data = {
    labels: [...sourceChart.data.labels],
    datasets: sourceChart.data.datasets.map(ds => ({
      ...ds,
      backgroundColor: ds.type === "line" ? "transparent" : ds.backgroundColor,
      borderColor: ds.borderColor,
      data: [...ds.data],
      // Force white datalabels for fullscreen (override dataset-level dark colors)
      datalabels: { ...(ds.datalabels || {}), color: "#fff" }
    }))
  };
  
  config.options = {
    ...sourceChart.options,
    _isFullscreen: true,
    responsive: true,
    maintainAspectRatio: false,
    color: "#fff",
    layout: { padding: { top: 30 } },
    plugins: {
      ...sourceChart.options.plugins,
      legend: { 
        display: true, 
        position: "bottom",
        labels: { color: "#fff", font: { size: 10 }, boxWidth: 12, padding: 8 }
      },
      datalabels: {
        display: (context) => {
          // Hide data labels for trendlines
          if (context.dataset.type === 'line') return false;
          return true;
        },
        anchor: "end",
        align: "top",
        offset: 4,
        font: { size: 12, weight: "600" },
        color: "#fff",
        formatter: (value) => {
          if (value === 0 || value === null) return "";
          const isPercent = title.includes("%");
          if (isPercent) return value.toFixed(1) + "%";
          if (Math.abs(value) >= 1000000) return "$" + (value / 1000000).toFixed(1) + "M";
          if (Math.abs(value) >= 1000) return "$" + (value / 1000).toFixed(0) + "K";
          return "$" + value.toFixed(0);
        }
      }
    },
    scales: Object.fromEntries(
      Object.entries(sourceChart.options?.scales || { x: {}, y: {} }).map(([key, scale]) => [
        key,
        {
          ...scale,
          grid: { ...(scale.grid || {}), color: "rgba(255,255,255,0.1)" },
          ticks: { 
            ...(scale.ticks || {}), 
            color: "#fff", 
            font: { size: 12 },
            callback: scale.ticks?.callback || (key === 'y' ? (v => {
              const isPercent = title.includes("%");
              if (isPercent) return v.toFixed(0) + "%";
              if (Math.abs(v) >= 1000000) return "$" + (v / 1000000).toFixed(1) + "M";
              return "$" + (v / 1000).toFixed(0) + "K";
            }) : undefined)
          },
          title: scale.title ? { ...scale.title, color: "#fff" } : undefined
        }
      ])
    )
  };
  
  fullscreenChartInstance = new Chart(ctx, {
    type: "bar",
    data: config.data,
    plugins: [ChartDataLabels],
    options: config.options
  });
}

function closeChartFullscreen() {
  const modal = document.getElementById("chartFullscreenModal");
  modal.classList.add("hidden");
  document.body.style.overflow = "";
  
  if (fullscreenChartInstance) {
    fullscreenChartInstance.destroy();
    fullscreenChartInstance = null;
  }
}

function setupPageChartExpandButtons() {
  document.querySelectorAll(".page-chart-expand-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const chartId = btn.dataset.chart;
      const title = btn.dataset.title;
      openPageChartFullscreen(chartId, title);
    });
  });
}

function openPageChartFullscreen(chartId, title) {
  let sourceChart = null;
  let statsHtml = "";
  
  if (chartId === "revChart" && revChartInstance) {
    sourceChart = revChartInstance;
    const summaryTiles = document.getElementById("revSummaryTiles");
    if (summaryTiles) {
      const cagrValue = document.getElementById("revCagrValue")?.textContent || "-";
      const cagrNum = parseFloat(cagrValue.replace(/[%+]/g, '')) || 0;
      const cagrColor = cagrNum >= 0 ? '#10b981' : '#ef4444';
      statsHtml = `
        <div class="stat-box"><div class="stat-label">Average</div><div class="stat-value">${document.getElementById("revAvgValue")?.textContent || "-"}</div></div>
        <div class="stat-box"><div class="stat-label">Largest</div><div class="stat-value">${document.getElementById("revMaxValue")?.textContent || "-"}</div></div>
        <div class="stat-box"><div class="stat-label">Smallest</div><div class="stat-value">${document.getElementById("revMinValue")?.textContent || "-"}</div></div>
        <div class="stat-box"><div class="stat-label">CAGR</div><div class="stat-value" style="color: ${cagrColor}">${cagrValue}</div></div>
      `;
    }
  } else if (chartId === "acctChart" && acctChartInstance) {
    sourceChart = acctChartInstance;
    const summaryTiles = document.getElementById("acctSummaryTiles");
    if (summaryTiles) {
      const cagrValue = document.getElementById("acctCagrValue")?.textContent || "-";
      const cagrNum = parseFloat(cagrValue.replace(/[%+]/g, '')) || 0;
      const cagrColor = cagrNum >= 0 ? '#10b981' : '#ef4444';
      statsHtml = `
        <div class="stat-box"><div class="stat-label">Average</div><div class="stat-value">${document.getElementById("acctAvgValue")?.textContent || "-"}</div></div>
        <div class="stat-box"><div class="stat-label">Largest</div><div class="stat-value">${document.getElementById("acctMaxValue")?.textContent || "-"}</div></div>
        <div class="stat-box"><div class="stat-label">Smallest</div><div class="stat-value">${document.getElementById("acctMinValue")?.textContent || "-"}</div></div>
        <div class="stat-box"><div class="stat-label">CAGR</div><div class="stat-value" style="color: ${cagrColor}">${cagrValue}</div></div>
      `;
    }
  } else if (chartId === "cashChart" && cashChartInstance) {
    sourceChart = cashChartInstance;
    const growthValue = document.getElementById("cashGrowthValue")?.textContent || "-";
    const growthNum = parseFloat(growthValue.replace(/[%+]/g, '')) || 0;
    const growthColor = growthNum >= 0 ? '#10b981' : '#ef4444';
    statsHtml = `
      <div class="stat-box"><div class="stat-label">Average</div><div class="stat-value">${document.getElementById("cashAvgValue")?.textContent || "-"}</div></div>
      <div class="stat-box"><div class="stat-label">Highest</div><div class="stat-value">${document.getElementById("cashMaxValue")?.textContent || "-"}</div></div>
      <div class="stat-box"><div class="stat-label">Lowest</div><div class="stat-value">${document.getElementById("cashMinValue")?.textContent || "-"}</div></div>
      <div class="stat-box"><div class="stat-label">Growth</div><div class="stat-value" style="color: ${growthColor}">${growthValue}</div></div>
    `;
  } else if (chartId === "apAgingChart" && apAgingChart) {
    sourceChart = apAgingChart;
    const dateStr = document.getElementById("apAgingChartDate")?.textContent || "-";
    statsHtml = `
      <div class="stat-box"><div class="stat-label">0-30 Days</div><div class="stat-value">${document.getElementById("apAgingCurrent")?.textContent || "-"}</div></div>
      <div class="stat-box"><div class="stat-label">31-60 Days</div><div class="stat-value">${document.getElementById("apAging31to60")?.textContent || "-"}</div></div>
      <div class="stat-box"><div class="stat-label">61-90 Days</div><div class="stat-value">${document.getElementById("apAging61to90")?.textContent || "-"}</div></div>
      <div class="stat-box"><div class="stat-label">90+ Days</div><div class="stat-value" style="color: #ef4444">${document.getElementById("apAging90plus")?.textContent || "-"}</div></div>
      <div class="stat-box"><div class="stat-label">Total Due</div><div class="stat-value">${document.getElementById("apAgingTotalDue")?.textContent || "-"}</div></div>
    `;
    title = `AP Aging - as of: ${dateStr}`;
  } else if (chartId === "arAgingChart" && arAgingChart) {
    sourceChart = arAgingChart;
    const dateStr = document.getElementById("arAgingChartDate")?.textContent || "-";
    statsHtml = `
      <div class="stat-box"><div class="stat-label">0-30 Days</div><div class="stat-value">${document.getElementById("arAgingCurrent")?.textContent || "-"}</div></div>
      <div class="stat-box"><div class="stat-label">31-60 Days</div><div class="stat-value">${document.getElementById("arAging31to60")?.textContent || "-"}</div></div>
      <div class="stat-box"><div class="stat-label">61-90 Days</div><div class="stat-value">${document.getElementById("arAging61to90")?.textContent || "-"}</div></div>
      <div class="stat-box"><div class="stat-label">90+ Days</div><div class="stat-value" style="color: #ef4444">${document.getElementById("arAging90plus")?.textContent || "-"}</div></div>
      <div class="stat-box"><div class="stat-label">Total Due</div><div class="stat-value">${document.getElementById("arAgingTotalDue")?.textContent || "-"}</div></div>
    `;
    title = `AR Aging - as of: ${dateStr}`;
  } else if (chartId === "pmDonutChart" && pmDonutChart) {
    sourceChart = pmDonutChart;
    statsHtml = "";
  } else if (chartId === "customerDonutChart" && customerDonutChart) {
    sourceChart = customerDonutChart;
    statsHtml = "";
  } else if (chartId === "oubOverbilledChart" && oubOverbilledChart) {
    sourceChart = oubOverbilledChart;
    statsHtml = "";
  } else if (chartId === "oubUnderbilledChart" && oubUnderbilledChart) {
    sourceChart = oubUnderbilledChart;
    statsHtml = "";
  } else if (chartId === "ccRevenueChart" && ccRevenueChart) {
    sourceChart = ccRevenueChart;
    statsHtml = "";
  }
  
  if (!sourceChart) return;
  
  // Determine chart type
  const isDonutChart = chartId === "pmDonutChart" || chartId === "customerDonutChart";
  const isHorizontalBarChart = chartId === "oubOverbilledChart" || chartId === "oubUnderbilledChart" || chartId === "ccRevenueChart";
  
  const modal = document.getElementById("chartFullscreenModal");
  const titleEl = document.getElementById("chartFullscreenTitle");
  const canvas = document.getElementById("chartFullscreenCanvas");
  const statsEl = document.getElementById("chartFullscreenStats");
  
  titleEl.textContent = title;
  statsEl.innerHTML = statsHtml;
  modal.classList.remove("hidden");
  document.body.style.overflow = "hidden";
  
  if (fullscreenChartInstance) {
    fullscreenChartInstance.destroy();
  }
  
  const ctx = canvas.getContext("2d");
  
  // Determine if this is the cash chart - disable data labels for it
  const isCashChart = chartId === "cashChart";
  
  // Force white color for fullscreen mode (dark background) - override global defaults
  const fullscreenWhite = "#ffffff";
  const fullscreenGridColor = "rgba(255, 255, 255, 0.15)";
  
  // Handle doughnut charts differently
  if (isDonutChart) {
    fullscreenChartInstance = new Chart(ctx, {
      type: "doughnut",
      data: {
        labels: [...sourceChart.data.labels],
        datasets: sourceChart.data.datasets.map(ds => ({
          ...ds,
          data: [...ds.data],
          borderColor: '#1e293b',
          borderWidth: 3,
          datalabels: { ...(ds.datalabels || {}), color: "#fff" }
        }))
      },
      options: {
        _isFullscreen: true,
        responsive: true,
        maintainAspectRatio: false,
        color: fullscreenWhite,
        plugins: {
          legend: { 
            display: true, 
            position: "right",
            labels: { 
              color: fullscreenWhite, 
              font: { size: 14 }, 
              boxWidth: 16, 
              padding: 12,
              generateLabels: function(chart) {
                const data = chart.data;
                const total = data.datasets[0].data.reduce((a, b) => a + b, 0);
                return data.labels.map((label, i) => {
                  const value = data.datasets[0].data[i];
                  const pct = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                  return {
                    text: `${label}: ${pct}%`,
                    fillStyle: data.datasets[0].backgroundColor[i],
                    fontColor: fullscreenWhite,
                    strokeStyle: '#1e293b',
                    lineWidth: 2,
                    hidden: false,
                    index: i
                  };
                });
              }
            }
          },
          tooltip: {
            backgroundColor: "rgba(31, 41, 55, 0.95)",
            titleColor: fullscreenWhite,
            bodyColor: fullscreenWhite,
            callbacks: {
              label: function(context) {
                const value = context.raw;
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((value / total) * 100).toFixed(1);
                return `${formatCurrencyCompact(value)} (${pct}%)`;
              }
            }
          }
        }
      }
    });
  } else if (isHorizontalBarChart) {
    // Horizontal bar chart for Over/Under billing and Cost Codes
    const isPercentageChart = chartId === "ccRevenueChart";
    
    fullscreenChartInstance = new Chart(ctx, {
      type: "bar",
      data: {
        labels: [...sourceChart.data.labels],
        datasets: sourceChart.data.datasets.map(ds => ({
          ...ds,
          data: [...ds.data],
          datalabels: { ...(ds.datalabels || {}), color: "#fff" }
        }))
      },
      plugins: [ChartDataLabels],
      options: {
        _isFullscreen: true,
        responsive: true,
        maintainAspectRatio: false,
        indexAxis: 'y',
        color: fullscreenWhite,
        layout: { padding: { right: 60 } },
        plugins: {
          legend: { display: false },
          tooltip: {
            backgroundColor: "rgba(31, 41, 55, 0.95)",
            titleColor: fullscreenWhite,
            bodyColor: fullscreenWhite
          },
          datalabels: {
            display: true,
            anchor: "end",
            align: "right",
            offset: 4,
            font: { size: 12, weight: "600" },
            color: fullscreenWhite,
            formatter: (value) => {
              if (value === 0 || value === null) return "";
              if (isPercentageChart) return value.toFixed(1) + "%";
              if (Math.abs(value) >= 1000000) return "$" + (value / 1000000).toFixed(1) + "M";
              if (Math.abs(value) >= 1000) return "$" + (value / 1000).toFixed(0) + "K";
              return "$" + value.toFixed(0);
            }
          }
        },
        scales: {
          x: { 
            beginAtZero: true,
            grid: { color: fullscreenGridColor },
            ticks: { 
              color: fullscreenWhite, 
              font: { size: 12 },
              callback: v => {
                if (isPercentageChart) return v + "%";
                if (Math.abs(v) >= 1000000) return "$" + (v / 1000000).toFixed(1) + "M";
                if (Math.abs(v) >= 1000) return "$" + (v / 1000).toFixed(0) + "K";
                return "$" + v;
              }
            },
            title: isPercentageChart ? { display: true, text: '% of Revenue', color: fullscreenWhite } : undefined
          },
          y: {
            grid: { display: false },
            ticks: { color: fullscreenWhite, font: { size: 12 } }
          }
        }
      }
    });
  } else {
    // Get Y-axis min/max from source chart to maintain consistent scale
    const sourceYScale = sourceChart.options?.scales?.y || {};
    const yMin = sourceYScale.min;
    const yMax = sourceYScale.max;
    const isStacked = sourceChart.options?.scales?.x?.stacked || false;
    
    fullscreenChartInstance = new Chart(ctx, {
      type: "bar",
      data: {
        labels: [...sourceChart.data.labels],
        datasets: sourceChart.data.datasets.map(ds => ({
          ...ds,
          backgroundColor: ds.type === "line" ? "transparent" : ds.backgroundColor,
          borderColor: ds.borderColor,
          data: [...ds.data],
          datalabels: { ...(ds.datalabels || {}), color: "#fff" }
        }))
      },
      plugins: isCashChart ? [] : [ChartDataLabels],
      options: {
        _isFullscreen: true,
        responsive: true,
        maintainAspectRatio: false,
        color: fullscreenWhite,
        layout: { padding: { top: 30 } },
        plugins: {
          legend: { 
            display: true, 
            position: "bottom",
            labels: { color: fullscreenWhite, font: { size: 10 }, boxWidth: 12, padding: 8 }
          },
          tooltip: {
            backgroundColor: "rgba(31, 41, 55, 0.95)",
            titleColor: fullscreenWhite,
            bodyColor: fullscreenWhite
          },
          datalabels: isCashChart ? { display: false } : {
            display: true,
            anchor: "end",
            align: "top",
            offset: 4,
            font: { size: 12, weight: "600" },
            color: fullscreenWhite,
            formatter: (value) => {
              if (value === 0 || value === null) return "";
              if (Math.abs(value) >= 1000000) return "$" + (value / 1000000).toFixed(1) + "M";
              if (Math.abs(value) >= 1000) return "$" + (value / 1000).toFixed(0) + "K";
              return "$" + value.toFixed(0);
            }
          }
        },
        scales: {
          x: { 
            stacked: isStacked,
            grid: { color: fullscreenGridColor },
            ticks: { color: fullscreenWhite, font: { size: 14 } }
          },
          y: {
            stacked: isStacked,
            min: yMin,
            max: yMax,
            grid: { color: fullscreenGridColor },
            ticks: { 
              color: fullscreenWhite,
              font: { size: 12 },
              callback: v => {
                if (Math.abs(v) >= 1000000) return "$" + (v / 1000000).toFixed(1) + "M";
                return "$" + (v / 1000).toFixed(0) + "K";
              }
            }
          }
        }
      }
    });
  }
}

/* ------------------------------------------------------------
   USER SESSION MANAGEMENT
------------------------------------------------------------ */
function initAuth() {
  const loginScreen = document.getElementById("loginScreen");
  const logoutBtn = document.getElementById("logoutBtn");
  const currentUserEl = document.getElementById("currentUser");
  const userDropdownBtn = document.getElementById("userDropdownBtn");
  const userDropdownMenu = document.getElementById("userDropdownMenu");
  const changePasswordBtn = document.getElementById("changePasswordBtn");
  
  const isAuthenticated = localStorage.getItem("ftg_authenticated");
  const currentUser = localStorage.getItem("ftg_current_user");
  const cachedIsAdmin = localStorage.getItem("ftg_is_admin") === "true";
  const cachedRole = localStorage.getItem("ftg_user_role") || '';
  
  console.log('[DEBUG] initAuth - isAuthenticated:', isAuthenticated, 'currentUser:', currentUser);
  console.log('[DEBUG] initAuth - ftg_is_admin raw:', localStorage.getItem("ftg_is_admin"), 'cachedIsAdmin:', cachedIsAdmin, 'cachedRole:', cachedRole);
  
  if (isAuthenticated === "true" && currentUser) {
    loginScreen.classList.add("hidden");
    if (currentUserEl) {
      // Prefer display name from database, fall back to email
      const storedDisplayName = localStorage.getItem("ftg_display_name");
      const displayName = storedDisplayName || currentUser.split('@')[0].charAt(0).toUpperCase() + currentUser.split('@')[0].slice(1);
      currentUserEl.textContent = displayName;
    }
    
    // IMMEDIATELY show overview section to prevent blank screen on page refresh
    // This runs synchronously before async checkAdminAccess completes
    const overviewEl = document.getElementById('overview');
    const overviewNav = document.querySelector('.nav-item[data-section="overview"]');
    if (overviewEl && !document.querySelector('.dashboard-section.visible')) {
      overviewEl.classList.add('visible');
      if (overviewNav) overviewNav.classList.add('active');
      // Initialize overview data
      if (typeof initOverviewModule === 'function') initOverviewModule();
      if (typeof loadFinancialCharts === 'function') loadFinancialCharts();
    }
    
    // IMMEDIATELY show admin nav if user was previously identified as admin
    // This uses cached localStorage value before async API call completes
    console.log('[DEBUG] initAuth - checking cachedIsAdmin:', cachedIsAdmin);
    if (cachedIsAdmin) {
      const adminNavItem = document.getElementById('adminNavItem');
      console.log('[DEBUG] initAuth - adminNavItem found:', !!adminNavItem);
      if (adminNavItem) {
        adminNavItem.classList.remove('hidden');
        console.log('[DEBUG] initAuth - Removed hidden class from adminNavItem');
      }
      window.isAdminUser = true;
    }
    window.userRole = cachedRole;
  } else {
    // Not authenticated - show login screen, but also show overview as background content
    const overviewEl = document.getElementById('overview');
    if (overviewEl) overviewEl.classList.add('visible');
  }
  
  // User dropdown toggle
  if (userDropdownBtn && userDropdownMenu) {
    userDropdownBtn.onclick = function(e) {
      e.stopPropagation();
      userDropdownMenu.classList.toggle("hidden");
    };
    
    document.addEventListener("click", function(e) {
      if (!userDropdownBtn.contains(e.target) && !userDropdownMenu.contains(e.target)) {
        userDropdownMenu.classList.add("hidden");
      }
    });
  }
  
  if (logoutBtn) {
    logoutBtn.onclick = function() {
      localStorage.removeItem("ftg_authenticated");
      localStorage.removeItem("ftg_current_user");
      localStorage.removeItem("ftg_session_token");
      localStorage.removeItem("ftg_is_admin");
      localStorage.removeItem("ftg_user_role");
      localStorage.removeItem("ftg_display_name");
      if (currentUserEl) currentUserEl.textContent = "";
      if (userDropdownMenu) userDropdownMenu.classList.add("hidden");
      window.userPermissions = [];
      window.isAdminUser = false;
      window.userRole = '';
      const adminNavItem = document.getElementById('adminNavItem');
      if (adminNavItem) adminNavItem.classList.add('hidden');
      loginScreen.classList.remove("hidden");
    };
  }
  
  // Change password functionality
  if (changePasswordBtn) {
    changePasswordBtn.onclick = function() {
      if (userDropdownMenu) userDropdownMenu.classList.add("hidden");
      showChangePasswordModal();
    };
  }
  
  // Security settings (2FA)
  const securitySettingsBtn = document.getElementById("securitySettingsBtn");
  if (securitySettingsBtn) {
    securitySettingsBtn.onclick = function() {
      if (userDropdownMenu) userDropdownMenu.classList.add("hidden");
      showSecuritySettingsModal();
    };
  }
}

function showChangePasswordModal() {
  // Create modal if it doesn't exist
  let modal = document.getElementById("changePasswordModal");
  if (!modal) {
    modal = document.createElement("div");
    modal.id = "changePasswordModal";
    modal.className = "modal-overlay";
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-header">
          <h3>Change Password</h3>
          <button class="modal-close" id="changePasswordClose">&times;</button>
        </div>
        <div class="modal-body">
          <label>Current Password:</label>
          <input type="password" id="currentPasswordInput" placeholder="Enter current password">
          <label>New Password:</label>
          <input type="password" id="newPasswordInput" placeholder="Enter new password">
          <label>Confirm New Password:</label>
          <input type="password" id="confirmPasswordInput" placeholder="Confirm new password">
          <div id="changePasswordStatus" class="email-status"></div>
        </div>
        <div class="modal-footer">
          <button class="btn-secondary" id="changePasswordCancelBtn">Cancel</button>
          <button class="btn-primary" id="changePasswordSaveBtn">Save Password</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    
    // Event handlers
    document.getElementById("changePasswordClose").onclick = () => modal.classList.add("hidden");
    document.getElementById("changePasswordCancelBtn").onclick = () => modal.classList.add("hidden");
    document.getElementById("changePasswordSaveBtn").onclick = function() {
      const current = document.getElementById("currentPasswordInput").value;
      const newPass = document.getElementById("newPasswordInput").value;
      const confirm = document.getElementById("confirmPasswordInput").value;
      const status = document.getElementById("changePasswordStatus");
      
      const email = localStorage.getItem("ftg_current_user");
      if (!email) {
        status.textContent = "Please log in again.";
        status.className = "email-status error";
        return;
      }
      
      // Get current password (custom or default)
      const defaultPassword = "Ftgb2025$";
      const storedPassword = localStorage.getItem("ftg_pwd_" + email) || defaultPassword;
      
      if (current !== storedPassword) {
        status.textContent = "Current password is incorrect.";
        status.className = "email-status error";
        return;
      }
      
      if (newPass.length < 6) {
        status.textContent = "New password must be at least 6 characters.";
        status.className = "email-status error";
        return;
      }
      
      if (newPass !== confirm) {
        status.textContent = "New passwords do not match.";
        status.className = "email-status error";
        return;
      }
      
      // Save new password to localStorage
      localStorage.setItem("ftg_pwd_" + email, newPass);
      
      status.textContent = "Password changed successfully!";
      status.className = "email-status success";
      
      // Close modal after delay
      setTimeout(() => {
        const modal = getEl("changePasswordModal");
        if (modal) modal.classList.add("hidden");
      }, 1500);
    };
    
    modal.onclick = function(e) {
      if (e.target === modal) modal.classList.add("hidden");
    };
  }
  
  // Reset form and show
  setElValue("currentPasswordInput", "");
  setElValue("newPasswordInput", "");
  setElValue("confirmPasswordInput", "");
  setElText("changePasswordStatus", "");
  setElClass("changePasswordStatus", "email-status");
  modal.classList.remove("hidden");
}

async function showSecuritySettingsModal() {
  let modal = document.getElementById("securitySettingsModal");
  if (!modal) {
    modal = document.createElement("div");
    modal.id = "securitySettingsModal";
    modal.className = "modal-overlay";
    modal.innerHTML = `
      <div class="modal-content" style="max-width:500px;">
        <div class="modal-header">
          <h3>Security Settings</h3>
          <button class="modal-close" id="securitySettingsClose">&times;</button>
        </div>
        <div class="modal-body">
          <div id="twoFAStatusSection">
            <h4 style="margin-bottom:12px;">Two-Factor Authentication (2FA)</h4>
            <p id="twoFAStatusText" style="color:#6b7280;margin-bottom:16px;">Loading...</p>
            <div id="twoFAActions"></div>
          </div>
          <div id="twoFASetupSection" class="hidden" style="margin-top:20px;">
            <h4>Set Up 2FA</h4>
            <p style="color:#6b7280;font-size:14px;margin:12px 0;">Scan this QR code with your authenticator app (Google Authenticator, Authy, etc.)</p>
            <div style="text-align:center;margin:16px 0;">
              <img id="twoFAQRCode" src="" alt="2FA QR Code" style="max-width:200px;">
            </div>
            <p style="color:#6b7280;font-size:12px;margin:8px 0;">Or enter this code manually: <code id="twoFASecretCode" style="background:#f3f4f6;padding:4px 8px;border-radius:4px;"></code></p>
            <label style="margin-top:16px;display:block;">Enter verification code:</label>
            <input type="text" id="twoFASetupCode" placeholder="000000" maxlength="6" style="text-align:center;font-size:18px;">
            <div id="twoFASetupStatus" class="email-status" style="margin-top:8px;"></div>
            <div style="margin-top:16px;display:flex;gap:8px;">
              <button class="btn-secondary" id="twoFASetupCancelBtn">Cancel</button>
              <button class="btn-primary" id="twoFASetupConfirmBtn">Enable 2FA</button>
            </div>
          </div>
          <div id="twoFADisableSection" class="hidden" style="margin-top:20px;">
            <h4>Disable 2FA</h4>
            <p style="color:#6b7280;font-size:14px;margin:12px 0;">Enter your password to confirm:</p>
            <input type="password" id="twoFADisablePassword" placeholder="Your password">
            <div id="twoFADisableStatus" class="email-status" style="margin-top:8px;"></div>
            <div style="margin-top:16px;display:flex;gap:8px;">
              <button class="btn-secondary" id="twoFADisableCancelBtn">Cancel</button>
              <button class="btn-primary" id="twoFADisableConfirmBtn" style="background:#dc2626;">Disable 2FA</button>
            </div>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    
    document.getElementById("securitySettingsClose").onclick = () => modal.classList.add("hidden");
    modal.onclick = (e) => { if (e.target === modal) modal.classList.add("hidden"); };
  }
  
  modal.classList.remove("hidden");
  await load2FAStatus();
}

async function load2FAStatus() {
  const token = localStorage.getItem("ftg_session_token");
  const statusText = document.getElementById("twoFAStatusText");
  const actions = document.getElementById("twoFAActions");
  
  try {
    const response = await fetch("/api/2fa/status", {
      headers: { "Authorization": `Bearer ${token}` }
    });
    const data = await response.json();
    
    if (data.enabled) {
      statusText.innerHTML = `<span style="color:#10b981;">✓ 2FA is enabled</span>`;
      actions.innerHTML = `
        <button class="btn-secondary" id="disable2FABtn" style="background:#fee2e2;color:#dc2626;">Disable 2FA</button>
      `;
      document.getElementById("disable2FABtn").onclick = () => showDisable2FASection();
    } else {
      statusText.textContent = "2FA is not enabled. Enable it for extra security.";
      actions.innerHTML = `<button class="btn-primary" id="enable2FABtn">Enable 2FA</button>`;
      document.getElementById("enable2FABtn").onclick = () => start2FASetup();
    }
  } catch (e) {
    statusText.textContent = "Error loading 2FA status";
  }
}

async function start2FASetup() {
  const token = localStorage.getItem("ftg_session_token");
  document.getElementById("twoFAStatusSection").classList.add("hidden");
  document.getElementById("twoFASetupSection").classList.remove("hidden");
  
  try {
    const response = await fetch("/api/2fa/setup", {
      method: "POST",
      headers: { "Authorization": `Bearer ${token}`, "Content-Type": "application/json" }
    });
    const data = await response.json();
    
    if (data.success) {
      document.getElementById("twoFAQRCode").src = data.qr_code;
      document.getElementById("twoFASecretCode").textContent = data.secret;
      
      document.getElementById("twoFASetupCancelBtn").onclick = () => {
        document.getElementById("twoFASetupSection").classList.add("hidden");
        document.getElementById("twoFAStatusSection").classList.remove("hidden");
      };
      
      document.getElementById("twoFASetupConfirmBtn").onclick = async () => {
        const code = document.getElementById("twoFASetupCode").value.trim();
        const status = document.getElementById("twoFASetupStatus");
        
        if (!code) { status.textContent = "Enter the code"; status.className = "email-status error"; return; }
        
        const confirmRes = await fetch("/api/2fa/confirm", {
          method: "POST",
          headers: { "Authorization": `Bearer ${token}`, "Content-Type": "application/json" },
          body: JSON.stringify({ code })
        });
        const confirmData = await confirmRes.json();
        
        if (confirmData.success) {
          document.getElementById("twoFASetupSection").classList.add("hidden");
          document.getElementById("twoFAStatusSection").classList.remove("hidden");
          load2FAStatus();
        } else {
          status.textContent = confirmData.error || "Verification failed";
          status.className = "email-status error";
        }
      };
    }
  } catch (e) {
    console.error("2FA setup error:", e);
  }
}

function showDisable2FASection() {
  document.getElementById("twoFAStatusSection").classList.add("hidden");
  document.getElementById("twoFADisableSection").classList.remove("hidden");
  document.getElementById("twoFADisablePassword").value = "";
  document.getElementById("twoFADisableStatus").textContent = "";
  
  document.getElementById("twoFADisableCancelBtn").onclick = () => {
    document.getElementById("twoFADisableSection").classList.add("hidden");
    document.getElementById("twoFAStatusSection").classList.remove("hidden");
  };
  
  document.getElementById("twoFADisableConfirmBtn").onclick = async () => {
    const password = document.getElementById("twoFADisablePassword").value;
    const status = document.getElementById("twoFADisableStatus");
    const token = localStorage.getItem("ftg_session_token");
    
    if (!password) { status.textContent = "Enter your password"; status.className = "email-status error"; return; }
    
    const response = await fetch("/api/2fa/disable", {
      method: "POST",
      headers: { "Authorization": `Bearer ${token}`, "Content-Type": "application/json" },
      body: JSON.stringify({ password })
    });
    const data = await response.json();
    
    if (data.success) {
      document.getElementById("twoFADisableSection").classList.add("hidden");
      document.getElementById("twoFAStatusSection").classList.remove("hidden");
      load2FAStatus();
    } else {
      status.textContent = data.error || "Failed to disable 2FA";
      status.className = "email-status error";
    }
  };
}

document.addEventListener("DOMContentLoaded", function() {
  initAuth();
  initMyPmView();
  initSidebar();
  initNavigation();
  initConfigPanels();
  setupExportButtons();
  setupChartExpandButtons();
  setupPageChartExpandButtons();
  setupMetricInfoButtons();
  setupDarkModeToggle();
  updateDataAsOfDates();
  initAllSavedViewsHandlers();
});

/* ------------------------------------------------------------
   DARK MODE TOGGLE FUNCTIONALITY
------------------------------------------------------------ */
function setupDarkModeToggle() {
  const toggle = document.getElementById("darkModeToggle");
  const themeSelect = document.getElementById("themeSelect");
  
  // Load saved theme preference and apply immediately
  const savedTheme = localStorage.getItem("ftg_theme") || "dark";
  applyTheme(savedTheme);
  
  // Sync dropdown with current theme
  if (themeSelect) {
    themeSelect.value = savedTheme;
    themeSelect.addEventListener("change", (e) => {
      const newTheme = e.target.value;
      applyTheme(newTheme);
      localStorage.setItem("ftg_theme", newTheme);
      updateChartColorsForTheme(newTheme);
    });
  }
  
  // Header toggle button
  if (toggle) {
    toggle.addEventListener("click", () => {
      const currentTheme = document.documentElement.getAttribute("data-theme") || "light";
      const newTheme = currentTheme === "dark" ? "light" : "dark";
      applyTheme(newTheme);
      localStorage.setItem("ftg_theme", newTheme);
      updateChartColorsForTheme(newTheme);
      if (themeSelect) themeSelect.value = newTheme;
    });
  }
}

function applyTheme(theme) {
  if (theme === "dark") {
    document.documentElement.setAttribute("data-theme", "dark");
    document.body.classList.add("dark-mode");
    initChartJsThemeDefaults("dark");
  } else {
    document.documentElement.removeAttribute("data-theme");
    document.body.classList.remove("dark-mode");
    initChartJsThemeDefaults("light");
  }
}

function applyJobBudgetsDarkModeStyles(theme) {
  // This function is now a no-op - styles handled by CSS
  // Keeping function to avoid errors from existing calls
}

/* ------------------------------------------------------------
   CHART THEME MANAGER - Centralized theme color management
   Reads colors from CSS custom properties for consistency
------------------------------------------------------------ */
const ChartThemeManager = {
  _palette: null,
  _listeners: [],
  
  refresh() {
    const styles = getComputedStyle(document.documentElement);
    this._palette = {
      text: styles.getPropertyValue('--chart-text').trim() || '#374151',
      grid: styles.getPropertyValue('--chart-grid').trim() || 'rgba(0,0,0,0.1)',
      legend: styles.getPropertyValue('--chart-legend').trim() || '#374151',
      datalabel: styles.getPropertyValue('--chart-datalabel').trim() || '#374151',
      gradientStart: styles.getPropertyValue('--chart-gradient-start').trim() || '#2563eb',
      gradientEnd: styles.getPropertyValue('--chart-gradient-end').trim() || '#60a5fa',
      barPrimary: styles.getPropertyValue('--chart-bar-primary').trim() || '#3b82f6',
      barSecondary: styles.getPropertyValue('--chart-bar-secondary').trim() || '#10b981',
      barTertiary: styles.getPropertyValue('--chart-bar-tertiary').trim() || '#f59e0b',
      lineTotal: styles.getPropertyValue('--chart-line-total').trim() || '#dc2626'
    };
    this._notifyListeners();
    return this._palette;
  },
  
  getPalette() {
    if (!this._palette) this.refresh();
    return this._palette;
  },
  
  createGradient(ctx, vertical = true) {
    const p = this.getPalette();
    const gradient = vertical 
      ? ctx.createLinearGradient(0, 0, 0, 300)
      : ctx.createLinearGradient(0, 0, 300, 0);
    gradient.addColorStop(0, p.gradientStart);
    gradient.addColorStop(1, p.gradientEnd);
    return gradient;
  },
  
  onThemeChange(callback) {
    this._listeners.push(callback);
  },
  
  _notifyListeners() {
    this._listeners.forEach(cb => cb(this._palette));
  }
};

/* ------------------------------------------------------------
   CHART THEME PLUGIN - Auto-applies theme colors on every chart update
   Uses afterInit to apply theme colors once without causing loops
------------------------------------------------------------ */
const ChartThemePlugin = {
  id: 'chartThemePlugin',
  
  afterInit(chart) {
    applyThemeToChart(chart);
  }
};

function applyThemeToChart(chart) {
  const p = ChartThemeManager.getPalette();
  if (!p || !chart || !chart.options) return;
  
  // Skip theme application for fullscreen charts (they have forced white colors)
  if (chart.options._isFullscreen) return;
  
  // Update scales only for cartesian charts (bar, line, etc.)
  // Skip for pie, doughnut, polarArea, radar which don't have x/y scales
  if (chart.options.scales && typeof chart.options.scales === 'object') {
    Object.keys(chart.options.scales).forEach(scaleKey => {
      const scale = chart.options.scales[scaleKey];
      if (scale && typeof scale === 'object') {
        if (!scale.ticks) scale.ticks = {};
        scale.ticks.color = p.text;
        if (!scale.grid) scale.grid = {};
        scale.grid.color = p.grid;
      }
    });
  }
  
  // Update legend labels (works for all chart types)
  if (chart.options.plugins) {
    if (chart.options.plugins.legend?.labels) {
      chart.options.plugins.legend.labels.color = p.legend;
    }
    // Update datalabels
    if (chart.options.plugins.datalabels) {
      chart.options.plugins.datalabels.color = p.datalabel;
    }
  }
  
  // Regenerate gradients for datasets flagged with _useThemeGradient
  // Respects per-dataset type override for mixed charts
  if (chart.data?.datasets && chart.ctx) {
    chart.data.datasets.forEach(dataset => {
      if (dataset._useThemeGradient) {
        // Determine effective type: dataset-level type overrides chart-level type
        const effectiveType = dataset.type || chart.config?.type;
        // Apply gradient only to bar/area fill datasets, not line strokes
        if (effectiveType === 'bar' || (effectiveType === 'line' && dataset.fill)) {
          dataset.backgroundColor = ChartThemeManager.createGradient(chart.ctx, dataset._gradientVertical !== false);
        }
      }
    });
  }
}

// Register the plugin globally when Chart.js is available
if (typeof Chart !== 'undefined') {
  Chart.register(ChartThemePlugin);
}

function getChartThemeColors() {
  const p = ChartThemeManager.getPalette();
  return {
    gridColor: p.grid,
    textColor: p.text,
    legendColor: p.legend
  };
}

function initChartJsThemeDefaults(theme) {
  if (typeof Chart === "undefined") return;
  
  ChartThemeManager.refresh();
  const p = ChartThemeManager.getPalette();
  
  Chart.defaults.color = p.text;
  Chart.defaults.borderColor = p.grid;
  
  if (Chart.defaults.scales) {
    if (Chart.defaults.scales.linear) {
      Chart.defaults.scales.linear.ticks = Chart.defaults.scales.linear.ticks || {};
      Chart.defaults.scales.linear.ticks.color = p.text;
      Chart.defaults.scales.linear.grid = Chart.defaults.scales.linear.grid || {};
      Chart.defaults.scales.linear.grid.color = p.grid;
    }
    if (Chart.defaults.scales.category) {
      Chart.defaults.scales.category.ticks = Chart.defaults.scales.category.ticks || {};
      Chart.defaults.scales.category.ticks.color = p.text;
      Chart.defaults.scales.category.grid = Chart.defaults.scales.category.grid || {};
      Chart.defaults.scales.category.grid.color = p.grid;
    }
  }
  
  if (Chart.defaults.plugins && Chart.defaults.plugins.legend) {
    Chart.defaults.plugins.legend.labels = Chart.defaults.plugins.legend.labels || {};
    Chart.defaults.plugins.legend.labels.color = p.legend;
  }
}

function updateChartColorsForTheme(theme) {
  // Refresh the palette from CSS variables (CSS vars change when data-theme changes)
  initChartJsThemeDefaults(theme);
  
  // Apply theme colors to all existing charts and trigger update
  if (typeof Chart !== "undefined" && Chart.instances) {
    Object.values(Chart.instances).forEach(chart => {
      if (chart) {
        applyThemeToChart(chart);
        chart.update('none');
      }
    });
  }
}

function setupMetricInfoButtons() {
  document.querySelectorAll(".metric-info-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const infoText = btn.dataset.info;
      if (infoText) {
        showMetricInfoPopup(infoText);
      }
    });
  });
}

function showMetricInfoPopup(text) {
  closeMetricInfoPopup();
  
  const overlay = document.createElement("div");
  overlay.className = "metric-info-popup-overlay";
  overlay.id = "metricInfoOverlay";
  overlay.addEventListener("click", closeMetricInfoPopup);
  
  const popup = document.createElement("div");
  popup.className = "metric-info-popup";
  popup.id = "metricInfoPopup";
  popup.innerHTML = `
    <div class="metric-info-popup-text">${text}</div>
    <button class="metric-info-popup-close">Got it</button>
  `;
  
  document.body.appendChild(overlay);
  document.body.appendChild(popup);
  
  popup.querySelector(".metric-info-popup-close").addEventListener("click", closeMetricInfoPopup);
}

function closeMetricInfoPopup() {
  const overlay = document.getElementById("metricInfoOverlay");
  const popup = document.getElementById("metricInfoPopup");
  if (overlay) overlay.remove();
  if (popup) popup.remove();
}

// Global data timestamps
let dataTimestamps = {
  gl: null,
  jobs: null,
  ar: null,
  ap: null,
  latest: null
};

async function loadDataTimestamps() {
  try {
    const [glResp, metricsResp] = await Promise.all([
      DataCache.getGLData().catch(() => null),
      DataCache.getMetricsSummary().catch(() => null)
    ]);
    
    dataTimestamps.gl = glResp?.generated_at || null;
    dataTimestamps.jobs = metricsResp?.last_refresh || null;
    dataTimestamps.ar = metricsResp?.last_refresh || null;
    dataTimestamps.ap = metricsResp?.last_refresh || null;
    
    // Find the most recent timestamp
    const timestamps = [dataTimestamps.gl, dataTimestamps.jobs, dataTimestamps.ar, dataTimestamps.ap]
      .filter(t => t)
      .map(t => new Date(t))
      .sort((a, b) => b - a);
    
    dataTimestamps.latest = timestamps[0] || new Date();
    
    // Update all data as of elements
    updateAllDataAsOfElements();
  } catch (e) {
    console.error('Error loading data timestamps:', e);
  }
}

function formatDataTimestamp(date) {
  if (!date) return 'Unknown';
  const d = new Date(date);
  return d.toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric',
    hour: 'numeric',
    minute: '2-digit'
  });
}

function formatDataTimestampShort(date) {
  if (!date) return 'Unknown';
  const d = new Date(date);
  return d.toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'short', 
    day: 'numeric'
  });
}

function updateAllDataAsOfElements() {
  const dateStr = formatDataTimestampShort(dataTimestamps.latest);
  
  // All DataAsOf element IDs
  const elementIds = [
    'revDataAsOf', 'acctDataAsOf', 'isDataAsOf', 'overviewDataAsOf',
    'bsDataAsOf', 'cfDataAsOf', 'cashDataAsOf', 
    'jobBudgetsDataAsOf', 'jobOverviewDataAsOf', 'jobActualsDataAsOf', 
    'jobCostsDataAsOf', 'missingBudgetsDataAsOf', 'pmrDataAsOf',
    'arAgingDataAsOf', 'apAgingDataAsOf', 'aiInsightsDataAsOf'
  ];
  
  elementIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.textContent = dateStr;
  });
}

function updateDataAsOfDates() {
  // Load timestamps from data files and update all elements
  loadDataTimestamps();
}

function initConfigPanels() {
  document.querySelectorAll(".config-header").forEach(header => {
    header.addEventListener("click", (e) => {
      // Ignore clicks on the expand button itself - it will handle its own click
      if (e.target.classList.contains('config-expand-btn')) return;
      
      const targetId = header.dataset.target;
      const body = document.getElementById(targetId);
      if (body) {
        body.classList.toggle("collapsed");
        header.classList.toggle("collapsed");
        updateConfigExpandBtn(header);
      }
    });
    
    // Handle expand button click
    const expandBtn = header.querySelector('.config-expand-btn');
    if (expandBtn) {
      expandBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        const targetId = header.dataset.target;
        const body = document.getElementById(targetId);
        if (body) {
          body.classList.toggle("collapsed");
          header.classList.toggle("collapsed");
          updateConfigExpandBtn(header);
        }
      });
    }
  });
}

function updateConfigExpandBtn(header) {
  const expandBtn = header.querySelector('.config-expand-btn');
  if (expandBtn) {
    const isCollapsed = header.classList.contains('collapsed');
    expandBtn.textContent = isCollapsed ? 'Expand ▼' : 'Collapse ▲';
  }
}

function initSidebar() {
  const sidebar = document.getElementById("sidebar");
  const overlay = document.getElementById("overlay");
  const mobileBtn = document.getElementById("mobileMenuButton");

  if (mobileBtn) {
    mobileBtn.addEventListener("click", () => {
      sidebar.classList.add("open");
      overlay.classList.remove("hidden");
      document.body.classList.add("menu-open");
    });
  }

  if (overlay) {
    overlay.addEventListener("click", () => {
      closeMobileSidebar();
    });
  }
}

function closeMobileSidebar() {
  const sidebar = document.getElementById("sidebar");
  const overlay = document.getElementById("overlay");
  if (sidebar) sidebar.classList.remove("open");
  if (overlay) overlay.classList.add("hidden");
  document.body.classList.remove("menu-open");
}

function initNavigation() {
  const navItems = document.querySelectorAll(".nav-item[data-section]");
  const sections = document.querySelectorAll(".dashboard-section");
  const sidebar = document.getElementById("sidebar");
  const overlay = document.getElementById("overlay");
  const layout = document.querySelector(".layout");

  // Handle sidebar collapse toggle
  const sidebarCollapseBtn = document.getElementById("sidebarCollapseBtn");
  if (sidebarCollapseBtn && sidebar) {
    // Restore collapsed state from localStorage
    const isCollapsed = localStorage.getItem("ftg_sidebar_collapsed") === "true";
    if (isCollapsed) {
      sidebar.classList.add("collapsed");
      if (layout) layout.classList.add("sidebar-collapsed");
    }
    
    sidebarCollapseBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      sidebar.classList.toggle("collapsed");
      if (layout) layout.classList.toggle("sidebar-collapsed");
      localStorage.setItem("ftg_sidebar_collapsed", sidebar.classList.contains("collapsed"));
    });
  }

  // Handle expandable nav sections (Financials, Jobs, Distribution Reports)
  const sectionHeaders = document.querySelectorAll(".nav-section-header");
  sectionHeaders.forEach(header => {
    const childrenContainer = header.nextElementSibling;
    if (childrenContainer && childrenContainer.classList.contains("nav-section-items")) {
      // Start expanded by default
      header.classList.add("expanded");
      childrenContainer.classList.add("expanded");
      
      header.addEventListener("click", () => {
        header.classList.toggle("expanded");
        childrenContainer.classList.toggle("expanded");
      });
    }
  });

  // Keep references for auto-expand logic
  const finStatementsParent = document.getElementById("navFinancialStatements");
  const finStatementsChildren = document.getElementById("navFinancialStatementsChildren");
  const jobsParent = document.getElementById("navJobs");
  const jobsChildren = document.getElementById("navJobsChildren");
  const distReportsParent = document.getElementById("navDistReports");
  const distReportsChildren = document.getElementById("navDistReportsChildren");

  navItems.forEach(item => {
    item.addEventListener("click", () => {
      const id = item.dataset.section;
      
      // Check permission before allowing navigation
      if (typeof sectionToPermission !== 'undefined' && typeof window.userPermissions !== 'undefined') {
        const permKey = sectionToPermission[id];
        if (permKey && !window.isAdminUser && !window.userPermissions.includes(permKey)) {
          console.warn('Access denied to section:', id);
          return; // Block navigation
        }
      }
      
      // Remove old states
      navItems.forEach(i => i.classList.remove("active"));
      sections.forEach(s => s.classList.remove("visible"));

      // Activate clicked
      item.classList.add("active");
      const section = document.getElementById(id);
      if (section) section.classList.add("visible");
      
      // Hide export ribbon on admin page and placeholder distribution reports pages only
      const exportArea = document.querySelector('.content-export-area');
      const hideExportPages = ['admin', 'deptHeadMeeting', 'monthEndReporting'];
      if (exportArea) {
        exportArea.style.display = hideExportPages.includes(id) ? 'none' : '';
      }

      // Auto-expand Financials if child is clicked
      if (item.classList.contains("nav-child") && finStatementsParent && finStatementsChildren) {
        const fsChildren = ['overview', 'incomeStatement', 'balanceSheet', 'cashFlows', 'cashReports', 'accounts', 'payments', 'apAging', 'arAging'];
        if (fsChildren.includes(id)) {
          finStatementsParent.classList.add("expanded");
          finStatementsChildren.classList.add("expanded");
        }
      }
      
      // Auto-expand Jobs if child is clicked
      if (item.classList.contains("nav-child") && jobsParent && jobsChildren) {
        const jobsChildItems = ['jobOverview', 'jobBudgets', 'jobActuals', 'overUnderBilling', 'costCodes', 'missingBudgets', 'pmReport', 'payments', 'jobAnalytics'];
        if (jobsChildItems.includes(id)) {
          jobsParent.classList.add("expanded");
          jobsChildren.classList.add("expanded");
        }
      }
      
      // Auto-expand Distribution Reports if child is clicked
      if (item.classList.contains("nav-child") && distReportsParent && distReportsChildren) {
        const distReportsChildItems = ['deptHeadMeeting', 'cashReport', 'monthEndReporting'];
        if (distReportsChildItems.includes(id)) {
          distReportsParent.classList.add("expanded");
          distReportsChildren.classList.add("expanded");
        }
      }

      // Auto-close sidebar on mobile
      if (window.innerWidth <= 768) {
        closeMobileSidebar();
      }

      // Section-specific loaders
      if (id === "overview") {
        initOverviewModule();
        loadFinancialCharts();
      }
      if (id === "financials") loadFinancialCharts();
      if (id === "accounts") initAccountModule();
      if (id === "incomeStatement") loadIncomeStatement();
      if (id === "balanceSheet") initBalanceSheet();
      if (id === "cashFlows") loadCashFlowStatement();
      if (id === "cashReports") initCashReports();
      if (id === "cashReport") initCashReport();
      if (id === "jobOverview") initJobOverview();
      if (id === "jobBudgets") initJobBudgets();
      if (id === "jobActuals") initJobActuals();
      if (id === "overUnderBilling") initOverUnderBilling();
      if (id === "costCodes") initCostCodes();
      if (id === "missingBudgets") initMissingBudgets();
      if (id === "pmReport") initPmReport();
      if (id === "aiInsights") initAiInsights();
      if (id === "payments") initPayments();
      if (id === "apAging") initApAging();
      if (id === "arAging") initArAging();
    });
  });
  
  initAllAiPanelToggles();
}

function initAllAiPanelToggles() {
  ['overview', 'rev', 'acct', 'bs', 'jo', 'jb', 'ja', 'pmr'].forEach(prefix => {
    const panel = document.getElementById(`${prefix}AiAnalysisPanel`);
    const header = document.getElementById(`${prefix}AiAnalysisHeader`);
    const analyzeBtn = document.getElementById(`${prefix}AiAnalyzeBtn`);
    if (header && panel) header.addEventListener("click", (e) => {
      if (analyzeBtn && (e.target === analyzeBtn || analyzeBtn.contains(e.target))) return;
      panel.classList.toggle("collapsed");
    });
  });
  
  const overviewBtn = document.getElementById('overviewAiAnalyzeBtn');
  if (overviewBtn) overviewBtn.addEventListener('click', performOverviewAiAnalysis);
  
  const revBtn = document.getElementById('revAiAnalyzeBtn');
  if (revBtn) revBtn.addEventListener('click', performRevenueAiAnalysis);
  
  const acctBtn = document.getElementById('acctAiAnalyzeBtn');
  if (acctBtn) acctBtn.addEventListener('click', performAccountAiAnalysis);
  
  const bsBtn = document.getElementById('bsAiAnalyzeBtn');
  if (bsBtn) bsBtn.addEventListener('click', performBalanceSheetAiAnalysis);
  
  const joBtn = document.getElementById('joAiAnalyzeBtn');
  if (joBtn) joBtn.addEventListener('click', performJobOverviewAiAnalysis);
  
  const jbBtn = document.getElementById('jbAiAnalyzeBtn');
  if (jbBtn) jbBtn.addEventListener('click', performJobBudgetsAiAnalysis);
  
  const jaBtn = document.getElementById('jaAiAnalyzeBtn');
  if (jaBtn) jaBtn.addEventListener('click', performJobActualsAiAnalysis);
  
  const arAiBtn = document.getElementById('arAiAnalyzeBtn');
  if (arAiBtn) arAiBtn.addEventListener('click', performARAgingAiAnalysis);
  
  const apAiBtn = document.getElementById('apAiAnalyzeBtn');
  if (apAiBtn) apAiBtn.addEventListener('click', performAPAgingAiAnalysis);
  
  const dcrBtn = document.getElementById('dcrAiAnalyzeBtn');
  if (dcrBtn) dcrBtn.addEventListener('click', performCashReportAiAnalysis);
  
  const dcrEmailBtn = document.getElementById('dcrEmailReportBtn');
  if (dcrEmailBtn) dcrEmailBtn.addEventListener('click', emailCashReport);
  
}

async function performOverviewAiAnalysis() {
  const btn = document.getElementById('overviewAiAnalyzeBtn');
  const panel = document.getElementById('overviewAiAnalysisPanel');
  const content = document.getElementById('overviewAiAnalysisContent');
  btn.disabled = true;
  btn.textContent = 'Analyzing...';
  panel.classList.remove('collapsed');
  content.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div>Analyzing overview...</div>';
  try {
    const statementData = extractOverviewChartData();
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit ? '/api/analyze-overview' : '/.netlify/functions/analyze-overview';
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({statementData, periodInfo: 'Executive Overview'})
    });
    const result = await response.json();
    if (result.success) {
      content.innerHTML = formatMarkdown(result.analysis);
      panel.classList.add('has-analysis');
    } else {
      content.innerHTML = `<div style="color: #dc2626;">Error: ${result.error}</div>`;
    }
  } catch (e) {
    content.innerHTML = `<div style="color: #dc2626;">Error: ${e.message}</div>`;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Run Analysis';
  }
}

function extractOverviewChartData() {
  let text = "Executive Overview Metrics:\n\n";
  
  const tiles = document.querySelectorAll('.overview-metric-tile');
  tiles.forEach(tile => {
    const title = tile.querySelector('.metric-tile-title')?.textContent.trim() || 'Unknown';
    text += `${title}:\n`;
    
    const statsDiv = tile.querySelector('.metric-stats');
    if (statsDiv) {
      const statBoxes = statsDiv.querySelectorAll('.stat-box');
      statBoxes.forEach(box => {
        const label = box.querySelector('.stat-label')?.textContent.trim() || '';
        const value = box.querySelector('.stat-value')?.textContent.trim() || '-';
        if (label) {
          text += `  ${label}: ${value}\n`;
        }
      });
    }
    text += "\n";
  });
  
  return text || "No overview data available";
}

async function performJobOverviewAiAnalysis() {
  const btn = document.getElementById('joAiAnalyzeBtn');
  const panel = document.getElementById('joAiAnalysisPanel');
  const content = document.getElementById('joAiAnalysisContent');
  btn.disabled = true;
  btn.textContent = 'Analyzing...';
  panel.classList.remove('collapsed');
  content.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div>Analyzing job data...</div>';
  try {
    const statementData = extractJobOverviewData();
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit ? '/api/analyze-jobs' : '/.netlify/functions/analyze-jobs';
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({statementData, periodInfo: 'Job Overview Analysis'})
    });
    const result = await response.json();
    if (result.success) {
      content.innerHTML = formatMarkdown(result.analysis);
      panel.classList.add('has-analysis');
    } else {
      content.innerHTML = `<div style="color: #dc2626;">Error: ${result.error}</div>`;
    }
  } catch (e) {
    content.innerHTML = `<div style="color: #dc2626;">Error: ${e.message}</div>`;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Run Analysis';
  }
}

function extractJobOverviewData() {
  let text = "Job Overview Analysis:\n\n";
  
  // Get filter selections
  const statusFilters = [];
  if (document.getElementById('joStatusActive')?.checked) statusFilters.push('Active');
  if (document.getElementById('joStatusInactive')?.checked) statusFilters.push('Inactive');
  if (document.getElementById('joStatusClosed')?.checked) statusFilters.push('Closed');
  if (document.getElementById('joStatusOverhead')?.checked) statusFilters.push('Overhead');
  text += `Filters: ${statusFilters.join(', ') || 'None'}\n`;
  
  const pmFilter = document.getElementById('joPmFilter')?.value || 'All';
  const clientFilter = document.getElementById('joCustomerFilter')?.value || 'All';
  text += `Project Manager: ${pmFilter || 'All'}\n`;
  text += `Client: ${clientFilter || 'All'}\n\n`;
  
  // Get key metrics
  text += "Key Metrics:\n";
  const metrics = [
    { id: 'joTotalJobs', label: 'Total Jobs' },
    { id: 'joContractValue', label: 'Contract Value' },
    { id: 'joBilledRevenue', label: 'Billed Revenue' },
    { id: 'joOverUnderValue', label: 'Over/(Under) Bill' },
    { id: 'joEstProfitMargin', label: 'Est. Profit Margin' }
  ];
  metrics.forEach(m => {
    const el = document.getElementById(m.id);
    if (el) text += `  ${m.label}: ${el.textContent.trim()}\n`;
  });
  text += "\n";
  
  // Get chart summary stats
  const chartSections = [
    { title: 'By Project Manager', charts: ['pmJobsChart', 'pmContractChart', 'pmMarginChart'] },
    { title: 'By Client', charts: ['customerJobsChart', 'customerContractChart', 'customerMarginChart'] }
  ];
  
  chartSections.forEach(section => {
    text += `${section.title}:\n`;
    section.charts.forEach(chartId => {
      const container = document.getElementById(chartId)?.closest('.jo-chart-container');
      if (container) {
        const title = container.querySelector('.jo-chart-title')?.textContent.trim() || chartId;
        text += `  ${title}:\n`;
        const statTiles = container.querySelectorAll('.jo-stat-tile');
        statTiles.forEach(tile => {
          const label = tile.querySelector('.jo-stat-label')?.textContent.trim() || '';
          const value = tile.querySelector('.jo-stat-value')?.textContent.trim() || '';
          const name = tile.querySelector('.jo-stat-name')?.textContent.trim() || '';
          if (label && value) {
            text += `    ${label}: ${value}${name ? ` (${name})` : ''}\n`;
          }
        });
      }
    });
    text += "\n";
  });
  
  return text || "No job overview data available";
}

async function performJobBudgetsAiAnalysis() {
  const btn = document.getElementById('jbAiAnalyzeBtn');
  const panel = document.getElementById('jbAiAnalysisPanel');
  const content = document.getElementById('jbAiAnalysisContent');
  btn.disabled = true;
  btn.textContent = 'Analyzing...';
  panel.classList.remove('collapsed');
  content.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div>Analyzing job budgets...</div>';
  try {
    const statementData = extractJobBudgetsData();
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit ? '/api/analyze-jobs' : '/.netlify/functions/analyze-jobs';
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({statementData, periodInfo: 'Job Budgets Analysis'})
    });
    const result = await response.json();
    if (result.success) {
      content.innerHTML = formatMarkdown(result.analysis);
      panel.classList.add('has-analysis');
    } else {
      content.innerHTML = `<div style="color: #dc2626;">Error: ${result.error}</div>`;
    }
  } catch (e) {
    content.innerHTML = `<div style="color: #dc2626;">Error: ${e.message}</div>`;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Run Analysis';
  }
}

function extractJobBudgetsData() {
  let text = "Job Budgets Analysis:\n\n";
  
  // Get key metrics
  text += "Key Metrics:\n";
  const metrics = [
    { id: 'jobTotalCount', label: 'Total Jobs' },
    { id: 'jobTotalContract', label: 'Total Contract Value' },
    { id: 'jobTotalCost', label: 'Total Est. Cost' },
    { id: 'jobTotalProfit', label: 'Total Est. Profit' },
    { id: 'jobAvgMargin', label: 'Avg Profit Margin' }
  ];
  metrics.forEach(m => {
    const el = document.getElementById(m.id);
    if (el) text += `  ${m.label}: ${el.textContent.trim()}\n`;
  });
  text += "\n";
  
  // Get breakdown by PM
  const pmBody = document.getElementById('jobPmBreakdownBody');
  if (pmBody) {
    text += "Breakdown by Project Manager:\n";
    const rows = pmBody.querySelectorAll('tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      if (cells.length >= 5) {
        const pm = cells[0]?.textContent.trim() || '';
        const jobs = cells[1]?.textContent.trim() || '';
        const contract = cells[2]?.textContent.trim() || '';
        const margin = cells[5]?.textContent.trim() || '';
        text += `  ${pm}: ${jobs} jobs, ${contract} contract, ${margin} margin\n`;
      }
    });
    text += "\n";
  }
  
  // Get breakdown by Client
  const custBody = document.getElementById('jobCustomerBreakdownBody');
  if (custBody) {
    text += "Breakdown by Client:\n";
    const rows = custBody.querySelectorAll('tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      if (cells.length >= 5) {
        const cust = cells[0]?.textContent.trim() || '';
        const jobs = cells[1]?.textContent.trim() || '';
        const contract = cells[2]?.textContent.trim() || '';
        const margin = cells[5]?.textContent.trim() || '';
        text += `  ${cust}: ${jobs} jobs, ${contract} contract, ${margin} margin\n`;
      }
    });
  }
  
  return text || "No job budgets data available";
}

async function performJobActualsAiAnalysis() {
  const btn = document.getElementById('jaAiAnalyzeBtn');
  const panel = document.getElementById('jaAiAnalysisPanel');
  const content = document.getElementById('jaAiAnalysisContent');
  btn.disabled = true;
  btn.textContent = 'Analyzing...';
  panel.classList.remove('collapsed');
  content.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div>Analyzing job actuals...</div>';
  try {
    const statementData = extractJobActualsData();
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit ? '/api/analyze-jobs' : '/.netlify/functions/analyze-jobs';
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({statementData, periodInfo: 'Job Actuals Analysis'})
    });
    if (!response.ok) {
      const errorText = await response.text();
      let errorMsg = `Server error (${response.status})`;
      try {
        const errorJson = JSON.parse(errorText);
        errorMsg = errorJson.error || errorMsg;
      } catch (parseErr) {
        if (errorText) errorMsg = errorText;
      }
      content.innerHTML = `<div style="color: #dc2626;">Error: ${errorMsg}</div>`;
      return;
    }
    const result = await response.json();
    if (result.success) {
      content.innerHTML = formatMarkdown(result.analysis);
      panel.classList.add('has-analysis');
    } else {
      content.innerHTML = `<div style="color: #dc2626;">Error: ${result.error || 'Unknown error'}</div>`;
    }
  } catch (e) {
    content.innerHTML = `<div style="color: #dc2626;">Error: ${e.message || 'Failed to analyze. Please try again.'}</div>`;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Run Analysis';
  }
}

async function performARAgingAiAnalysis() {
  const btn = document.getElementById('arAiAnalyzeBtn');
  const panel = document.getElementById('arAiAnalysisPanel');
  const content = document.getElementById('arAiAnalysisContent');
  btn.disabled = true;
  btn.textContent = 'Analyzing...';
  panel.classList.remove('collapsed');
  content.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div>Analyzing AR aging...</div>';
  try {
    const agingData = extractARAgingData();
    const periodInfo = document.getElementById('arAgingDataAsOf')?.textContent || 'Current';
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit ? '/api/analyze-ar-aging' : '/.netlify/functions/analyze-ar-aging';
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({agingData, periodInfo})
    });
    const result = await response.json();
    if (result.success) {
      content.innerHTML = '<p style="margin:0;line-height:1.6;">' + result.analysis + '</p>';
      panel.classList.add('has-analysis');
    } else {
      content.innerHTML = '<div style="color: #dc2626;">Error: ' + result.error + '</div>';
    }
  } catch (e) {
    content.innerHTML = '<div style="color: #dc2626;">Error: ' + e.message + '</div>';
  } finally {
    btn.disabled = false;
    btn.textContent = 'Run Analysis';
  }
}

function extractARAgingData() {
  let text = "AR Aging Summary:\n";
  text += "Total Due: " + (document.getElementById('arAgingTotalDue')?.textContent || '$0') + "\n";
  text += "Total Retainage: " + (document.getElementById('arAgingRetainage')?.textContent || '$0') + "\n";
  text += "Current (0-30 Days): " + (document.getElementById('arAgingCurrent')?.textContent || '$0') + "\n";
  text += "31-60 Days: " + (document.getElementById('arAging31to60')?.textContent || '$0') + "\n";
  text += "61-90 Days: " + (document.getElementById('arAging61to90')?.textContent || '$0') + "\n";
  text += "90+ Days: " + (document.getElementById('arAging90plus')?.textContent || '$0') + "\n\n";
  
  // Get top customers from table
  const table = document.getElementById('arAgingTable');
  if (table) {
    const rows = table.querySelectorAll('tbody tr:not(.customer-detail-row)');
    text += "Top Customers by Total Due:\n";
    let count = 0;
    rows.forEach(row => {
      if (count < 5) {
        const cells = row.querySelectorAll('td');
        if (cells.length >= 2) {
          const customer = cells[0]?.textContent.trim() || '';
          const totalDue = cells[1]?.textContent.trim() || '$0';
          if (customer) {
            text += "- " + customer + ": " + totalDue + "\n";
            count++;
          }
        }
      }
    });
  }
  
  return text;
}

async function performAPAgingAiAnalysis() {
  const btn = document.getElementById('apAiAnalyzeBtn');
  const panel = document.getElementById('apAiAnalysisPanel');
  const content = document.getElementById('apAiAnalysisContent');
  btn.disabled = true;
  btn.textContent = 'Analyzing...';
  panel.classList.remove('collapsed');
  content.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div>Analyzing AP aging...</div>';
  try {
    const agingData = extractAPAgingData();
    const periodInfo = document.getElementById('apAgingDataAsOf')?.textContent || 'Current';
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit ? '/api/analyze-ap-aging' : '/.netlify/functions/analyze-ap-aging';
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({agingData, periodInfo})
    });
    const result = await response.json();
    if (result.success) {
      content.innerHTML = '<p style="margin:0;line-height:1.6;">' + result.analysis + '</p>';
      panel.classList.add('has-analysis');
    } else {
      content.innerHTML = '<div style="color: #dc2626;">Error: ' + result.error + '</div>';
    }
  } catch (e) {
    content.innerHTML = '<div style="color: #dc2626;">Error: ' + e.message + '</div>';
  } finally {
    btn.disabled = false;
    btn.textContent = 'Run Analysis';
  }
}

function extractAPAgingData() {
  let text = "AP Aging Summary:\n";
  text += "Total Due: " + (document.getElementById('apAgingTotalDue')?.textContent || '$0') + "\n";
  text += "Total Retainage: " + (document.getElementById('apAgingRetainage')?.textContent || '$0') + "\n";
  text += "Current (0-30 Days): " + (document.getElementById('apAgingCurrent')?.textContent || '$0') + "\n";
  text += "31-60 Days: " + (document.getElementById('apAging31to60')?.textContent || '$0') + "\n";
  text += "61-90 Days: " + (document.getElementById('apAging61to90')?.textContent || '$0') + "\n";
  text += "90+ Days: " + (document.getElementById('apAging90plus')?.textContent || '$0') + "\n\n";
  
  // Get top vendors from table
  const table = document.getElementById('apAgingTable');
  if (table) {
    const rows = table.querySelectorAll('tbody tr:not(.vendor-detail-row)');
    text += "Top Vendors by Total Due:\n";
    let count = 0;
    rows.forEach(row => {
      if (count < 5) {
        const cells = row.querySelectorAll('td');
        if (cells.length >= 2) {
          const vendor = cells[0]?.textContent.trim() || '';
          const totalDue = cells[1]?.textContent.trim() || '$0';
          if (vendor) {
            text += "- " + vendor + ": " + totalDue + "\n";
            count++;
          }
        }
      }
    });
  }
  
  return text;
}



function extractJobActualsData() {
  let text = "Job Actuals Analysis:\n\n";
  
  // Get key metrics
  text += "Key Metrics:\n";
  const metrics = [
    { id: 'jaTotalCount', label: 'Total Jobs' },
    { id: 'jaTotalBilledRevenue', label: 'Total Billed Revenue' },
    { id: 'jaTotalEarnedRevenue', label: 'Total Earned Revenue' },
    { id: 'jaTotalActualCost', label: 'Total Actual Cost' },
    { id: 'jaOverUnderValue', label: 'Over/(Under) Bill' },
    { id: 'jaAvgMargin', label: 'Avg Actual Margin' }
  ];
  metrics.forEach(m => {
    const el = document.getElementById(m.id);
    if (el) text += `  ${m.label}: ${el.textContent.trim()}\n`;
  });
  text += "\n";
  
  // Get breakdown by PM
  const pmBody = document.getElementById('jaPmBreakdownBody');
  if (pmBody) {
    text += "Breakdown by Project Manager:\n";
    const rows = pmBody.querySelectorAll('tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      if (cells.length >= 5) {
        const pm = cells[0]?.textContent.trim() || '';
        const jobs = cells[1]?.textContent.trim() || '';
        const earned = cells[2]?.textContent.trim() || '';
        const cost = cells[3]?.textContent.trim() || '';
        const margin = cells[5]?.textContent.trim() || '';
        text += `  ${pm}: ${jobs} jobs, ${earned} earned, ${cost} cost, ${margin} margin\n`;
      }
    });
    text += "\n";
  }
  
  // Get breakdown by Client
  const custBody = document.getElementById('jaCustomerBreakdownBody');
  if (custBody) {
    text += "Breakdown by Client:\n";
    const rows = custBody.querySelectorAll('tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      if (cells.length >= 5) {
        const cust = cells[0]?.textContent.trim() || '';
        const jobs = cells[1]?.textContent.trim() || '';
        const earned = cells[2]?.textContent.trim() || '';
        const cost = cells[3]?.textContent.trim() || '';
        const margin = cells[5]?.textContent.trim() || '';
        text += `  ${cust}: ${jobs} jobs, ${earned} earned, ${cost} cost, ${margin} margin\n`;
      }
    });
  }
  
  return text || "No job actuals data available";
}

async function performRevenueAiAnalysis() {
  const btn = document.getElementById('revAiAnalyzeBtn');
  const panel = document.getElementById('revAiAnalysisPanel');
  const content = document.getElementById('revAiAnalysisContent');
  btn.disabled = true;
  btn.textContent = 'Analyzing...';
  panel.classList.remove('collapsed');
  content.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div>Analyzing revenue...</div>';
  try {
    const statementData = extractRevenueChartData();
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit ? '/api/analyze-revenue' : '/.netlify/functions/analyze-revenue';
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({statementData, periodInfo: 'Revenue Analysis'})
    });
    const result = await response.json();
    if (result.success) {
      content.innerHTML = formatMarkdown(result.analysis);
      panel.classList.add('has-analysis');
    } else {
      content.innerHTML = `<div style="color: #dc2626;">Error: ${result.error}</div>`;
    }
  } catch (e) {
    content.innerHTML = `<div style="color: #dc2626;">Error: ${e.message}</div>`;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Run Analysis';
  }
}

function extractRevenueChartData() {
  let text = "Revenue Analysis:\n\n";
  
  // Try to get revenue summary stats
  const summaryDiv = document.getElementById('revenueSummary');
  if (summaryDiv) {
    const stats = summaryDiv.querySelectorAll('.stat-item');
    stats.forEach(stat => {
      const label = stat.querySelector('.stat-label')?.textContent.trim() || '';
      const value = stat.querySelector('.stat-value')?.textContent.trim() || '';
      if (label && value) {
        text += `${label}: ${value}\n`;
      }
    });
  }
  
  // Try to get revenue table
  const table = document.getElementById('revenueTable');
  if (table) {
    text += "\nRevenue Table:\n";
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('th, td');
      const rowData = [];
      cells.forEach(cell => {
        rowData.push(cell.textContent.trim());
      });
      text += rowData.join("\t") + "\n";
    });
  }
  
  return text || "No revenue data available";
}

async function performAccountAiAnalysis() {
  const btn = document.getElementById('acctAiAnalyzeBtn');
  const panel = document.getElementById('acctAiAnalysisPanel');
  const content = document.getElementById('acctAiAnalysisContent');
  btn.disabled = true;
  btn.textContent = 'Analyzing...';
  panel.classList.remove('collapsed');
  content.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div>Analyzing account...</div>';
  try {
    const statementData = extractAccountChartData();
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit ? '/api/analyze-account' : '/.netlify/functions/analyze-account';
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({statementData, periodInfo: 'Account Detail'})
    });
    const result = await response.json();
    if (result.success) {
      content.innerHTML = formatMarkdown(result.analysis);
      panel.classList.add('has-analysis');
    } else {
      content.innerHTML = `<div style="color: #dc2626;">Error: ${result.error}</div>`;
    }
  } catch (e) {
    content.innerHTML = `<div style="color: #dc2626;">Error: ${e.message}</div>`;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Run Analysis';
  }
}

function extractAccountChartData() {
  let text = "Account Detail:\n\n";
  
  // Get account info
  const acctSelector = document.getElementById('acctSelector');
  if (acctSelector) {
    const selectedText = acctSelector.options[acctSelector.selectedIndex]?.text || 'Unknown Account';
    text += `Account: ${selectedText}\n\n`;
  }
  
  // Get account detail table
  const table = document.getElementById('acctTable');
  if (table) {
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('th, td');
      const rowData = [];
      cells.forEach(cell => {
        rowData.push(cell.textContent.trim());
      });
      text += rowData.join("\t") + "\n";
    });
  }
  
  return text || "No account data available";
}

async function performBalanceSheetAiAnalysis() {
  const btn = document.getElementById('bsAiAnalyzeBtn');
  const panel = document.getElementById('bsAiAnalysisPanel');
  const content = document.getElementById('bsAiAnalysisContent');
  btn.disabled = true;
  btn.textContent = 'Analyzing...';
  panel.classList.remove('collapsed');
  content.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div>Analyzing balance sheet...</div>';
  try {
    const statementData = extractBalanceSheetData();
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit ? '/api/analyze-balance-sheet' : '/.netlify/functions/analyze-balance-sheet';
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({statementData, periodInfo: 'Balance Sheet'})
    });
    const result = await response.json();
    if (result.success) {
      content.innerHTML = formatMarkdown(result.analysis);
      panel.classList.add('has-analysis');
    } else {
      content.innerHTML = `<div style="color: #dc2626;">Error: ${result.error}</div>`;
    }
  } catch (e) {
    content.innerHTML = `<div style="color: #dc2626;">Error: ${e.message}</div>`;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Run Analysis';
  }
}

function extractBalanceSheetData() {
  let text = "Balance Sheet:\n\n";
  
  const table = document.getElementById('balanceSheetTable');
  if (table) {
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('th, td');
      const rowData = [];
      cells.forEach(cell => {
        rowData.push(cell.textContent.trim());
      });
      text += rowData.join("\t") + "\n";
    });
  }
  
  return text || "No balance sheet data available";
}

/* ------------------------------------------------------------
   EXECUTIVE OVERVIEW MODULE
------------------------------------------------------------ */
const currentUserEl = document.getElementById("currentUser");
if (currentUserEl) currentUserEl.innerText = "";

let overviewDataCache = null;
let overviewChartInstances = {};

/* ------------------------------------------------------------
   USER PREFERENCES SYSTEM
------------------------------------------------------------ */
const metricTileMapping = {
  revenue: "overviewRevenueChart",
  grossMargin: "overviewGrossMarginChart",
  opMargin: "overviewOpMarginChart",
  cash: "overviewCashChart",
  arApRatio: "overviewArApRatioChart",
  overUnder: "overviewOverUnderChart"
};

function getCurrentUser() {
  try {
    return localStorage.getItem("ftg_current_user") || null;
  } catch (e) {
    console.warn("Unable to access localStorage:", e);
    return null;
  }
}

function getUserPreferences() {
  try {
    const user = getCurrentUser();
    if (!user) return {};
    const stored = localStorage.getItem(`ftg_prefs_${user}`);
    if (!stored) return {};
    return JSON.parse(stored);
  } catch (e) {
    console.warn("Error reading preferences:", e);
    return {};
  }
}

function saveUserPreferences(prefs) {
  try {
    const user = getCurrentUser();
    if (!user) return;
    const existing = getUserPreferences();
    const merged = { ...existing, ...prefs };
    localStorage.setItem(`ftg_prefs_${user}`, JSON.stringify(merged));
  } catch (e) {
    console.warn("Error saving preferences:", e);
  }
}

/* ------------------------------------------------------------
   SAVED VIEWS MANAGER - Named view configurations per page
------------------------------------------------------------ */
const SavedViewManager = {
  getStorageKey() {
    const user = getCurrentUser();
    return user ? `ftg_views_${user}` : null;
  },
  
  getAllViews() {
    try {
      const key = this.getStorageKey();
      if (!key) return {};
      const stored = localStorage.getItem(key);
      return stored ? JSON.parse(stored) : {};
    } catch (e) {
      console.warn("Error reading saved views:", e);
      return {};
    }
  },
  
  saveAllViews(data) {
    try {
      const key = this.getStorageKey();
      if (!key) return false;
      localStorage.setItem(key, JSON.stringify(data));
      return true;
    } catch (e) {
      console.warn("Error saving views:", e);
      return false;
    }
  },
  
  getPageViews(page) {
    const all = this.getAllViews();
    return all[page] || { selectedId: null, views: {} };
  },
  
  saveView(page, name, config) {
    const all = this.getAllViews();
    if (!all[page]) all[page] = { selectedId: null, views: {} };
    const id = "view_" + Date.now();
    all[page].views[id] = { name, config, createdAt: new Date().toISOString() };
    all[page].selectedId = id;
    this.saveAllViews(all);
    return id;
  },
  
  deleteView(page, viewId) {
    const all = this.getAllViews();
    if (all[page] && all[page].views[viewId]) {
      delete all[page].views[viewId];
      if (all[page].selectedId === viewId) {
        all[page].selectedId = null;
      }
      this.saveAllViews(all);
      return true;
    }
    return false;
  },
  
  selectView(page, viewId) {
    const all = this.getAllViews();
    if (!all[page]) all[page] = { selectedId: null, views: {} };
    all[page].selectedId = viewId;
    this.saveAllViews(all);
  },
  
  getSelectedView(page) {
    const pageData = this.getPageViews(page);
    if (pageData.selectedId && pageData.views[pageData.selectedId]) {
      return { id: pageData.selectedId, ...pageData.views[pageData.selectedId] };
    }
    return null;
  }
};

function generateViewId() {
  return "view_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
}

/* ------------------------------------------------------------
   SAVED VIEWS - Page-specific collect/apply functions
------------------------------------------------------------ */
const PageViewConfigs = {
  overview: {
    collect() {
      const metrics = {};
      document.querySelectorAll("[data-metric]").forEach(cb => {
        metrics[cb.dataset.metric] = cb.checked;
      });
      return {
        viewType: document.getElementById("overviewViewType")?.value,
        year: document.getElementById("overviewYear")?.value,
        compare: document.getElementById("overviewCompare")?.checked,
        trendline: document.getElementById("overviewTrend")?.checked,
        dataLabels: document.getElementById("overviewDataLabels")?.checked,
        excludeCurrent: document.getElementById("overviewExclude")?.checked,
        rangeStart: document.getElementById("overviewRangeStart")?.value,
        rangeEnd: document.getElementById("overviewRangeEnd")?.value,
        metrics
      };
    },
    apply(cfg) {
      if (!cfg) return;
      if (cfg.viewType) {
        const el = document.getElementById("overviewViewType");
        if (el) el.value = cfg.viewType;
      }
      if (cfg.year) {
        const el = document.getElementById("overviewYear");
        if (el && el.querySelector(`option[value="${cfg.year}"]`)) el.value = cfg.year;
      }
      if (cfg.compare !== undefined) {
        const el = document.getElementById("overviewCompare");
        if (el) el.checked = cfg.compare;
      }
      if (cfg.trendline !== undefined) {
        const el = document.getElementById("overviewTrend");
        if (el) el.checked = cfg.trendline;
      }
      if (cfg.dataLabels !== undefined) {
        const el = document.getElementById("overviewDataLabels");
        if (el) el.checked = cfg.dataLabels;
      }
      if (cfg.excludeCurrent !== undefined) {
        const el = document.getElementById("overviewExclude");
        if (el) el.checked = cfg.excludeCurrent;
      }
      if (cfg.rangeStart) {
        const el = document.getElementById("overviewRangeStart");
        if (el) {
          el.value = cfg.rangeStart;
          const label = document.getElementById("overviewRangeStartLabel");
          if (label) label.textContent = cfg.rangeStart;
        }
      }
      if (cfg.rangeEnd) {
        const el = document.getElementById("overviewRangeEnd");
        if (el) {
          el.value = cfg.rangeEnd;
          const label = document.getElementById("overviewRangeEndLabel");
          if (label) label.textContent = cfg.rangeEnd;
        }
      }
      if (cfg.metrics) {
        Object.keys(cfg.metrics).forEach(metric => {
          const cb = document.querySelector(`[data-metric="${metric}"]`);
          if (cb) cb.checked = cfg.metrics[metric];
        });
      }
      const viewType = document.getElementById("overviewViewType")?.value;
      if (viewType) {
        syncTimePeriodButtons(viewType);
      }
    },
    refresh() {
      applyMetricVisibility();
      if (typeof updateOverviewCharts === "function") updateOverviewCharts();
    }
  },
  
  revenue: {
    collect() {
      return {
        viewType: document.getElementById("revViewType")?.value,
        year: document.getElementById("revYear")?.value,
        compare: document.getElementById("revCompare")?.checked,
        trendline: document.getElementById("revTrendline")?.checked,
        dataLabels: document.getElementById("revDataLabels")?.checked,
        excludeCurrent: document.getElementById("revExcludeCurrent")?.checked,
        rangeStart: document.getElementById("revRangeStart")?.value,
        rangeEnd: document.getElementById("revRangeEnd")?.value
      };
    },
    apply(cfg) {
      if (!cfg) return;
      if (cfg.viewType) {
        const el = document.getElementById("revViewType");
        if (el) el.value = cfg.viewType;
      }
      if (cfg.year) {
        const el = document.getElementById("revYear");
        if (el && el.querySelector(`option[value="${cfg.year}"]`)) el.value = cfg.year;
      }
      if (cfg.compare !== undefined) {
        const el = document.getElementById("revCompare");
        if (el) el.checked = cfg.compare;
      }
      if (cfg.trendline !== undefined) {
        const el = document.getElementById("revTrendline");
        if (el) el.checked = cfg.trendline;
      }
      if (cfg.dataLabels !== undefined) {
        const el = document.getElementById("revDataLabels");
        if (el) el.checked = cfg.dataLabels;
      }
      if (cfg.excludeCurrent !== undefined) {
        const el = document.getElementById("revExcludeCurrent");
        if (el) el.checked = cfg.excludeCurrent;
      }
      if (cfg.rangeStart) {
        const el = document.getElementById("revRangeStart");
        if (el) {
          el.value = cfg.rangeStart;
          const label = document.getElementById("revRangeStartLabel");
          if (label) label.textContent = cfg.rangeStart;
        }
      }
      if (cfg.rangeEnd) {
        const el = document.getElementById("revRangeEnd");
        if (el) {
          el.value = cfg.rangeEnd;
          const label = document.getElementById("revRangeEndLabel");
          if (label) label.textContent = cfg.rangeEnd;
        }
      }
      const view = cfg.viewType || "monthly";
      const yearWrap = document.getElementById("revYearWrapper");
      const rangeWrap = document.getElementById("revRangeWrapper");
      const compareLabel = document.getElementById("revCompare")?.closest("label");
      if (view === "annual") {
        if (yearWrap) yearWrap.style.display = "none";
        if (rangeWrap) rangeWrap.classList.remove("hidden");
        if (compareLabel) compareLabel.style.display = "none";
      } else {
        if (yearWrap) yearWrap.style.display = "flex";
        if (rangeWrap) rangeWrap.classList.add("hidden");
        if (compareLabel) compareLabel.style.display = "";
      }
    },
    refresh() {
      if (revenueDataCache && typeof updateRevenueView === "function") updateRevenueView(revenueDataCache);
    }
  },
  
  accounts: {
    collect() {
      return {
        account: document.getElementById("acctSelect")?.value,
        viewType: document.getElementById("acctViewType")?.value,
        year: document.getElementById("acctYear")?.value,
        trendline: document.getElementById("acctTrendline")?.checked,
        dataLabels: document.getElementById("acctDataLabels")?.checked,
        excludeCurrent: document.getElementById("acctExcludeCurrent")?.checked,
        rangeStart: document.getElementById("acctRangeStart")?.value,
        rangeEnd: document.getElementById("acctRangeEnd")?.value
      };
    },
    apply(cfg) {
      if (!cfg) return;
      if (cfg.account) {
        const el = document.getElementById("acctSelect");
        if (el && el.querySelector(`option[value="${cfg.account}"]`)) el.value = cfg.account;
      }
      if (cfg.viewType) {
        const el = document.getElementById("acctViewType");
        if (el) el.value = cfg.viewType;
      }
      if (cfg.year) {
        const el = document.getElementById("acctYear");
        if (el && el.querySelector(`option[value="${cfg.year}"]`)) el.value = cfg.year;
      }
      if (cfg.trendline !== undefined) {
        const el = document.getElementById("acctTrendline");
        if (el) el.checked = cfg.trendline;
      }
      if (cfg.dataLabels !== undefined) {
        const el = document.getElementById("acctDataLabels");
        if (el) el.checked = cfg.dataLabels;
      }
      if (cfg.excludeCurrent !== undefined) {
        const el = document.getElementById("acctExcludeCurrent");
        if (el) el.checked = cfg.excludeCurrent;
      }
      if (cfg.rangeStart) {
        const el = document.getElementById("acctRangeStart");
        if (el) {
          el.value = cfg.rangeStart;
          const label = document.getElementById("acctRangeStartLabel");
          if (label) label.textContent = cfg.rangeStart;
        }
      }
      if (cfg.rangeEnd) {
        const el = document.getElementById("acctRangeEnd");
        if (el) {
          el.value = cfg.rangeEnd;
          const label = document.getElementById("acctRangeEndLabel");
          if (label) label.textContent = cfg.rangeEnd;
        }
      }
      const view = cfg.viewType || "monthly";
      const yearWrap = document.getElementById("acctYearWrapper");
      const rangeWrap = document.getElementById("acctRangeWrapper");
      const compareLabel = document.getElementById("acctCompare")?.closest("label");
      if (view === "annual") {
        if (yearWrap) yearWrap.style.display = "none";
        if (rangeWrap) rangeWrap.classList.remove("hidden");
        if (compareLabel) compareLabel.style.display = "none";
      } else {
        if (yearWrap) yearWrap.style.display = "flex";
        if (rangeWrap) rangeWrap.classList.add("hidden");
        if (compareLabel) compareLabel.style.display = "";
      }
    },
    refresh() {
      if (acctDataCache && typeof updateAccountView === "function") updateAccountView(acctDataCache);
    }
  },
  
  incomeStatement: {
    collect() {
      return {
        viewMode: document.getElementById("isViewMode")?.value,
        periodType: document.getElementById("isPeriodType")?.value,
        periodSelect: document.getElementById("isPeriodSelect")?.value,
        compare: document.querySelector('input[name="isCompareRadio"]:checked')?.value,
        detailLevel: document.querySelector('input[name="isDetailLevel"]:checked')?.value,
        showThousands: document.getElementById("isShowThousands")?.checked,
        excludeCurrent: document.getElementById("isExcludeCurrent")?.checked,
        waterfallDataLabels: document.getElementById("isWaterfallDataLabels")?.checked,
        matrixMonths: document.getElementById("isMatrixMonths")?.value,
        matrixYearStart: document.getElementById("isMatrixYearStart")?.value,
        matrixYearEnd: document.getElementById("isMatrixYearEnd")?.value
      };
    },
    apply(cfg) {
      if (!cfg) return;
      if (cfg.viewMode) {
        const el = document.getElementById("isViewMode");
        if (el) el.value = cfg.viewMode;
      }
      if (cfg.periodType) {
        const el = document.getElementById("isPeriodType");
        if (el) el.value = cfg.periodType;
      }
      if (cfg.periodSelect) {
        const el = document.getElementById("isPeriodSelect");
        if (el && el.querySelector(`option[value="${cfg.periodSelect}"]`)) el.value = cfg.periodSelect;
      }
      if (cfg.compare) {
        const radio = document.querySelector(`input[name="isCompareRadio"][value="${cfg.compare}"]`);
        if (radio) radio.checked = true;
      }
      if (cfg.detailLevel) {
        const radio = document.querySelector(`input[name="isDetailLevel"][value="${cfg.detailLevel}"]`);
        if (radio) radio.checked = true;
      }
      if (cfg.showThousands !== undefined) {
        const el = document.getElementById("isShowThousands");
        if (el) el.checked = cfg.showThousands;
      }
      if (cfg.excludeCurrent !== undefined) {
        const el = document.getElementById("isExcludeCurrent");
        if (el) el.checked = cfg.excludeCurrent;
      }
      if (cfg.waterfallDataLabels !== undefined) {
        const el = document.getElementById("isWaterfallDataLabels");
        if (el) el.checked = cfg.waterfallDataLabels;
      }
      if (cfg.matrixMonths) {
        const el = document.getElementById("isMatrixMonths");
        if (el) el.value = cfg.matrixMonths;
      }
      if (cfg.matrixYearStart) {
        const el = document.getElementById("isMatrixYearStart");
        if (el) {
          el.value = cfg.matrixYearStart;
          const label = document.getElementById("isMatrixYearStartLabel");
          if (label) label.textContent = cfg.matrixYearStart;
        }
      }
      if (cfg.matrixYearEnd) {
        const el = document.getElementById("isMatrixYearEnd");
        if (el) {
          el.value = cfg.matrixYearEnd;
          const label = document.getElementById("isMatrixYearEndLabel");
          if (label) label.textContent = cfg.matrixYearEnd;
        }
      }
      if (typeof updateMatrixControlsVisibility === "function") updateMatrixControlsVisibility();
    },
    refresh() {
      if (typeof renderIncomeStatement === "function") renderIncomeStatement();
    }
  },
  
  balanceSheet: {
    collect() {
      return {
        viewMode: document.getElementById("bsViewMode")?.value,
        periodType: document.getElementById("bsPeriodType")?.value,
        periodSelect: document.getElementById("bsPeriodSelect")?.value,
        compare: document.querySelector('input[name="bsCompareRadio"]:checked')?.value,
        detailLevel: document.querySelector('input[name="bsDetailLevel"]:checked')?.value,
        showThousands: document.getElementById("bsShowThousands")?.checked,
        excludeCurrentMonth: document.getElementById("bsExcludeCurrentMonth")?.checked,
        matrixYear: document.getElementById("bsMatrixYear")?.value,
        matrixYearStart: document.getElementById("bsMatrixYearStart")?.value,
        matrixYearEnd: document.getElementById("bsMatrixYearEnd")?.value
      };
    },
    apply(cfg) {
      if (!cfg) return;
      if (cfg.viewMode) {
        const el = document.getElementById("bsViewMode");
        if (el) el.value = cfg.viewMode;
      }
      if (cfg.periodType) {
        const el = document.getElementById("bsPeriodType");
        if (el) el.value = cfg.periodType;
      }
      if (cfg.periodSelect) {
        const el = document.getElementById("bsPeriodSelect");
        if (el && el.querySelector(`option[value="${cfg.periodSelect}"]`)) el.value = cfg.periodSelect;
      }
      if (cfg.compare) {
        const radio = document.querySelector(`input[name="bsCompareRadio"][value="${cfg.compare}"]`);
        if (radio) radio.checked = true;
      }
      if (cfg.detailLevel) {
        const radio = document.querySelector(`input[name="bsDetailLevel"][value="${cfg.detailLevel}"]`);
        if (radio) radio.checked = true;
      }
      if (cfg.showThousands !== undefined) {
        const el = document.getElementById("bsShowThousands");
        if (el) el.checked = cfg.showThousands;
      }
      if (cfg.excludeCurrentMonth !== undefined) {
        const el = document.getElementById("bsExcludeCurrentMonth");
        if (el) el.checked = cfg.excludeCurrentMonth;
      }
      if (cfg.matrixYear) {
        const el = document.getElementById("bsMatrixYear");
        if (el && el.querySelector(`option[value="${cfg.matrixYear}"]`)) el.value = cfg.matrixYear;
      }
      if (cfg.matrixYearStart) {
        const el = document.getElementById("bsMatrixYearStart");
        if (el) {
          el.value = cfg.matrixYearStart;
          const label = document.getElementById("bsMatrixYearStartLabel");
          if (label) label.textContent = cfg.matrixYearStart;
        }
      }
      if (cfg.matrixYearEnd) {
        const el = document.getElementById("bsMatrixYearEnd");
        if (el) {
          el.value = cfg.matrixYearEnd;
          const label = document.getElementById("bsMatrixYearEndLabel");
          if (label) label.textContent = cfg.matrixYearEnd;
        }
      }
      if (typeof updateBSControlVisibility === "function") updateBSControlVisibility();
    },
    refresh() {
      if (typeof renderBalanceSheet === "function") renderBalanceSheet();
    }
  },
  
  cashFlows: {
    collect() {
      return {
        viewMode: document.getElementById("cfViewMode")?.value,
        periodType: document.getElementById("cfPeriodType")?.value,
        periodSelect: document.getElementById("cfPeriodSelect")?.value,
        compare: document.querySelector('input[name="cfCompareRadio"]:checked')?.value,
        detailLevel: document.querySelector('input[name="cfDetailLevel"]:checked')?.value,
        showThousands: document.getElementById("cfShowThousands")?.checked,
        showSubtotal: document.getElementById("cfShowSubtotal")?.checked,
        excludeCurrent: document.getElementById("cfExcludeCurrent")?.checked,
        matrixYearStart: document.getElementById("cfMatrixYearStart")?.value,
        matrixYearEnd: document.getElementById("cfMatrixYearEnd")?.value
      };
    },
    apply(cfg) {
      if (!cfg) return;
      if (cfg.viewMode) {
        const el = document.getElementById("cfViewMode");
        if (el) el.value = cfg.viewMode;
      }
      if (cfg.periodType) {
        const el = document.getElementById("cfPeriodType");
        if (el) el.value = cfg.periodType;
      }
      if (cfg.periodSelect) {
        const el = document.getElementById("cfPeriodSelect");
        if (el && el.querySelector(`option[value="${cfg.periodSelect}"]`)) el.value = cfg.periodSelect;
      }
      if (cfg.compare) {
        const radio = document.querySelector(`input[name="cfCompareRadio"][value="${cfg.compare}"]`);
        if (radio) radio.checked = true;
      }
      if (cfg.detailLevel) {
        // Migrate old "medium" or "account" values to "detailed"
        let detailValue = cfg.detailLevel;
        if (detailValue === "medium" || detailValue === "account") {
          detailValue = "detailed";
        }
        const radio = document.querySelector(`input[name="cfDetailLevel"][value="${detailValue}"]`);
        if (radio) radio.checked = true;
      }
      if (cfg.showThousands !== undefined) {
        const el = document.getElementById("cfShowThousands");
        if (el) el.checked = cfg.showThousands;
      }
      if (cfg.showSubtotal !== undefined) {
        const el = document.getElementById("cfShowSubtotal");
        if (el) el.checked = cfg.showSubtotal;
      }
      if (cfg.excludeCurrent !== undefined) {
        const el = document.getElementById("cfExcludeCurrent");
        if (el) el.checked = cfg.excludeCurrent;
      }
      if (cfg.matrixYearStart) {
        const el = document.getElementById("cfMatrixYearStart");
        if (el) {
          el.value = cfg.matrixYearStart;
          const label = document.getElementById("cfMatrixYearStartLabel");
          if (label) label.textContent = cfg.matrixYearStart;
        }
      }
      if (cfg.matrixYearEnd) {
        const el = document.getElementById("cfMatrixYearEnd");
        if (el) {
          el.value = cfg.matrixYearEnd;
          const label = document.getElementById("cfMatrixYearEndLabel");
          if (label) label.textContent = cfg.matrixYearEnd;
        }
      }
      if (typeof updateCFMatrixControlsVisibility === "function") updateCFMatrixControlsVisibility();
    },
    refresh() {
      if (typeof renderCashFlowStatement === "function") renderCashFlowStatement();
    }
  }
};

/* ------------------------------------------------------------
   SAVED VIEWS - UI Helper Functions
------------------------------------------------------------ */
function populateSavedViewsDropdown(page, selectId) {
  const select = document.getElementById(selectId);
  if (!select) return;
  
  const pageData = SavedViewManager.getPageViews(page);
  const views = pageData.views || {};
  const selectedId = pageData.selectedId;
  
  select.innerHTML = '<option value="">-- Current Settings --</option>';
  
  Object.keys(views).forEach(id => {
    const view = views[id];
    const option = document.createElement("option");
    option.value = id;
    option.textContent = view.name;
    select.appendChild(option);
  });
  
  // Always start at "Current Settings" on page load
  select.value = "";
  
  updateDeleteButtonState(page);
}

function updateDeleteButtonState(page) {
  const mapping = {
    overview: "overviewDeleteViewBtn",
    revenue: "revDeleteViewBtn",
    accounts: "acctDeleteViewBtn",
    incomeStatement: "isDeleteViewBtn",
    balanceSheet: "bsDeleteViewBtn",
    cashFlows: "cfDeleteViewBtn"
  };
  const selectMapping = {
    overview: "overviewSavedViews",
    revenue: "revSavedViews",
    cashFlows: "cfSavedViews",
    accounts: "acctSavedViews",
    incomeStatement: "isSavedViews",
    balanceSheet: "bsSavedViews"
  };
  
  const deleteBtn = document.getElementById(mapping[page]);
  const select = document.getElementById(selectMapping[page]);
  
  if (deleteBtn && select) {
    deleteBtn.disabled = !select.value;
  }
}

function setupSavedViewsHandlers(page, selectId, saveBtnId, deleteBtnId) {
  const select = document.getElementById(selectId);
  const saveBtn = document.getElementById(saveBtnId);
  const deleteBtn = document.getElementById(deleteBtnId);
  
  if (!select || !saveBtn || !deleteBtn) return;
  
  select.onchange = () => {
    const viewId = select.value;
    SavedViewManager.selectView(page, viewId || null);
    
    if (viewId) {
      const view = SavedViewManager.getSelectedView(page);
      if (view && view.config && PageViewConfigs[page]) {
        PageViewConfigs[page].apply(view.config);
        PageViewConfigs[page].refresh();
      }
    }
    updateDeleteButtonState(page);
  };
  
  saveBtn.onclick = () => {
    const name = prompt("Enter a name for this view:");
    if (!name || !name.trim()) return;
    
    const config = PageViewConfigs[page]?.collect();
    if (config) {
      const id = SavedViewManager.saveView(page, name.trim(), config);
      populateSavedViewsDropdown(page, selectId);
      select.value = id;
      updateDeleteButtonState(page);
    }
  };
  
  deleteBtn.onclick = () => {
    const viewId = select.value;
    if (!viewId) return;
    
    const view = SavedViewManager.getPageViews(page).views[viewId];
    if (!view) return;
    
    if (confirm(`Delete view "${view.name}"?`)) {
      SavedViewManager.deleteView(page, viewId);
      populateSavedViewsDropdown(page, selectId);
      updateDeleteButtonState(page);
    }
  };
  
  updateDeleteButtonState(page);
}

function initAllSavedViewsHandlers() {
  setupSavedViewsHandlers("overview", "overviewSavedViews", "overviewSaveViewBtn", "overviewDeleteViewBtn");
  setupSavedViewsHandlers("revenue", "revSavedViews", "revSaveViewBtn", "revDeleteViewBtn");
  setupSavedViewsHandlers("accounts", "acctSavedViews", "acctSaveViewBtn", "acctDeleteViewBtn");
  setupSavedViewsHandlers("incomeStatement", "isSavedViews", "isSaveViewBtn", "isDeleteViewBtn");
  setupSavedViewsHandlers("balanceSheet", "bsSavedViews", "bsSaveViewBtn", "bsDeleteViewBtn");
  setupSavedViewsHandlers("cashFlows", "cfSavedViews", "cfSaveViewBtn", "cfDeleteViewBtn");
  
  populateSavedViewsDropdown("overview", "overviewSavedViews");
  populateSavedViewsDropdown("revenue", "revSavedViews");
  populateSavedViewsDropdown("accounts", "acctSavedViews");
  populateSavedViewsDropdown("incomeStatement", "isSavedViews");
  populateSavedViewsDropdown("balanceSheet", "bsSavedViews");
  populateSavedViewsDropdown("cashFlows", "cfSavedViews");
}

let isLoadingPreferences = false;

function loadUserPreferences() {
  const user = getCurrentUser();
  if (!user) return;
  
  isLoadingPreferences = true;
  
  try {
    const prefs = getUserPreferences();
    
    if (prefs.overviewMetrics) {
      Object.keys(metricTileMapping).forEach(metric => {
        const checkbox = document.querySelector(`[data-metric="${metric}"]`);
        if (checkbox) {
          checkbox.checked = prefs.overviewMetrics[metric] !== false;
        }
      });
    }
    
    const viewEl = document.getElementById("overviewViewType");
    
    if (viewEl) viewEl.value = "quarterly";
    syncTimePeriodButtons("quarterly");
    
    if (prefs.overviewConfig) {
      const cfg = prefs.overviewConfig;
      
      if (cfg.viewType && viewEl) {
        viewEl.value = cfg.viewType;
        syncTimePeriodButtons(cfg.viewType);
      }
      if (cfg.year) {
        const yearEl = document.getElementById("overviewYear");
        if (yearEl) yearEl.value = cfg.year;
      }
      if (typeof cfg.compare === "boolean") {
        const compareEl = document.getElementById("overviewCompare");
        if (compareEl) compareEl.checked = cfg.compare;
      }
      if (typeof cfg.trendline === "boolean") {
        const trendEl = document.getElementById("overviewTrend");
        if (trendEl) trendEl.checked = cfg.trendline;
      }
      if (typeof cfg.dataLabels === "boolean") {
        const dataLabelsEl = document.getElementById("overviewDataLabels");
        if (dataLabelsEl) dataLabelsEl.checked = cfg.dataLabels;
      }
      const excludeEl = document.getElementById("overviewExclude");
      if (excludeEl) excludeEl.checked = cfg.excludeCurrent !== false;
    } else {
      const excludeEl = document.getElementById("overviewExclude");
      if (excludeEl) excludeEl.checked = true;
    }
    
    applyMetricVisibility();
  } finally {
    isLoadingPreferences = false;
  }
}

function syncTimePeriodButtons(viewType) {
  document.querySelectorAll('.time-period-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.view === viewType);
  });
  
  // Update year controls visibility
  const yearSelectWrapper = document.getElementById("overviewYearSelectWrapper");
  const yearSliderSection = document.getElementById("overviewYearSliderSection");
  const compareLabel = document.getElementById("overviewCompareLabel");
  const compareCheck = document.getElementById("overviewCompare");
  
  if (yearSelectWrapper && yearSliderSection) {
    if (viewType === "annual") {
      yearSelectWrapper.style.display = "none";
      yearSliderSection.style.display = "flex";
      // Hide and deselect Compare to Prior Year for annual view
      if (compareLabel) compareLabel.style.display = "none";
      if (compareCheck) compareCheck.checked = false;
    } else {
      yearSelectWrapper.style.display = "flex";
      yearSliderSection.style.display = "none";
      // Show Compare to Prior Year for monthly/quarterly views
      if (compareLabel) compareLabel.style.display = "";
    }
  }
}

function applyMetricVisibility() {
  const metricCheckboxes = document.querySelectorAll("[data-metric]");
  metricCheckboxes.forEach(cb => {
    const metric = cb.dataset.metric;
    const chartId = metricTileMapping[metric];
    const canvas = document.getElementById(chartId);
    if (canvas) {
      const tile = canvas.closest(".overview-metric-tile");
      if (tile) {
        tile.style.display = cb.checked ? "" : "none";
      }
    }
  });
}

function updateMetricVisibility() {
  applyMetricVisibility();
  
  if (!isLoadingPreferences) {
    const metricCheckboxes = document.querySelectorAll("[data-metric]");
    const visiblePrefs = {};
    metricCheckboxes.forEach(cb => {
      visiblePrefs[cb.dataset.metric] = cb.checked;
    });
    saveUserPreferences({ overviewMetrics: visiblePrefs });
  }
}

function saveOverviewConfig() {
  const cfg = {
    viewType: document.getElementById("overviewViewType")?.value,
    year: document.getElementById("overviewYear")?.value,
    compare: document.getElementById("overviewCompare")?.checked,
    trendline: document.getElementById("overviewTrend")?.checked,
    dataLabels: document.getElementById("overviewDataLabels")?.checked,
    excludeCurrent: document.getElementById("overviewExclude")?.checked
  };
  saveUserPreferences({ overviewConfig: cfg });
}

function saveRevenueConfig() {
  const cfg = {
    viewType: document.getElementById("revViewType")?.value,
    year: document.getElementById("revYear")?.value,
    compare: document.getElementById("revCompare")?.checked,
    trendline: document.getElementById("revTrendline")?.checked,
    dataLabels: document.getElementById("revDataLabels")?.checked,
    excludeCurrent: document.getElementById("revExcludeCurrent")?.checked,
    rangeStart: document.getElementById("revRangeStart")?.value,
    rangeEnd: document.getElementById("revRangeEnd")?.value
  };
  saveUserPreferences({ revenueConfig: cfg });
}

function saveAccountConfig() {
  const cfg = {
    account: document.getElementById("acctSelect")?.value,
    viewType: document.getElementById("acctViewType")?.value,
    year: document.getElementById("acctYear")?.value,
    trendline: document.getElementById("acctTrendline")?.checked,
    dataLabels: document.getElementById("acctDataLabels")?.checked,
    excludeCurrent: document.getElementById("acctExcludeCurrent")?.checked,
    rangeStart: document.getElementById("acctRangeStart")?.value,
    rangeEnd: document.getElementById("acctRangeEnd")?.value
  };
  saveUserPreferences({ accountConfig: cfg });
}

function saveIncomeStatementConfig() {
  const cfg = {
    viewMode: document.getElementById("isViewMode")?.value,
    periodType: document.getElementById("isPeriodType")?.value,
    periodSelect: document.getElementById("isPeriodSelect")?.value,
    compare: document.querySelector('input[name="isCompareRadio"]:checked')?.value,
    detailLevel: document.querySelector('input[name="isDetailLevel"]:checked')?.value,
    showThousands: document.getElementById("isShowThousands")?.checked,
    excludeCurrent: document.getElementById("isExcludeCurrent")?.checked,
    waterfallDataLabels: document.getElementById("isWaterfallDataLabels")?.checked,
    matrixMonths: document.getElementById("isMatrixMonths")?.value,
    matrixYearStart: document.getElementById("isMatrixYearStart")?.value,
    matrixYearEnd: document.getElementById("isMatrixYearEnd")?.value
  };
  saveUserPreferences({ incomeStatementConfig: cfg });
}

function saveBalanceSheetConfig() {
  const cfg = {
    viewMode: document.getElementById("bsViewMode")?.value,
    periodType: document.getElementById("bsPeriodType")?.value,
    periodSelect: document.getElementById("bsPeriodSelect")?.value,
    compare: document.querySelector('input[name="bsCompareRadio"]:checked')?.value,
    detailLevel: document.querySelector('input[name="bsDetailLevel"]:checked')?.value,
    showThousands: document.getElementById("bsShowThousands")?.checked,
    excludeCurrentMonth: document.getElementById("bsExcludeCurrentMonth")?.checked,
    matrixYear: document.getElementById("bsMatrixYear")?.value,
    matrixYearStart: document.getElementById("bsMatrixYearStart")?.value,
    matrixYearEnd: document.getElementById("bsMatrixYearEnd")?.value
  };
  saveUserPreferences({ balanceSheetConfig: cfg });
}

function loadRevenueConfig() {
  const prefs = getUserPreferences();
  const cfg = prefs.revenueConfig || {};
  
  if (cfg.viewType) {
    const el = document.getElementById("revViewType");
    if (el) el.value = cfg.viewType;
  }
  if (cfg.year) {
    const el = document.getElementById("revYear");
    if (el && el.querySelector(`option[value="${cfg.year}"]`)) el.value = cfg.year;
  }
  if (cfg.compare !== undefined) {
    const el = document.getElementById("revCompare");
    if (el) el.checked = cfg.compare;
  }
  if (cfg.trendline !== undefined) {
    const el = document.getElementById("revTrendline");
    if (el) el.checked = cfg.trendline;
  }
  if (cfg.dataLabels !== undefined) {
    const el = document.getElementById("revDataLabels");
    if (el) el.checked = cfg.dataLabels;
  }
  const excludeEl = document.getElementById("revExcludeCurrent");
  if (excludeEl) excludeEl.checked = cfg.excludeCurrent !== false;
  if (cfg.rangeStart) {
    const el = document.getElementById("revRangeStart");
    if (el) {
      el.value = cfg.rangeStart;
      document.getElementById("revRangeStartLabel").textContent = cfg.rangeStart;
    }
  }
  if (cfg.rangeEnd) {
    const el = document.getElementById("revRangeEnd");
    if (el) {
      el.value = cfg.rangeEnd;
      document.getElementById("revRangeEndLabel").textContent = cfg.rangeEnd;
    }
  }
  
  // Update UI visibility based on view type
  const viewType = document.getElementById("revViewType")?.value;
  const yearWrapper = document.getElementById("revYearWrapper");
  const rangeWrapper = document.getElementById("revRangeWrapper");
  const compareCheck = document.getElementById("revCompare");
  const compareLabel = compareCheck?.closest("label");
  const excludeLabel = document.getElementById("revExcludeLabel");
  
  if (viewType === "annual") {
    if (yearWrapper) yearWrapper.style.display = "none";
    if (rangeWrapper) rangeWrapper.classList.remove("hidden");
    if (compareLabel) compareLabel.style.display = "none";
    if (excludeLabel) excludeLabel.textContent = "Exclude Current Year";
  } else if (viewType === "quarterly") {
    if (yearWrapper) yearWrapper.style.display = "flex";
    if (rangeWrapper) rangeWrapper.classList.add("hidden");
    if (compareLabel) compareLabel.style.display = "";
    if (excludeLabel) excludeLabel.textContent = "Exclude Current Quarter";
  } else {
    if (yearWrapper) yearWrapper.style.display = "flex";
    if (rangeWrapper) rangeWrapper.classList.add("hidden");
    if (compareLabel) compareLabel.style.display = "";
    if (excludeLabel) excludeLabel.textContent = "Exclude Current Month";
  }
}

function loadAccountConfig() {
  const prefs = getUserPreferences();
  const cfg = prefs.accountConfig || {};
  
  if (cfg.account) {
    const el = document.getElementById("acctSelect");
    if (el && el.querySelector(`option[value="${cfg.account}"]`)) el.value = cfg.account;
  }
  if (cfg.viewType) {
    const el = document.getElementById("acctViewType");
    if (el) el.value = cfg.viewType;
  }
  if (cfg.year) {
    const el = document.getElementById("acctYear");
    if (el && el.querySelector(`option[value="${cfg.year}"]`)) el.value = cfg.year;
  }
  if (cfg.trendline !== undefined) {
    const el = document.getElementById("acctTrendline");
    if (el) el.checked = cfg.trendline;
  }
  if (cfg.dataLabels !== undefined) {
    const el = document.getElementById("acctDataLabels");
    if (el) el.checked = cfg.dataLabels;
  }
  const excludeEl = document.getElementById("acctExcludeCurrent");
  if (excludeEl) excludeEl.checked = cfg.excludeCurrent !== false;
  if (cfg.rangeStart) {
    const el = document.getElementById("acctRangeStart");
    if (el) {
      el.value = cfg.rangeStart;
      document.getElementById("acctRangeStartLabel").textContent = cfg.rangeStart;
    }
  }
  if (cfg.rangeEnd) {
    const el = document.getElementById("acctRangeEnd");
    if (el) {
      el.value = cfg.rangeEnd;
      document.getElementById("acctRangeEndLabel").textContent = cfg.rangeEnd;
    }
  }
  
  // Update UI visibility based on view type
  const viewType = document.getElementById("acctViewType")?.value;
  const yearWrap = document.getElementById("acctYearWrapper");
  const compareCheckbox = document.getElementById("acctCompare");
  const compareLabel = compareCheckbox?.closest("label");
  const rangeWrap = document.getElementById("acctRangeWrapper");
  const excludeLabel = document.getElementById("acctExcludeLabel");
  
  if (viewType === "annual") {
    if (yearWrap) yearWrap.style.display = "none";
    if (compareLabel) compareLabel.style.display = "none";
    if (rangeWrap) rangeWrap.classList.remove("hidden");
    if (excludeLabel) excludeLabel.textContent = "Exclude Current Year";
  } else if (viewType === "quarterly") {
    if (yearWrap) yearWrap.style.display = "flex";
    if (compareLabel) compareLabel.style.display = "";
    if (rangeWrap) rangeWrap.classList.add("hidden");
    if (excludeLabel) excludeLabel.textContent = "Exclude Current Quarter";
  } else {
    if (yearWrap) yearWrap.style.display = "flex";
    if (compareLabel) compareLabel.style.display = "";
    if (rangeWrap) rangeWrap.classList.add("hidden");
    if (excludeLabel) excludeLabel.textContent = "Exclude Current Month";
  }
}

function loadIncomeStatementConfig() {
  const prefs = getUserPreferences();
  const cfg = prefs.incomeStatementConfig || {};
  
  if (cfg.viewMode) {
    const el = document.getElementById("isViewMode");
    if (el) el.value = cfg.viewMode;
  }
  if (cfg.periodType) {
    const el = document.getElementById("isPeriodType");
    if (el) el.value = cfg.periodType;
  }
  if (cfg.periodSelect) {
    const el = document.getElementById("isPeriodSelect");
    if (el && el.querySelector(`option[value="${cfg.periodSelect}"]`)) el.value = cfg.periodSelect;
  }
  if (cfg.compare) {
    const radio = document.querySelector(`input[name="isCompareRadio"][value="${cfg.compare}"]`);
    if (radio) radio.checked = true;
  }
  if (cfg.detailLevel) {
    const radio = document.querySelector(`input[name="isDetailLevel"][value="${cfg.detailLevel}"]`);
    if (radio) radio.checked = true;
  }
  if (cfg.showThousands !== undefined) {
    const el = document.getElementById("isShowThousands");
    if (el) el.checked = cfg.showThousands;
  }
  const excludeEl = document.getElementById("isExcludeCurrent");
  if (excludeEl) excludeEl.checked = cfg.excludeCurrent !== false;
  if (cfg.matrixMonths) {
    const el = document.getElementById("isMatrixMonths");
    if (el) el.value = cfg.matrixMonths;
  }
  if (cfg.matrixYearStart) {
    const el = document.getElementById("isMatrixYearStart");
    if (el) {
      el.value = cfg.matrixYearStart;
      const label = document.getElementById("isMatrixYearStartLabel");
      if (label) label.textContent = cfg.matrixYearStart;
    }
  }
  if (cfg.matrixYearEnd) {
    const el = document.getElementById("isMatrixYearEnd");
    if (el) {
      el.value = cfg.matrixYearEnd;
      const label = document.getElementById("isMatrixYearEndLabel");
      if (label) label.textContent = cfg.matrixYearEnd;
    }
  }
  
  // Update control visibility based on loaded config
  if (typeof updateMatrixControlsVisibility === 'function') {
    updateMatrixControlsVisibility();
  }
}

function loadBalanceSheetConfig() {
  const prefs = getUserPreferences();
  const cfg = prefs.balanceSheetConfig || {};
  
  if (cfg.viewMode) {
    const el = document.getElementById("bsViewMode");
    if (el) el.value = cfg.viewMode;
  }
  if (cfg.periodType) {
    const el = document.getElementById("bsPeriodType");
    if (el) el.value = cfg.periodType;
  }
  if (cfg.periodSelect) {
    const el = document.getElementById("bsPeriodSelect");
    if (el && el.querySelector(`option[value="${cfg.periodSelect}"]`)) el.value = cfg.periodSelect;
  }
  if (cfg.compare) {
    const radio = document.querySelector(`input[name="bsCompareRadio"][value="${cfg.compare}"]`);
    if (radio) radio.checked = true;
  }
  if (cfg.detailLevel) {
    const radio = document.querySelector(`input[name="bsDetailLevel"][value="${cfg.detailLevel}"]`);
    if (radio) radio.checked = true;
  }
  if (cfg.showThousands !== undefined) {
    const el = document.getElementById("bsShowThousands");
    if (el) el.checked = cfg.showThousands;
  }
  const excludeEl = document.getElementById("bsExcludeCurrentMonth");
  if (excludeEl) excludeEl.checked = cfg.excludeCurrentMonth !== false;
  if (cfg.matrixYear) {
    const el = document.getElementById("bsMatrixYear");
    if (el && el.querySelector(`option[value="${cfg.matrixYear}"]`)) el.value = cfg.matrixYear;
  }
  if (cfg.matrixYearStart) {
    const el = document.getElementById("bsMatrixYearStart");
    if (el) {
      el.value = cfg.matrixYearStart;
      const label = document.getElementById("bsMatrixYearStartLabel");
      if (label) label.textContent = cfg.matrixYearStart;
    }
  }
  if (cfg.matrixYearEnd) {
    const el = document.getElementById("bsMatrixYearEnd");
    if (el) {
      el.value = cfg.matrixYearEnd;
      const label = document.getElementById("bsMatrixYearEndLabel");
      if (label) label.textContent = cfg.matrixYearEnd;
    }
  }
  
  // Update control visibility based on loaded config
  if (typeof updateBSControlVisibility === 'function') {
    updateBSControlVisibility();
  }
}

window.loadUserPreferences = loadUserPreferences;
let isData = null;
let isAccountGroups = null;
let isGLLookup = {};
let isRowStates = {};

// ===========================================
// CUSTOM GREETING
// ===========================================
function updateGreeting() {
  const greetingText = document.getElementById('greetingText');
  const greetingDate = document.getElementById('greetingDate');
  
  if (!greetingText) return;
  
  const now = new Date();
  const hour = now.getHours();
  // Prefer display name from database, fall back to email with capitalization
  let displayName = localStorage.getItem('ftg_display_name') || '';
  if (!displayName) {
    const currentUser = localStorage.getItem('ftg_current_user') || '';
    displayName = currentUser ? currentUser.split('@')[0].charAt(0).toUpperCase() + currentUser.split('@')[0].slice(1) : '';
  }
  
  let greeting;
  
  if (hour < 12) {
    greeting = displayName ? `Good morning, ${displayName}` : 'Good morning';
  } else if (hour < 17) {
    greeting = displayName ? `Good afternoon, ${displayName}` : 'Good afternoon';
  } else {
    greeting = displayName ? `Good evening, ${displayName}` : 'Good evening';
  }
  
  greetingText.textContent = greeting;
  
  if (greetingDate) {
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    greetingDate.textContent = now.toLocaleDateString('en-US', options);
  }
}

// ===========================================
// DRAG AND DROP TILES
// ===========================================
let draggedTile = null;

function initDragAndDropTiles() {
  const grid = document.querySelector('.overview-tiles-grid');
  if (!grid) return;
  
  // Skip if already initialized
  if (grid.dataset.dragInitialized) return;
  grid.dataset.dragInitialized = 'true';
  
  // Enable drag mode
  grid.classList.add('drag-enabled');
  
  // Add reset button
  let resetBtn = grid.querySelector('.reset-tile-order-btn');
  if (!resetBtn) {
    resetBtn = document.createElement('button');
    resetBtn.className = 'reset-tile-order-btn';
    resetBtn.textContent = 'Reset Order';
    resetBtn.onclick = resetTileOrder;
    grid.appendChild(resetBtn);
  }
  
  // Add saved indicator
  let savedIndicator = document.getElementById('tileOrderSaved');
  if (!savedIndicator) {
    savedIndicator = document.createElement('div');
    savedIndicator.id = 'tileOrderSaved';
    savedIndicator.className = 'tile-order-saved';
    savedIndicator.textContent = 'Tile order saved';
    document.body.appendChild(savedIndicator);
  }
  
  // Restore saved order first
  restoreTileOrder();
  
  // Use event delegation on the grid for robust handling
  grid.addEventListener('dragstart', (e) => {
    const tile = e.target.closest('.overview-metric-tile');
    if (!tile) return;
    
    draggedTile = tile;
    tile.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', 'tile');
    
    setTimeout(() => tile.classList.add('drag-ghost'), 0);
  });
  
  grid.addEventListener('dragend', (e) => {
    const tile = e.target.closest('.overview-metric-tile');
    if (!tile) return;
    
    tile.classList.remove('dragging', 'drag-ghost');
    grid.querySelectorAll('.overview-metric-tile').forEach(t => t.classList.remove('drag-over'));
    draggedTile = null;
  });
  
  grid.addEventListener('dragover', (e) => {
    e.preventDefault();
    const tile = e.target.closest('.overview-metric-tile');
    if (!tile || tile === draggedTile) return;
    
    e.dataTransfer.dropEffect = 'move';
    tile.classList.add('drag-over');
  });
  
  grid.addEventListener('dragleave', (e) => {
    const tile = e.target.closest('.overview-metric-tile');
    if (!tile) return;
    tile.classList.remove('drag-over');
  });
  
  grid.addEventListener('drop', (e) => {
    e.preventDefault();
    const tile = e.target.closest('.overview-metric-tile');
    if (!tile) return;
    
    tile.classList.remove('drag-over');
    
    if (draggedTile && tile !== draggedTile) {
      // Get fresh indices from current DOM state
      const allTiles = Array.from(grid.querySelectorAll('.overview-metric-tile'));
      const draggedIdx = allTiles.indexOf(draggedTile);
      const targetIdx = allTiles.indexOf(tile);
      
      if (draggedIdx < targetIdx) {
        tile.parentNode.insertBefore(draggedTile, tile.nextSibling);
      } else {
        tile.parentNode.insertBefore(draggedTile, tile);
      }
      
      saveTileOrder();
      showTileOrderSaved();
    }
  });
  
  // Make all tiles draggable and add handles
  setupTileDragHandles();
}

function setupTileDragHandles() {
  const grid = document.querySelector('.overview-tiles-grid');
  if (!grid) return;
  
  const tiles = grid.querySelectorAll('.overview-metric-tile');
  
  tiles.forEach(tile => {
    // Add drag handle if not present
    let dragHandle = tile.querySelector('.drag-handle');
    if (!dragHandle) {
      dragHandle = document.createElement('div');
      dragHandle.className = 'drag-handle';
      dragHandle.innerHTML = '<span></span>';
      tile.style.position = 'relative';
      tile.insertBefore(dragHandle, tile.firstChild);
    }
    
    // Make tile draggable
    tile.setAttribute('draggable', 'true');
  });
}

function saveTileOrder() {
  const grid = document.querySelector('.overview-tiles-grid');
  if (!grid) return;
  
  const tiles = grid.querySelectorAll('.overview-metric-tile');
  const order = [];
  
  tiles.forEach(tile => {
    const title = tile.querySelector('.metric-tile-title');
    if (title) {
      order.push(title.textContent.trim());
    }
  });
  
  localStorage.setItem('ftg_tile_order', JSON.stringify(order));
}

function restoreTileOrder() {
  const savedOrder = localStorage.getItem('ftg_tile_order');
  if (!savedOrder) return;
  
  try {
    const order = JSON.parse(savedOrder);
    const grid = document.querySelector('.overview-tiles-grid');
    if (!grid) return;
    
    const tiles = Array.from(grid.querySelectorAll('.overview-metric-tile'));
    const tileMap = {};
    
    tiles.forEach(tile => {
      const title = tile.querySelector('.metric-tile-title');
      if (title) {
        tileMap[title.textContent.trim()] = tile;
      }
    });
    
    // Reorder tiles based on saved order
    order.forEach(titleText => {
      const tile = tileMap[titleText];
      if (tile) {
        grid.appendChild(tile);
      }
    });
    
    // Append any tiles not in saved order (new tiles)
    tiles.forEach(tile => {
      const title = tile.querySelector('.metric-tile-title');
      if (title && !order.includes(title.textContent.trim())) {
        grid.appendChild(tile);
      }
    });
  } catch (e) {
    console.warn('Could not restore tile order:', e);
  }
}

function resetTileOrder() {
  localStorage.removeItem('ftg_tile_order');
  location.reload();
}

function showTileOrderSaved() {
  const indicator = document.getElementById('tileOrderSaved');
  if (!indicator) return;
  
  indicator.classList.add('show');
  setTimeout(() => {
    indicator.classList.remove('show');
  }, 2000);
}

async function initOverviewModule() {
  try {
    // Update greeting first (instant, no data needed)
    updateGreeting();
    
    const fetchPromises = [];
    
    if (!overviewDataCache) {
      fetchPromises.push(
        fetch("/data/financials_gl.json").then(r => r.json()).then(data => { overviewDataCache = data; })
      );
    }
    
    if (!isAccountGroups) {
      fetchPromises.push(
        fetch("/data/account_groups.json").then(r => r.json()).then(data => { isAccountGroups = data; })
      );
    }
    
    if (!isData) {
      fetchPromises.push(
        fetch("/data/financials_gl.json").then(r => r.json()).then(data => { 
          isData = data;
          buildGLLookup();
        })
      );
    }
    
    if (fetchPromises.length > 0) {
      await Promise.all(fetchPromises);
    }
    
    setupOverviewUI();
    updateOverviewCharts();
    
    // Initialize drag-and-drop for tiles (after charts are rendered)
    setTimeout(() => initDragAndDropTiles(), 100);
  } catch (err) {
    console.error("Overview data load error:", err);
  }
}

function setupOverviewUI() {
  try {
    const viewTypeInput = document.getElementById("overviewViewType");
    const yearSelect = document.getElementById("overviewYear");
    const compareCheck = document.getElementById("overviewCompare");
    const rangeStart = document.getElementById("overviewRangeStart");
    const rangeEnd = document.getElementById("overviewRangeEnd");
    
    if (!viewTypeInput || !rangeStart || !rangeEnd) {
      console.error("Overview UI elements not found");
      return;
    }
    
    if (!overviewDataCache || !overviewDataCache.gl_history_all) {
      console.error("Overview data not loaded");
      return;
    }
    
    // Extract years from GL data date keys (format: YYYY-MM)
    const yearSet = new Set();
    overviewDataCache.gl_history_all.forEach(row => {
      Object.keys(row).forEach(key => {
        if (/^\d{4}-\d{2}$/.test(key)) {
          yearSet.add(parseInt(key.substring(0, 4)));
        }
      });
    });
    const years = Array.from(yearSet).sort((a, b) => a - b);
    if (years.length === 0) {
      console.error("No years found in GL data");
      return;
    }
    
    // Populate year select (descending order - most recent first)
    if (yearSelect) {
      const yearsDesc = [...years].sort((a, b) => b - a);
      yearSelect.innerHTML = yearsDesc.map(y => `<option value="${y}">${y}</option>`).join("");
      yearSelect.value = Math.max(...years);
    }
  
    // Initialize year range slider
    rangeStart.min = rangeEnd.min = years[0];
    rangeStart.max = rangeEnd.max = years[years.length - 1];
    rangeStart.value = years[0];
    rangeEnd.value = years[years.length - 1];
    document.getElementById("overviewRangeStartLabel").textContent = rangeStart.value;
    document.getElementById("overviewRangeEndLabel").textContent = rangeEnd.value;
  
    const trendCheck = document.getElementById("overviewTrend");
    
    // Initialize visibility based on current view type
    syncTimePeriodButtons(viewTypeInput.value);
  
    // Time period button click handlers
    document.querySelectorAll('.time-period-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.time-period-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        viewTypeInput.value = btn.dataset.view;
        syncTimePeriodButtons(btn.dataset.view);
        updateOverviewCharts();
        saveOverviewConfig();
      });
    });
  
  const excludeCheck = document.getElementById("overviewExclude");
  const dataLabelsCheck = document.getElementById("overviewDataLabels");
  
  yearSelect.onchange = () => { updateOverviewCharts(); saveOverviewConfig(); };
  compareCheck.onchange = () => { updateOverviewCharts(); saveOverviewConfig(); };
  trendCheck.onchange = () => { updateOverviewCharts(); saveOverviewConfig(); };
  excludeCheck.onchange = () => { updateOverviewCharts(); saveOverviewConfig(); };
  dataLabelsCheck.onchange = () => { updateOverviewCharts(); saveOverviewConfig(); };
  
  rangeStart.oninput = () => {
    if (+rangeStart.value > +rangeEnd.value) rangeStart.value = rangeEnd.value;
    document.getElementById("overviewRangeStartLabel").textContent = rangeStart.value;
    debouncedUpdateOverviewCharts();
    saveOverviewConfig();
  };
  
  rangeEnd.oninput = () => {
    if (+rangeEnd.value < +rangeStart.value) rangeEnd.value = rangeStart.value;
    document.getElementById("overviewRangeEndLabel").textContent = rangeEnd.value;
    debouncedUpdateOverviewCharts();
    saveOverviewConfig();
  };
  
  document.querySelectorAll("[data-metric]").forEach(cb => {
    cb.onchange = () => {
      updateMetricVisibility();
    };
  });
  
  loadUserPreferences();
  
  } catch (err) {
    console.error("Error setting up overview UI:", err);
  }
}

function updateOverviewCharts() {
  try {
  if (!overviewDataCache || !isAccountGroups) return;
  
  if (Object.keys(bsGLLookup).length === 0 && overviewDataCache.gl_history_all) {
    overviewDataCache.gl_history_all.forEach(row => {
      const acctNum = parseInt(row.Account_Num || row.Account, 10);
      if (isNaN(acctNum)) return;
      if (!bsGLLookup[acctNum]) bsGLLookup[acctNum] = {};
      Object.keys(row).forEach(key => {
        if (/^\d{4}-\d{2}$/.test(key)) {
          bsGLLookup[acctNum][key] = parseFloat(row[key]) || 0;
        }
      });
    });
  }
  
  const viewType = document.getElementById("overviewViewType").value;
  const year = parseInt(document.getElementById("overviewYear").value);
  const compare = document.getElementById("overviewCompare").checked;
  const excludeCurrent = document.getElementById("overviewExclude").checked;
  const rangeStart = parseInt(document.getElementById("overviewRangeStart").value);
  const rangeEnd = parseInt(document.getElementById("overviewRangeEnd").value);
  
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth() + 1;
  const currentMonthKey = `${currentYear}-${String(currentMonth).padStart(2, "0")}`;
  
  const needPriorForYoY = viewType === "monthly" || viewType === "quarterly";
  
  let labels = [];
  let periods = [];
  let priorPeriods = [];
  
  let viewSubtitle = "";
  
  if (viewType === "monthly") {
    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    viewSubtitle = `Monthly, ${year}`;
    for (let m = 1; m <= 12; m++) {
      const key = `${year}-${String(m).padStart(2, "0")}`;
      // Skip current month if exclude is checked
      if (excludeCurrent && key === currentMonthKey) continue;
      labels.push(`${monthNames[m - 1]} ${year}`);
      periods.push([key]);
      if (compare || needPriorForYoY) {
        priorPeriods.push([`${year - 1}-${String(m).padStart(2, "0")}`]);
      }
    }
  } else if (viewType === "quarterly") {
    viewSubtitle = `Quarterly, ${year}`;
    for (let q = 1; q <= 4; q++) {
      const qMonths = [];
      const priorQMonths = [];
      for (let m = (q - 1) * 3 + 1; m <= q * 3; m++) {
        qMonths.push(`${year}-${String(m).padStart(2, "0")}`);
        if (compare || needPriorForYoY) priorQMonths.push(`${year - 1}-${String(m).padStart(2, "0")}`);
      }
      // Skip current quarter if exclude is checked and it contains current month
      if (excludeCurrent && qMonths.includes(currentMonthKey)) continue;
      labels.push(`Q${q} ${year}`);
      periods.push(qMonths);
      if (compare || needPriorForYoY) priorPeriods.push(priorQMonths);
    }
  } else {
    viewSubtitle = `Annual, ${rangeStart} - ${rangeEnd}`;
    for (let y = rangeStart; y <= rangeEnd; y++) {
      // Skip current year if exclude is checked
      if (excludeCurrent && y === currentYear) continue;
      labels.push(String(y));
      const yearMonths = [];
      const priorYearMonths = [];
      for (let m = 1; m <= 12; m++) {
        yearMonths.push(`${y}-${String(m).padStart(2, "0")}`);
        if (compare) priorYearMonths.push(`${y - 1}-${String(m).padStart(2, "0")}`);
      }
      periods.push(yearMonths);
      if (compare) priorPeriods.push(priorYearMonths);
    }
  }
  
  // Update all chart subtitles
  const subtitleIds = [
    'overviewRevenueSubtitle', 'overviewGrossMarginSubtitle', 'overviewOpMarginSubtitle',
    'overviewCashSubtitle', 'overviewArApRatioSubtitle', 'overviewCurrentRatioSubtitle', 
    'overviewOverUnderSubtitle'
  ];
  subtitleIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.textContent = viewSubtitle;
  });
  
  const groups = isAccountGroups.income_statement.groups;
  
  const metrics = {
    revenue: { label: "Revenue", values: [], priorValues: [] },
    grossMargin: { label: "Gross Profit Margin %", values: [], priorValues: [], isPercent: true },
    opMargin: { label: "Operating Profit %", values: [], priorValues: [], isPercent: true },
    cash: { label: "Cash", values: [], priorValues: [], isBalance: true },
    currentRatio: { label: "Current Ratio", values: [], priorValues: [], isRatio: true },
    arApRatio: { label: "AR/AP Ratio", values: [], priorValues: [], isRatio: true },
    overUnder: { label: "Net Over/(Under) Billing", values: [], priorValues: [], isBalance: true }
  };
  
  const cashAccounts = [1001, 1003, 1004, 1005, 1006, 1007, 1040, 1090];
  const currentAssetAccounts = [1001, 1003, 1004, 1005, 1006, 1007, 1040, 1090, 1100, 1105, 1110, 1120, 1130, 1050, 1030];
  const currentLiabilityAccounts = [2000, 2005, 2010, 2015, 2016, 2017, 2018, 2021, 2023, 2025, 2028, 2030, 2070, 2100, 2110, 2120, 2130, 2140, 2200, 2250];
  // AR accounts excluding retention (1110)
  const arAccountsNoRetention = [1100, 1050, 1105];
  // AP accounts excluding retention (2010, 2015)
  const apAccountsNoRetention = [2000, 2005];
  // Over/Under billing accounts
  const underbillingAccount = 1050;
  const overbillingAccount = 2120;
  
  periods.forEach((periodMonths, idx) => {
    const rows = buildIncomeStatementRows(periodMonths, groups);
    const revenueRow = rows.find(r => r.label === "Revenue");
    const grossProfitRow = rows.find(r => r.label === "Gross Profit");
    const opIncomeRow = rows.find(r => r.label === "Operating Income");
    
    const rev = revenueRow ? revenueRow.value : 0;
    const gp = grossProfitRow ? grossProfitRow.value : 0;
    const opInc = opIncomeRow ? opIncomeRow.value : 0;
    
    metrics.revenue.values.push(rev);
    metrics.grossMargin.values.push(rev ? (gp / rev) * 100 : 0);
    metrics.opMargin.values.push(rev ? (opInc / rev) * 100 : 0);
    
    const endOfPeriod = periodMonths[periodMonths.length - 1];
    
    if (typeof getCumulativeBalance === 'function' && typeof bsGLLookup !== 'undefined') {
      const cashBal = getCumulativeBalance(cashAccounts, endOfPeriod, true);
      metrics.cash.values.push(cashBal);
      
      const caBal = getCumulativeBalance(currentAssetAccounts, endOfPeriod, true);
      const clBal = getCumulativeBalance(currentLiabilityAccounts, endOfPeriod, false);
      metrics.currentRatio.values.push(clBal !== 0 ? caBal / Math.abs(clBal) : 0);
      
      // AR/AP Ratio (excluding retention)
      const arBal = getCumulativeBalance(arAccountsNoRetention, endOfPeriod, true);
      const apBal = getCumulativeBalance(apAccountsNoRetention, endOfPeriod, false);
      metrics.arApRatio.values.push(apBal !== 0 ? arBal / Math.abs(apBal) : 0);
      
      // Net Over/(Under) Billing = Overbillings - Underbillings
      const underbillings = getCumulativeBalance([underbillingAccount], endOfPeriod, true);
      const overbillings = getCumulativeBalance([overbillingAccount], endOfPeriod, false);
      metrics.overUnder.values.push(Math.abs(overbillings) - underbillings);
    } else {
      metrics.cash.values.push(0);
      metrics.currentRatio.values.push(0);
      metrics.arApRatio.values.push(0);
      metrics.overUnder.values.push(0);
    }
    
    if ((compare || needPriorForYoY) && priorPeriods[idx]) {
      const priorRows = buildIncomeStatementRows(priorPeriods[idx], groups);
      const pRevRow = priorRows.find(r => r.label === "Revenue");
      const pGpRow = priorRows.find(r => r.label === "Gross Profit");
      const pOpIncRow = priorRows.find(r => r.label === "Operating Income");
      
      const pRev = pRevRow ? pRevRow.value : 0;
      const pGp = pGpRow ? pGpRow.value : 0;
      const pOpInc = pOpIncRow ? pOpIncRow.value : 0;
      
      metrics.revenue.priorValues.push(pRev);
      metrics.grossMargin.priorValues.push(pRev ? (pGp / pRev) * 100 : 0);
      metrics.opMargin.priorValues.push(pRev ? (pOpInc / pRev) * 100 : 0);
      
      const priorEndOfPeriod = priorPeriods[idx][priorPeriods[idx].length - 1];
      if (typeof getCumulativeBalance === 'function' && typeof bsGLLookup !== 'undefined') {
        const pCashBal = getCumulativeBalance(cashAccounts, priorEndOfPeriod, true);
        metrics.cash.priorValues.push(pCashBal);
        
        const pCaBal = getCumulativeBalance(currentAssetAccounts, priorEndOfPeriod, true);
        const pClBal = getCumulativeBalance(currentLiabilityAccounts, priorEndOfPeriod, false);
        metrics.currentRatio.priorValues.push(pClBal !== 0 ? pCaBal / Math.abs(pClBal) : 0);
        
        // Prior AR/AP Ratio (excluding retention)
        const pArBal = getCumulativeBalance(arAccountsNoRetention, priorEndOfPeriod, true);
        const pApBal = getCumulativeBalance(apAccountsNoRetention, priorEndOfPeriod, false);
        metrics.arApRatio.priorValues.push(pApBal !== 0 ? pArBal / Math.abs(pApBal) : 0);
        
        // Prior Net Over/(Under) Billing
        const pUnderbillings = getCumulativeBalance([underbillingAccount], priorEndOfPeriod, true);
        const pOverbillings = getCumulativeBalance([overbillingAccount], priorEndOfPeriod, false);
        metrics.overUnder.priorValues.push(Math.abs(pOverbillings) - pUnderbillings);
      } else {
        metrics.cash.priorValues.push(0);
        metrics.currentRatio.priorValues.push(0);
        metrics.arApRatio.priorValues.push(0);
        metrics.overUnder.priorValues.push(0);
      }
    }
  });
  
  const showTrend = document.getElementById("overviewTrend").checked;
  
  // Track which indices contain the current month (for coloring)
  const currentMonthIndices = [];
  if (!excludeCurrent) {
    if (viewType === "monthly") {
      for (let m = 1; m <= 12; m++) {
        const key = `${year}-${String(m).padStart(2, "0")}`;
        if (key === currentMonthKey) {
          // Count only non-excluded months before this one
          let idx = 0;
          for (let i = 1; i < m; i++) {
            idx++;
          }
          currentMonthIndices.push(idx);
        }
      }
    } else if (viewType === "quarterly") {
      const currentMonth = currentMonthKey.split("-")[1];
      const currentQuarter = Math.ceil(parseInt(currentMonth) / 3) - 1;
      if (parseInt(currentMonthKey.split("-")[0]) === year) {
        currentMonthIndices.push(currentQuarter);
      }
    } else if (viewType === "annual") {
      let yearIdx = 0;
      for (let y = rangeStart; y <= rangeEnd; y++) {
        if (y === currentYear) {
          currentMonthIndices.push(yearIdx);
          break;
        }
        yearIdx++;
      }
    }
  }
  
  const chartConfigs = [
    { id: "overviewRevenueChart", data: metrics.revenue },
    { id: "overviewGrossMarginChart", data: metrics.grossMargin },
    { id: "overviewOpMarginChart", data: metrics.opMargin },
    { id: "overviewCashChart", data: metrics.cash },
    { id: "overviewArApRatioChart", data: metrics.arApRatio }
  ];
  
  chartConfigs.forEach(cfg => {
    renderOverviewChart(cfg.id, labels, cfg.data, compare, showTrend, currentMonthIndices);
  });
  
  // Render Over/Under Billing chart separately (bar chart with pos/neg coloring)
  renderOverUnderBillingChart(labels, metrics.overUnder, compare, currentMonthIndices);
  
  updateOverviewStats(metrics, labels, excludeCurrent, currentMonthIndices);
  
  // Render data tables for each chart
  const tableConfigs = [
    { tableId: 'overviewRevenueTable', data: metrics.revenue, isPercent: false, isRatio: false },
    { tableId: 'overviewGrossMarginTable', data: metrics.grossMargin, isPercent: true, isRatio: false },
    { tableId: 'overviewOpMarginTable', data: metrics.opMargin, isPercent: true, isRatio: false },
    { tableId: 'overviewCashTable', data: metrics.cash, isPercent: false, isRatio: false },
    { tableId: 'overviewArApRatioTable', data: metrics.arApRatio, isPercent: false, isRatio: true },
    { tableId: 'overviewOverUnderTable', data: metrics.overUnder, isPercent: false, isRatio: false }
  ];
  
  tableConfigs.forEach(cfg => {
    renderOverviewDataTable(cfg.tableId, labels, cfg.data.values, compare ? cfg.data.priorValues : [], cfg.isPercent, cfg.isRatio, !cfg.isPercent && !cfg.isRatio);
  });
  
  initOverviewDataToggle();
  } catch (err) {
    console.error("Error updating overview charts:", err);
  }
}

function updateOverviewStats(metrics, labels, excludeCurrent, currentMonthIndices) {
  try {
  const statConfigs = [
    { key: "revenue", avgId: "revenueAvg", highId: "revenueHigh", lowId: "revenueLow", cagrId: "revenueCagr", highPeriodId: "revenueHighPeriod", lowPeriodId: "revenueLowPeriod", growthLabelId: "revenueGrowthLabel", isPercent: false },
    { key: "grossMargin", avgId: "grossMarginAvg", highId: "grossMarginHigh", lowId: "grossMarginLow", cagrId: "grossMarginCagr", highPeriodId: "grossMarginHighPeriod", lowPeriodId: "grossMarginLowPeriod", growthLabelId: "grossMarginGrowthLabel", isPercent: true },
    { key: "opMargin", avgId: "opMarginAvg", highId: "opMarginHigh", lowId: "opMarginLow", cagrId: "opMarginCagr", highPeriodId: "opMarginHighPeriod", lowPeriodId: "opMarginLowPeriod", growthLabelId: "opMarginGrowthLabel", isPercent: true },
    { key: "cash", avgId: "cashAvg", highId: "cashHigh", lowId: "cashLow", cagrId: "cashCagr", highPeriodId: "cashHighPeriod", lowPeriodId: "cashLowPeriod", growthLabelId: "cashGrowthLabel", isPercent: false },
    { key: "arApRatio", avgId: "arApRatioAvg", highId: "arApRatioHigh", lowId: "arApRatioLow", cagrId: "arApRatioCagr", highPeriodId: "arApRatioHighPeriod", lowPeriodId: "arApRatioLowPeriod", growthLabelId: "arApRatioGrowthLabel", isPercent: false, isRatio: true }
  ];
  
  const viewType = document.getElementById("overviewViewType").value;
  const year = parseInt(document.getElementById("overviewYear").value);
  
  const growthLabel = viewType === "annual" ? "CAGR" : "YoY";
  
  statConfigs.forEach(cfg => {
    const growthLabelEl = document.getElementById(cfg.growthLabelId);
    if (growthLabelEl) growthLabelEl.textContent = growthLabel;
    
    let allValues = metrics[cfg.key]?.values || [];
    let priorValues = metrics[cfg.key]?.priorValues || [];
    
    // Filter out current month if exclude is checked
    if (excludeCurrent && currentMonthIndices.length > 0) {
      const filteredValues = [];
      const filteredPriorValues = [];
      allValues.forEach((v, idx) => {
        if (!currentMonthIndices.includes(idx)) {
          filteredValues.push(v);
          if (priorValues[idx] !== undefined) filteredPriorValues.push(priorValues[idx]);
        }
      });
      allValues = filteredValues;
      priorValues = filteredPriorValues;
    }
    
    const values = allValues.filter(v => v !== 0);
    
    if (values.length === 0) {
      const avgEl = document.getElementById(cfg.avgId);
      const highEl = document.getElementById(cfg.highId);
      const lowEl = document.getElementById(cfg.lowId);
      const cagrEl = document.getElementById(cfg.cagrId);
      const highPeriodEl = document.getElementById(cfg.highPeriodId);
      const lowPeriodEl = document.getElementById(cfg.lowPeriodId);
      if (avgEl) avgEl.textContent = "-";
      if (highEl) highEl.textContent = "-";
      if (lowEl) lowEl.textContent = "-";
      if (cagrEl) cagrEl.textContent = "-";
      if (highPeriodEl) highPeriodEl.textContent = "";
      if (lowPeriodEl) lowPeriodEl.textContent = "";
      return;
    }
    
    const avg = values.reduce((a, b) => a + b, 0) / values.length;
    const high = Math.max(...allValues);
    const low = Math.min(...values);
    
    const highIdx = allValues.indexOf(high);
    const lowIdx = allValues.findIndex(v => v === low && v !== 0);
    
    let highPeriod = labels[highIdx] || "";
    let lowPeriod = labels[lowIdx] || "";
    
    if (viewType === "monthly") {
      highPeriod = highPeriod + " " + year;
      lowPeriod = lowPeriod + " " + year;
    } else if (viewType === "quarterly") {
      highPeriod = highPeriod + " " + year;
      lowPeriod = lowPeriod + " " + year;
    }
    
    let growthRate = 0;
    
    if (viewType === "annual") {
      const firstNonZeroIdx = allValues.findIndex(v => v !== 0);
      const lastNonZeroIdx = allValues.length - 1 - [...allValues].reverse().findIndex(v => v !== 0);
      
      if (firstNonZeroIdx !== -1 && lastNonZeroIdx !== -1 && firstNonZeroIdx !== lastNonZeroIdx) {
        const startVal = allValues[firstNonZeroIdx];
        const endVal = allValues[lastNonZeroIdx];
        const periods = lastNonZeroIdx - firstNonZeroIdx;
        if (startVal > 0 && endVal > 0 && periods > 0) {
          growthRate = (Math.pow(endVal / startVal, 1 / periods) - 1) * 100;
        }
      }
    } else {
      let totalCurrent = 0;
      let totalPrior = 0;
      
      for (let i = 0; i < allValues.length; i++) {
        const currVal = allValues[i] || 0;
        const priorVal = priorValues[i] || 0;
        totalCurrent += currVal;
        totalPrior += priorVal;
      }
      
      if (Math.abs(totalPrior) > 0) {
        growthRate = ((totalCurrent - totalPrior) / Math.abs(totalPrior)) * 100;
      }
    }
    
    const formatValue = (val, isPercent, isRatio) => {
      if (isRatio) {
        return val.toFixed(2) + "x";
      }
      if (isPercent) {
        const formatted = Math.abs(val) >= 1000 
          ? val.toLocaleString("en-US", { minimumFractionDigits: 1, maximumFractionDigits: 1 })
          : val.toFixed(1);
        return formatted + "%";
      }
      if (Math.abs(val) >= 1000000) return "$" + (val / 1000000).toLocaleString("en-US", { minimumFractionDigits: 1, maximumFractionDigits: 1 }) + "M";
      if (Math.abs(val) >= 1000) return "$" + Math.round(val / 1000).toLocaleString("en-US") + "K";
      return "$" + Math.round(val).toLocaleString("en-US");
    };
    
    const formatGrowth = (val) => {
      const sign = val >= 0 ? "+" : "";
      const formatted = Math.abs(val) >= 1000 
        ? val.toLocaleString("en-US", { minimumFractionDigits: 1, maximumFractionDigits: 1 })
        : val.toFixed(1);
      return sign + formatted + "%";
    };
    
    const avgEl = document.getElementById(cfg.avgId);
    if (avgEl) {
      avgEl.className = avg < 0 ? "stat-value negative" : "stat-value";
      if (cfg.isRatio) {
        animateRatio(avgEl, avg, 600);
      } else if (cfg.isPercent) {
        animatePercent(avgEl, avg, 600, false);
      } else {
        animateCurrency(avgEl, avg, 600);
      }
    }
    
    const highEl = document.getElementById(cfg.highId);
    if (highEl) {
      highEl.className = high < 0 ? "stat-value negative" : "stat-value";
      if (cfg.isRatio) {
        animateRatio(highEl, high, 600);
      } else if (cfg.isPercent) {
        animatePercent(highEl, high, 600, false);
      } else {
        animateCurrency(highEl, high, 600);
      }
    }
    
    const lowEl = document.getElementById(cfg.lowId);
    if (lowEl) {
      lowEl.className = low < 0 ? "stat-value negative" : "stat-value";
      if (cfg.isRatio) {
        animateRatio(lowEl, low, 600);
      } else if (cfg.isPercent) {
        animatePercent(lowEl, low, 600, false);
      } else {
        animateCurrency(lowEl, low, 600);
      }
    }
    
    const highPeriodEl = document.getElementById(cfg.highPeriodId);
    if (highPeriodEl) highPeriodEl.textContent = highPeriod;
    const lowPeriodEl = document.getElementById(cfg.lowPeriodId);
    if (lowPeriodEl) lowPeriodEl.textContent = lowPeriod;
    
    const cagrEl = document.getElementById(cfg.cagrId);
    if (cagrEl) {
      cagrEl.className = growthRate < 0 ? "stat-value negative" : "stat-value";
      animatePercent(cagrEl, growthRate, 600, true);
    }
  });
  
  // Update Over/Under Billing stats separately (uses current instead of CAGR)
  let overUnderValues = metrics.overUnder?.values || [];
  let overUnderLabels = [...labels];
  
  // Filter out current month if exclude is checked
  if (excludeCurrent && currentMonthIndices.length > 0) {
    const filteredValues = [];
    const filteredLabels = [];
    overUnderValues.forEach((v, idx) => {
      if (!currentMonthIndices.includes(idx)) {
        filteredValues.push(v);
        filteredLabels.push(labels[idx]);
      }
    });
    overUnderValues = filteredValues;
    overUnderLabels = filteredLabels;
  }
  
  if (overUnderValues.length > 0) {
    const nonZeroValues = overUnderValues.filter(v => v !== 0);
    const avg = nonZeroValues.length > 0 ? nonZeroValues.reduce((a, b) => a + b, 0) / nonZeroValues.length : 0;
    const high = overUnderValues.length > 0 ? Math.max(...overUnderValues) : 0;
    const low = nonZeroValues.length > 0 ? Math.min(...nonZeroValues) : 0;
    const current = overUnderValues[overUnderValues.length - 1] || 0;
    
    const highIdx = overUnderValues.indexOf(high);
    const lowIdx = nonZeroValues.length > 0 ? overUnderValues.indexOf(low) : -1;
    const highPeriod = highIdx >= 0 && overUnderLabels[highIdx] ? overUnderLabels[highIdx] : '';
    const lowPeriod = lowIdx >= 0 && overUnderLabels[lowIdx] ? overUnderLabels[lowIdx] : '';
    
    const avgEl = document.getElementById('overUnderAvg');
    const highEl = document.getElementById('overUnderHigh');
    const lowEl = document.getElementById('overUnderLow');
    const currentEl = document.getElementById('overUnderCurrent');
    const highPeriodEl = document.getElementById('overUnderHighPeriod');
    const lowPeriodEl = document.getElementById('overUnderLowPeriod');
    
    if (avgEl) {
      avgEl.className = avg < 0 ? 'stat-value negative' : 'stat-value';
      animateCurrency(avgEl, avg, 600);
    }
    if (highEl) {
      highEl.className = high < 0 ? 'stat-value negative' : 'stat-value';
      animateCurrency(highEl, high, 600);
    }
    if (lowEl) {
      lowEl.className = low < 0 ? 'stat-value negative' : 'stat-value';
      animateCurrency(lowEl, low, 600);
    }
    if (currentEl) {
      currentEl.className = current < 0 ? 'stat-value negative' : 'stat-value';
      animateCurrency(currentEl, current, 600);
    }
    if (highPeriodEl) highPeriodEl.textContent = highPeriod;
    if (lowPeriodEl) lowPeriodEl.textContent = lowPeriod;
  }
  } catch (err) {
    console.error("Error updating overview stats:", err);
  }
}

let overUnderChartInstance = null;

function renderOverUnderBillingChart(labels, metricData, compare, currentMonthIndices) {
  const canvas = document.getElementById('overviewOverUnderChart');
  if (!canvas) return;
  
  if (overUnderChartInstance) {
    overUnderChartInstance.destroy();
  }
  
  const ctx = canvas.getContext('2d');
  if (!ctx) return;
  
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#e2e8f0' : '#374151';
  const gridColor = isDark ? '#334155' : '#e5e7eb';
  
  // Get trendline and data labels settings from config checkboxes
  const showTrendline = document.getElementById('overviewTrend')?.checked || false;
  const showDataLabels = document.getElementById('overviewDataLabels')?.checked || false;
  
  const values = metricData.values || [];
  const priorValues = metricData.priorValues || [];
  
  // Create bar colors based on positive/negative values
  const barColors = values.map(v => v >= 0 ? 'rgba(34, 197, 94, 0.8)' : 'rgba(239, 68, 68, 0.8)');
  const borderColors = values.map(v => v >= 0 ? '#22c55e' : '#ef4444');
  
  const datasets = [{
    label: 'Net Over/(Under)',
    data: values,
    backgroundColor: barColors,
    borderColor: borderColors,
    borderWidth: 1,
    borderRadius: 4
  }];
  
  if (compare && priorValues.length > 0) {
    const priorBarColors = priorValues.map(v => v >= 0 ? 'rgba(34, 197, 94, 0.4)' : 'rgba(239, 68, 68, 0.4)');
    const priorBorderColors = priorValues.map(v => v >= 0 ? '#22c55e' : '#ef4444');
    
    datasets.unshift({
      label: 'Prior Year',
      data: priorValues,
      backgroundColor: priorBarColors,
      borderColor: priorBorderColors,
      borderWidth: 1,
      borderRadius: 4
    });
  }
  
  // Add trendline if enabled
  if (showTrendline && values.length > 1) {
    const validValues = values.map((v, i) => ({ x: i, y: v })).filter(p => p.y !== null && p.y !== undefined && !isNaN(p.y));
    if (validValues.length > 1) {
      const n = validValues.length;
      const sumX = validValues.reduce((s, p) => s + p.x, 0);
      const sumY = validValues.reduce((s, p) => s + p.y, 0);
      const sumXY = validValues.reduce((s, p) => s + p.x * p.y, 0);
      const sumXX = validValues.reduce((s, p) => s + p.x * p.x, 0);
      const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
      const intercept = (sumY - slope * sumX) / n;
      const trendData = values.map((_, i) => slope * i + intercept);
      
      datasets.push({
        label: 'Trend',
        data: trendData,
        type: 'line',
        borderColor: isDark ? '#94a3b8' : '#6b7280',
        borderWidth: 2,
        borderDash: [5, 5],
        pointRadius: 0,
        fill: false,
        tension: 0
      });
    }
  }
  
  overUnderChartInstance = new Chart(canvas, {
    type: 'bar',
    data: { labels, datasets },
    plugins: showDataLabels ? [ChartDataLabels] : [],
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { top: showDataLabels ? 20 : 0 }
      },
      plugins: {
        legend: {
          display: (compare && priorValues.length > 0) || showTrendline,
          position: 'bottom',
          labels: { color: textColor, boxWidth: 12, padding: 8, font: { size: 10 } }
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              if (context.dataset.type === 'line') return null;
              const value = context.raw;
              return context.dataset.label + ': ' + formatCurrency(value);
            }
          }
        },
        datalabels: {
          display: (context) => {
            if (!showDataLabels) return false;
            if (context.dataset.type === 'line') return false;
            return true;
          },
          anchor: 'end',
          align: 'top',
          offset: 2,
          font: { size: 8, weight: '500' },
          color: textColor,
          formatter: (value) => {
            if (value === 0 || value === null) return '';
            return formatCurrencyCompact(value);
          }
        }
      },
      scales: {
        x: {
          grid: { color: gridColor, drawBorder: false },
          ticks: { color: textColor, font: { size: 10 } }
        },
        y: {
          grid: { color: gridColor, drawBorder: false },
          ticks: {
            color: textColor,
            font: { size: 10 },
            callback: function(value) {
              return formatCurrencyCompact(value);
            }
          }
        }
      }
    }
  });
  
  // Register to overviewChartInstances for fullscreen functionality
  overviewChartInstances['overviewOverUnderChart'] = overUnderChartInstance;
}

function createBarGradient(ctx, chartArea, colorStart, colorEnd) {
  if (!chartArea) return colorStart;
  const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
  gradient.addColorStop(0, colorStart);
  gradient.addColorStop(1, colorEnd);
  return gradient;
}

const gradientColors = {
  blue: { start: "#2563eb", end: "#60a5fa" },
  red: { start: "#dc2626", end: "#f87171" },
  orange: { start: "#d97706", end: "#fbbf24" }
};

let overviewDataTableCache = {};

function initOverviewDataToggle() {
  document.querySelectorAll('.chart-data-toggle').forEach(btn => {
    btn.removeEventListener('click', handleDataToggleClick);
    btn.addEventListener('click', handleDataToggleClick);
  });
}

function handleDataToggleClick(e) {
  const btn = e.currentTarget;
  const targetId = btn.getAttribute('data-target');
  const wrapper = document.getElementById(targetId);
  if (!wrapper) return;
  
  const isCollapsed = wrapper.classList.contains('collapsed');
  if (isCollapsed) {
    wrapper.classList.remove('collapsed');
    wrapper.classList.add('expanded');
    btn.textContent = 'Collapse';
  } else {
    wrapper.classList.remove('expanded');
    wrapper.classList.add('collapsed');
    btn.textContent = 'Expand';
  }
}

function renderOverviewDataTable(tableId, labels, values, priorValues, isPercent, isRatio, isCurrency) {
  const wrapper = document.getElementById(tableId);
  if (!wrapper) return;
  
  const table = wrapper.querySelector('table');
  if (!table) return;
  
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  
  let headerHtml = '<tr><th>Period</th><th>Value</th>';
  if (priorValues && priorValues.length > 0) {
    headerHtml += '<th>Prior</th><th>Change</th>';
  }
  headerHtml += '</tr>';
  thead.innerHTML = headerHtml;
  
  let bodyHtml = '';
  labels.forEach((label, idx) => {
    const value = values[idx] || 0;
    const formattedValue = formatOverviewTableValue(value, isPercent, isRatio, isCurrency);
    
    bodyHtml += '<tr>';
    bodyHtml += '<td>' + label + '</td>';
    bodyHtml += '<td>' + formattedValue + '</td>';
    
    if (priorValues && priorValues.length > 0) {
      const prior = priorValues[idx] || 0;
      const formattedPrior = formatOverviewTableValue(prior, isPercent, isRatio, isCurrency);
      const change = prior !== 0 ? ((value - prior) / Math.abs(prior)) * 100 : 0;
      const changeClass = change < 0 ? 'style="color:#ef4444"' : (change > 0 ? 'style="color:#22c55e"' : '');
      const changeSign = change > 0 ? '+' : '';
      bodyHtml += '<td>' + formattedPrior + '</td>';
      bodyHtml += '<td ' + changeClass + '>' + changeSign + change.toFixed(1) + '%</td>';
    }
    
    bodyHtml += '</tr>';
  });
  
  tbody.innerHTML = bodyHtml;
  overviewDataTableCache[tableId] = { labels, values, priorValues, isPercent, isRatio, isCurrency };
}

function formatOverviewTableValue(value, isPercent, isRatio, isCurrency) {
  if (isRatio) {
    return value.toFixed(2) + 'x';
  }
  if (isPercent) {
    return value.toFixed(1) + '%';
  }
  if (isCurrency !== false) {
    return formatCurrency(value);
  }
  return value.toLocaleString('en-US', { maximumFractionDigits: 2 });
}

function renderOverviewChart(canvasId, labels, metricData, showPrior, showTrend, currentMonthIndices) {
  try {
    const canvas = document.getElementById(canvasId);
    if (!canvas) {
      console.error("Canvas not found:", canvasId);
      return;
    }
    
    if (overviewChartInstances[canvasId]) {
      overviewChartInstances[canvasId].destroy();
    }
    
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      console.error("Could not get 2D context for:", canvasId);
      return;
    }
    
    const datasets = [];
  
  if (showPrior && metricData.priorValues.length > 0) {
    datasets.push({
      label: "Prior Year",
      data: metricData.priorValues,
      backgroundColor: (context) => {
        const chart = context.chart;
        const { ctx, chartArea } = chart;
        return createBarGradient(ctx, chartArea, gradientColors.red.start, gradientColors.red.end);
      },
      borderRadius: 4,
      barPercentage: 0.9,
      categoryPercentage: 0.85
    });
  }
  
  datasets.push({
    label: "Current",
    data: metricData.values,
    backgroundColor: (context) => {
      const chart = context.chart;
      const { ctx, chartArea } = chart;
      const datasetIndex = context.datasetIndex;
      const dataIndex = context.dataIndex;
      
      // Use orange for current month if not excluding it
      if (currentMonthIndices && currentMonthIndices.length > 0 && currentMonthIndices.includes(dataIndex)) {
        return createBarGradient(ctx, chartArea, gradientColors.orange.start, gradientColors.orange.end);
      }
      
      return createBarGradient(ctx, chartArea, gradientColors.blue.start, gradientColors.blue.end);
    },
    borderRadius: 4,
    barPercentage: 0.9,
    categoryPercentage: 0.85
  });
  
  if (showTrend && metricData.values.length > 1) {
    const trendData = calculateTrendline(metricData.values);
    datasets.push({
      label: "Trendline",
      data: trendData,
      type: "line",
      borderColor: "#10b981",
      borderWidth: 2,
      borderDash: [5, 5],
      fill: false,
      pointRadius: 0,
      tension: 0,
      order: 0
    });
  }
  
  const dataLabelsCheckbox = document.getElementById("overviewDataLabels");
  const showDataLabels = dataLabelsCheckbox ? dataLabelsCheckbox.checked : false;
  
  // Calculate Y-axis minimum based on data
  let allValues = [...metricData.values];
  if (showPrior && metricData.priorValues.length > 0) {
    allValues = allValues.concat(metricData.priorValues);
  }
  const validValues = allValues.filter(v => v !== null && v !== undefined && !isNaN(v));
  const dataMin = validValues.length > 0 ? Math.min(...validValues) : 0;
  const dataMax = validValues.length > 0 ? Math.max(...validValues) : 0;
  
  // Calculate appropriate Y-axis min (start just below the lowest value)
  let yMin = undefined;
  if (dataMin > 0) {
    const range = dataMax - dataMin;
    // Use 15% of range as padding, or 10% of dataMin if flat data
    const padding = range > 0 ? range * 0.15 : dataMin * 0.1;
    
    if (metricData.isRatio) {
      // For ratios, round to nearest 0.1
      yMin = Math.floor((dataMin - padding) * 10) / 10;
      if (yMin < 0) yMin = 0;
    } else if (metricData.isPercent) {
      // For percentages, round to nearest 1%
      yMin = Math.floor(dataMin - padding);
      if (yMin < 0) yMin = 0;
    } else {
      // For currency, round to a nice number
      let step;
      if (dataMin >= 1000000) {
        step = 100000;
      } else if (dataMin >= 100000) {
        step = 10000;
      } else if (dataMin >= 10000) {
        step = 5000;
      } else if (dataMin >= 1000) {
        step = 500;
      } else {
        step = 100;
      }
      yMin = Math.floor((dataMin - padding) / step) * step;
      if (yMin < 0) yMin = 0;
    }
  }
  
  const themeColors = getChartThemeColors();
  
  overviewChartInstances[canvasId] = new Chart(canvas, {
    type: "bar",
    data: { labels, datasets },
    plugins: [ChartDataLabels],
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: {
        duration: 800,
        easing: 'easeOutQuart',
        delay: (context) => {
          let delay = 0;
          if (context.type === 'data' && context.mode === 'default') {
            delay = context.dataIndex * 50 + context.datasetIndex * 100;
          }
          return delay;
        }
      },
      transitions: {
        active: {
          animation: {
            duration: 200
          }
        }
      },
      layout: {
        padding: { top: showDataLabels ? 20 : 0 }
      },
      plugins: {
        legend: { display: showPrior || showTrend, position: "bottom", labels: { boxWidth: 12, font: { size: 10 }, color: themeColors.legendColor } },
        tooltip: {
          backgroundColor: "rgba(31, 41, 55, 0.95)",
          titleFont: { size: 13 },
          bodyFont: { size: 12 },
          padding: 10,
          callbacks: {
            title: function(tooltipItems) {
              return tooltipItems[0].label;
            },
            label: function(context) {
              if (context.dataset.type === "line") return null;
              const value = context.parsed.y;
              const datasetLabel = context.dataset.label === "Current" ? "" : context.dataset.label + ": ";
              if (metricData.isRatio) {
                return datasetLabel + value.toFixed(2) + "x";
              }
              if (metricData.isPercent) {
                return datasetLabel + value.toFixed(1) + "%";
              }
              if (Math.abs(value) >= 1000000) {
                return datasetLabel + "$" + (value / 1000000).toFixed(2) + "M";
              }
              return datasetLabel + "$" + value.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
          }
        },
        datalabels: {
          display: (context) => {
            if (!showDataLabels) return false;
            if (context.dataset.type === "line") return false;
            return true;
          },
          anchor: "end",
          align: "top",
          offset: 2,
          font: { size: 8, weight: "500" },
          color: themeColors.textColor,
          formatter: (value) => {
            if (value === 0 || value === null) return "";
            if (metricData.isRatio) return value.toFixed(2) + "x";
            if (metricData.isPercent) return value.toFixed(1) + "%";
            if (Math.abs(value) >= 1000000) return "$" + (value / 1000000).toFixed(1) + "M";
            if (Math.abs(value) >= 1000) return "$" + (value / 1000).toFixed(0) + "K";
            return "$" + value.toFixed(0);
          }
        }
      },
      scales: {
        x: { grid: { display: false, color: themeColors.gridColor }, ticks: { font: { size: 9 }, color: themeColors.textColor } },
        y: {
          min: yMin,
          grid: { color: themeColors.gridColor },
          ticks: {
            font: { size: 9 },
            color: themeColors.textColor,
            callback: v => metricData.isRatio ? v.toFixed(1) + "x" : (metricData.isPercent ? v.toFixed(0) + "%" : (Math.abs(v) >= 1000000 ? "$" + (v / 1000000).toFixed(1) + "M" : "$" + (v / 1000).toFixed(0) + "K"))
          }
        }
      }
    }
  });
  } catch (err) {
    console.error("Error rendering chart " + canvasId + ":", err);
  }
}

initOverviewModule();

/* ============================================================
   FINANCIALS SECTION (STATIC CHARTS)
============================================================ */
async function loadFinancialCharts() {
  // This function is deprecated - overview charts now use GL data directly
  // Kept for backwards compatibility but does nothing
  return;
}

/* Utility: subtle gradient generator with solid color fallback */
function makeGradient(canvas, base) {
  try {
    const ctx = canvas.getContext("2d");
    if (!ctx) return base;
    
    const height = canvas.clientHeight || canvas.offsetHeight || 300;
    if (height <= 0) return base;
    
    const g = ctx.createLinearGradient(0, 0, 0, height);
    if (base === "#3b82f6") {
      g.addColorStop(0, "#60a5fa");
      g.addColorStop(1, "#1d4ed8");
    } else if (base === "#dc2626") {
      g.addColorStop(0, "#f87171");
      g.addColorStop(1, "#b91c1c");
    } else {
      g.addColorStop(0, base);
      g.addColorStop(1, base);
    }
    return g;
  } catch (err) {
    console.error("Gradient error:", err);
    return base;
  }
}

/* Utility: calculate linear regression trendline */
function calculateTrendline(data) {
  const n = data.length;
  if (n === 0) return [];
  
  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
  for (let i = 0; i < n; i++) {
    sumX += i;
    sumY += data[i];
    sumXY += i * data[i];
    sumX2 += i * i;
  }
  
  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;
  
  return data.map((_, i) => slope * i + intercept);
}

/* Utility renderer for Financials section */
function renderFinancialBar(id, label, labels, values) {
  const ctx = document.getElementById(id);
  if (!ctx) return;

  const gradient = makeGradient(ctx, "#3b82f6");

  new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [
        {
          label,
          data: values,
          backgroundColor: gradient
        }
      ]
    },
    options: {
      responsive: true,
      aspectRatio: 1.8,
      animation: {
        duration: 800,
        easing: 'easeOutQuart',
        delay: (context) => {
          let delay = 0;
          if (context.type === 'data' && context.mode === 'default') {
            delay = context.dataIndex * 50;
          }
          return delay;
        }
      },
      transitions: {
        active: { animation: { duration: 200 } }
      },
      scales: {
        y: {
          ticks: {
            callback: v => "$" + v.toLocaleString()
          }
        }
      }
    }
  });
}

/* ============================================================
   REVENUE VIEW — UI INITIALIZATION
============================================================ */

let revenueDataCache = null;
let revChartInstance = null;
let currentTableData = { labels: [], datasets: [] };

function buildRevenueFromGLHistory(data) {
  if (data.revenue) return data;
  if (!data.gl_history_all) return data;
  
  const revenueAccounts = ['4000', '4100', '4200', '4300', '4400'];
  const revenue = {};
  
  data.gl_history_all.forEach(entry => {
    const acctNum = String(entry.Account_Num || '');
    if (!revenueAccounts.includes(acctNum)) return;
    
    Object.keys(entry).forEach(key => {
      if (!/^\d{4}-\d{2}$/.test(key)) return;
      const [year, month] = key.split('-').map(Number);
      
      if (!revenue[year]) revenue[year] = new Array(12).fill(0);
      
      const val = parseFloat(entry[key]) || 0;
      revenue[year][month - 1] += Math.abs(val);
    });
  });
  
  data.revenue = revenue;
  return data;
}

/* ------------------------------------------------------------
   INIT MODULE
------------------------------------------------------------ */
async function initRevenueModule() {
  const spinner = document.getElementById("revLoadingSpinner");
  
  try {
    if (spinner) spinner.classList.remove("hidden");
    
    if (!revenueDataCache) {
      const response = await fetch("/data/financials_gl.json");
      if (!response.ok) throw new Error("Failed to fetch revenue data");
      revenueDataCache = await response.json();
      revenueDataCache = buildRevenueFromGLHistory(revenueDataCache);
    }

    setupRevenueUI(revenueDataCache);
    loadRevenueConfig();
    
    spinner.classList.add("hidden");
    updateRevenueView(revenueDataCache);

  } catch (err) {
    console.error("Revenue module error:", err);
    spinner.classList.add("hidden");
  }
}

/* ------------------------------------------------------------
   EXPORT DROPDOWN & FUNCTIONALITY (Universal for all views)
------------------------------------------------------------ */
function setupExportButtons() {
  const dropdown = document.getElementById("exportDropdownMenu");
  const dropdownBtn = document.getElementById("exportDropdownBtn");
  
  if (dropdownBtn) {
    dropdownBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      dropdown.classList.toggle("hidden");
    });
  }
  
  document.addEventListener("click", (e) => {
    if (!e.target.closest(".export-dropdown")) {
      if (dropdown) dropdown.classList.add("hidden");
    }
  });
  
  const printBtn = document.getElementById("exportPrintBtn");
  if (printBtn) {
    printBtn.onclick = () => {
      dropdown.classList.add("hidden");
      universalPrint();
    };
  }
  
  const pdfBtn = document.getElementById("exportPdfBtn");
  if (pdfBtn) {
    pdfBtn.onclick = () => {
      dropdown.classList.add("hidden");
      universalExportToPdf();
    };
  }
  
  const emailBtn = document.getElementById("exportEmailBtn");
  if (emailBtn) {
    emailBtn.onclick = () => {
      dropdown.classList.add("hidden");
      openEmailModal();
    };
  }
  
  
  // Desktop ribbon buttons
  const ribbonPrint = document.getElementById("exportPrintBtnRibbon");
  const ribbonPdf = document.getElementById("exportPdfBtnRibbon");
  const ribbonEmail = document.getElementById("exportEmailBtnRibbon");
  
  if (ribbonPrint) ribbonPrint.onclick = () => universalPrint();
  if (ribbonPdf) ribbonPdf.onclick = () => universalExportToPdf();
  if (ribbonEmail) ribbonEmail.onclick = () => openEmailModal();
  
  // Setup table-specific export buttons
  setupTableExportButtons();
}

function setupTableExportButtons() {
  const tables = [
    { id: 'incomeStatementTable', name: 'income-statement', section: 'incomeStatement' },
    { id: 'balanceSheetTable', name: 'balance-sheet', section: 'balanceSheet' },
    { id: 'cashFlowTable', name: 'cash-flows', section: 'cashFlows' },
    { id: 'jobBudgetsTable', name: 'job-budgets', section: 'jobBudgets' },
    { id: 'jobActualsTable', name: 'job-actuals', section: 'jobActuals' },
    { id: 'oubTable', name: 'over-under-billing', section: 'overUnderBilling' },
    { id: 'costCodesTable', name: 'cost-codes', section: 'costCodes' },
    { id: 'paymentsTable', name: 'payments', section: 'payments' },
    { id: 'apAgingTable', name: 'ap-aging', section: 'apAging' },
    { id: 'arAgingTable', name: 'ar-aging', section: 'arAging' },
    { id: 'dcrDepositsTable', name: 'cash-deposits', section: 'cashReport' },
    { id: 'dcrWithdrawalsTable', name: 'cash-withdrawals', section: 'cashReport' }
  ];
  
  tables.forEach(({ id, name, section }) => {
    const table = document.getElementById(id);
    if (!table) return;
    
    const container = table.closest('.job-table-container, .table-wrapper, .is-table-box, .rev-table-box');
    if (!container) return;
    
    if (container.querySelector('.table-export-btns')) return;
    
    const btnRow = document.createElement('div');
    btnRow.className = 'table-export-row';
    btnRow.style.cssText = 'display:flex;justify-content:flex-end;margin-bottom:8px;';
    
    const btnGroup = document.createElement('div');
    btnGroup.className = 'table-export-btns';
    
    const csvBtn = document.createElement('button');
    csvBtn.className = 'export-table-btn csv-btn';
    csvBtn.textContent = 'CSV';
    csvBtn.title = 'Export to CSV';
    csvBtn.onclick = () => exportTableToCsv(id, name);
    
    const excelBtn = document.createElement('button');
    excelBtn.className = 'export-table-btn excel-btn';
    excelBtn.textContent = 'Excel';
    excelBtn.title = 'Export to Excel';
    excelBtn.onclick = () => exportTableToExcel(id, name);
    
    const dropdownBtn = document.createElement('button');
    dropdownBtn.className = 'table-export-dropdown-btn';
    dropdownBtn.innerHTML = '⬇';
    dropdownBtn.title = 'Export options';
    
    const dropdownMenu = document.createElement('div');
    dropdownMenu.className = 'table-export-dropdown-menu hidden';
    
    const csvOption = document.createElement('button');
    csvOption.textContent = 'CSV';
    csvOption.onclick = (e) => { e.stopPropagation(); exportTableToCsv(id, name); dropdownMenu.classList.add('hidden'); };
    
    const excelOption = document.createElement('button');
    excelOption.textContent = 'Excel';
    excelOption.onclick = (e) => { e.stopPropagation(); exportTableToExcel(id, name); dropdownMenu.classList.add('hidden'); };
    
    dropdownMenu.appendChild(csvOption);
    dropdownMenu.appendChild(excelOption);
    
    dropdownBtn.onclick = (e) => {
      e.stopPropagation();
      document.querySelectorAll('.table-export-dropdown-menu').forEach(m => {
        if (m !== dropdownMenu) m.classList.add('hidden');
      });
      dropdownMenu.classList.toggle('hidden');
    };
    
    btnGroup.appendChild(csvBtn);
    btnGroup.appendChild(excelBtn);
    btnGroup.appendChild(dropdownBtn);
    btnGroup.appendChild(dropdownMenu);
    btnRow.appendChild(btnGroup);
    
    container.insertBefore(btnRow, table);
  });
  
  document.addEventListener('click', () => {
    document.querySelectorAll('.table-export-dropdown-menu').forEach(m => m.classList.add('hidden'));
  });
}

function exportTableToCsv(tableId, filename) {
  const table = document.getElementById(tableId);
  if (!table) return alert('Table not found');
  
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  if (!tbody || tbody.children.length === 0) return alert('No data to export');
  
  let csv = '';
  
  if (thead) {
    const headers = [];
    thead.querySelectorAll('th').forEach(th => {
      if (!th.classList.contains('hidden') && th.style.display !== 'none') {
        headers.push(`"${th.textContent.trim().replace(/"/g, '""')}"`);
      }
    });
    csv += headers.join(',') + '\n';
  }
  
  Array.from(tbody.children).forEach(tr => {
    if (tr.style.display === 'none') return;
    const cells = [];
    tr.querySelectorAll('td').forEach(td => {
      if (!td.classList.contains('hidden') && td.style.display !== 'none') {
        cells.push(`"${td.textContent.trim().replace(/"/g, '""')}"`);
      }
    });
    if (cells.length > 0) csv += cells.join(',') + '\n';
  });
  
  const dateStr = new Date().toISOString().split('T')[0];
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `ftg_${filename}_${dateStr}.csv`;
  a.click();
  URL.revokeObjectURL(url);
}

async function exportTableToExcel(tableId, filename) {
  const table = document.getElementById(tableId);
  if (!table) return alert('Table not found');
  
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  if (!tbody || tbody.children.length === 0) return alert('No data to export');
  
  try {
    await LazyLoader.load('exceljs');
  } catch (err) {
    return alert('Failed to load Excel library. Please check your internet connection.');
  }
  
  const rows = [];
  
  if (thead) {
    thead.querySelectorAll('tr').forEach(tr => {
      const cells = [];
      tr.querySelectorAll('th').forEach(th => {
        if (!th.classList.contains('hidden') && th.style.display !== 'none') {
          cells.push(th.textContent.trim());
        }
      });
      if (cells.length > 0) rows.push({ cells, isHeader: true });
    });
  }
  
  Array.from(tbody.children).forEach(tr => {
    if (tr.style.display === 'none') return;
    const cells = [];
    const isGroupHeader = tr.classList.contains('is-group-header') || tr.classList.contains('bs-group-header');
    const isTotalRow = tr.classList.contains('is-total') || tr.classList.contains('bs-total') || tr.classList.contains('grand-total');
    
    tr.querySelectorAll('td').forEach(td => {
      if (!td.classList.contains('hidden') && td.style.display !== 'none') {
        cells.push(td.textContent.trim());
      }
    });
    if (cells.length > 0) rows.push({ cells, isHeader: false, isGroupHeader, isTotalRow });
  });
  
  if (rows.length === 0) return alert('No data to export');
  
  const workbook = new ExcelJS.Workbook();
  workbook.creator = 'FTG Dashboard';
  workbook.created = new Date();
  
  const sheetName = filename.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()).substring(0, 31);
  const worksheet = workbook.addWorksheet(sheetName);
  
  const headerFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF1F2937' } };
  const headerFont = { bold: true, color: { argb: 'FFFFFFFF' }, size: 11 };
  const groupHeaderFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE5E7EB' } };
  const groupHeaderFont = { bold: true, color: { argb: 'FF374151' }, size: 11 };
  const totalFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF3F4F6' } };
  const totalFont = { bold: true, color: { argb: 'FF111827' }, size: 11 };
  const borderStyle = { style: 'thin', color: { argb: 'FFD1D5DB' } };
  const allBorders = { top: borderStyle, left: borderStyle, bottom: borderStyle, right: borderStyle };
  
  const currencyColumns = new Set();
  rows.forEach((row, idx) => {
    if (row.isHeader) return;
    row.cells.forEach((cell, colIdx) => {
      if (cell.includes('$')) currencyColumns.add(colIdx);
    });
  });
  
  rows.forEach((row, rowIdx) => {
    const excelRow = worksheet.addRow(row.cells.map((cell, colIdx) => {
      if (row.isHeader) return cell;
      const cleanValue = cell.replace(/[$,]/g, '').replace(/\(([^)]+)\)/g, '-$1');
      const numValue = parseFloat(cleanValue);
      if (!isNaN(numValue) && cleanValue !== '' && !cell.includes('%')) return numValue;
      return cell;
    }));
    
    excelRow.eachCell({ includeEmpty: true }, (cell, colNumber) => {
      cell.border = allBorders;
      cell.alignment = { vertical: 'middle' };
      
      if (row.isHeader) {
        cell.fill = headerFill;
        cell.font = headerFont;
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
      } else if (row.isGroupHeader) {
        cell.fill = groupHeaderFill;
        cell.font = groupHeaderFont;
      } else if (row.isTotalRow) {
        cell.fill = totalFill;
        cell.font = totalFont;
      }
      
      if (!row.isHeader && currencyColumns.has(colNumber - 1) && typeof cell.value === 'number') {
        cell.numFmt = '"$"#,##0';
        cell.alignment = { horizontal: 'right', vertical: 'middle' };
      }
    });
  });
  
  const colCount = rows[0]?.cells.length || 0;
  for (let i = 1; i <= colCount; i++) {
    let maxWidth = 12;
    worksheet.getColumn(i).eachCell({ includeEmpty: false }, cell => {
      const len = String(cell.value || '').length;
      maxWidth = Math.max(maxWidth, len + 2);
    });
    worksheet.getColumn(i).width = Math.min(maxWidth, 45);
  }
  
  const headerRowCount = rows.filter(r => r.isHeader).length || 1;
  worksheet.views = [{ state: 'frozen', ySplit: headerRowCount }];
  
  const buffer = await workbook.xlsx.writeBuffer();
  const dateStr = new Date().toISOString().split('T')[0];
  const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `ftg_${filename}_${dateStr}.xlsx`;
  a.click();
  URL.revokeObjectURL(url);
}

// Keep old function for backwards compatibility
function exportTableToCSV(tableId, filename) {
  exportTableToCsv(tableId, filename);
}

/* ------------------------------------------------------------
   AUTH HELPER FUNCTIONS
------------------------------------------------------------ */

function getAuthToken() {
  return localStorage.getItem("ftg_session_token") || "";
}

function getCurrentView() {
  const sections = ["overview", "revenue", "accounts", "incomeStatement", "balanceSheet", "cashFlows", "cashReports", "cashReport", "jobOverview", "jobBudgets", "jobActuals", "overUnderBilling", "costCodes", "missingBudgets", "pmReport", "aiInsights", "payments", "apAging", "arAging", "jobAnalytics", "deptHeadMeeting", "monthEndReporting", "admin"];
  for (const s of sections) {
    const el = document.getElementById(s);
    if (el && el.classList.contains("visible")) return s;
  }
  return "overview";
}

function getReportData() {
  const view = getCurrentView();
  
  if (view === "overview") {
    return {
      title: "Executive Overview",
      subtitle: getOverviewSubtitle(),
      tableHtml: getOverviewTableHtml(),
      csvData: getOverviewCsvData(),
      isWide: true
    };
  } else if (view === "revenue") {
    return {
      title: "Revenue Report",
      subtitle: getRevenueSubtitle(),
      tableHtml: getRevenueTableHtml(),
      csvData: getRevenueCsvData(),
      isWide: isRevenueWide()
    };
  } else if (view === "accounts") {
    return {
      title: "Account Detail Report",
      subtitle: getAccountSubtitle(),
      tableHtml: getAccountTableHtml(),
      csvData: getAccountCsvData(),
      isWide: isAccountWide()
    };
  } else if (view === "incomeStatement") {
    return {
      title: "Income Statement",
      subtitle: getIncomeStatementSubtitle(),
      tableHtml: getIncomeStatementTableHtml(),
      csvData: getIncomeStatementCsvData(),
      isWide: isIncomeStatementWide(),
      aiAnalysis: getIncomeStatementAiAnalysis()
    };
  } else if (view === "balanceSheet") {
    return {
      title: "Balance Sheet",
      subtitle: getBalanceSheetSubtitle(),
      tableHtml: getBalanceSheetTableHtml(),
      csvData: getBalanceSheetCsvData(),
      isWide: isBalanceSheetWide(),
      aiAnalysis: getBalanceSheetAiAnalysis()
    };
  } else if (view === "cashFlows") {
    return {
      title: "Statement of Cash Flows",
      subtitle: getCashFlowSubtitle(),
      tableHtml: getCashFlowTableHtml(),
      csvData: getCashFlowCsvData(),
      isWide: isCashFlowWide(),
      aiAnalysis: getCashFlowAiAnalysis()
    };
  } else if (view === "cashReports") {
    return {
      title: "Cash Balances",
      subtitle: getCashBalancesSubtitle(),
      tableHtml: getCashBalancesTableHtml(),
      csvData: getCashBalancesCsvData(),
      isWide: true
    };
  } else if (view === "cashReport") {
    return {
      title: "Cash Report",
      subtitle: "FTG Builders Cash Position",
      tableHtml: "",
      csvData: null,
      isWide: true
    };
  } else if (view === "jobOverview") {
    return {
      title: "Job Overview Report",
      subtitle: getJobOverviewSubtitle(),
      tableHtml: getJobOverviewTableHtml(),
      csvData: getJobOverviewCsvData(),
      isWide: true,
      captureCharts: captureJobOverviewCharts
    };
  } else if (view === "jobBudgets") {
    return {
      title: "Job Budgets Report",
      subtitle: getJobBudgetsSubtitle(),
      tableHtml: getJobBudgetsTableHtml(),
      csvData: getJobBudgetsCsvData(),
      isWide: true
    };
  } else if (view === "jobActuals") {
    return {
      title: "Job Actuals Report",
      subtitle: getJobActualsSubtitle(),
      tableHtml: getJobActualsTableHtml(),
      csvData: getJobActualsCsvData(),
      isWide: true
    };
  } else if (view === "overUnderBilling") {
    return {
      title: "Over/(Under) Billing Report",
      subtitle: getOverUnderBillingSubtitle(),
      tableHtml: getOverUnderBillingTableHtml(),
      csvData: getOverUnderBillingCsvData(),
      isWide: true
    };
  } else if (view === "costCodes") {
    return {
      title: "Cost Codes Report",
      subtitle: getCostCodesSubtitle(),
      tableHtml: getCostCodesTableHtml(),
      csvData: getCostCodesCsvData(),
      isWide: true
    };
  } else if (view === "missingBudgets") {
    return {
      title: "Missing Budgets Report",
      subtitle: getMissingBudgetsSubtitle(),
      tableHtml: getMissingBudgetsTableHtml(),
      csvData: getMissingBudgetsCsvData(),
      isWide: true
    };
  } else if (view === "payments") {
    return {
      title: "Payments Report",
      subtitle: getPaymentsSubtitle(),
      tableHtml: getPaymentsTableHtml(),
      csvData: getPaymentsCsvData(),
      isWide: true
    };
  } else if (view === "apAging") {
    return {
      title: "AP Aging Report",
      subtitle: getApAgingSubtitle(),
      tableHtml: getApAgingTableHtml(),
      csvData: getApAgingCsvData(),
      isWide: true
    };
  } else if (view === "arAging") {
    return {
      title: "AR Aging Report",
      subtitle: getArAgingSubtitle(),
      tableHtml: getArAgingTableHtml(),
      csvData: getArAgingCsvData(),
      isWide: true
    };
  } else if (view === "aiInsights") {
    return {
      title: "AI Financial Insights",
      subtitle: getAiInsightsSubtitle(),
      tableHtml: getAiInsightsTableHtml(),
      csvData: getAiInsightsCsvData(),
      isWide: true
    };
  } else if (view === "deptHeadMeeting") {
    return {
      title: "Dept Head Meeting Report",
      subtitle: getDeptHeadMeetingSubtitle(),
      tableHtml: getDeptHeadMeetingTableHtml(),
      csvData: getDeptHeadMeetingCsvData(),
      isWide: true
    };
  } else if (view === "monthEndReporting") {
    return {
      title: "Month End Report",
      subtitle: getMonthEndReportSubtitle(),
      tableHtml: getMonthEndReportTableHtml(),
      csvData: getMonthEndReportCsvData(),
      isWide: true
    };
  }
  return null;
}

function getOverviewSubtitle() {
  const viewType = document.getElementById("overviewViewType")?.value || "monthly";
  const year = document.getElementById("overviewYear")?.value || new Date().getFullYear();
  const compare = document.getElementById("overviewCompare")?.checked;
  let subtitle = `${viewType.charAt(0).toUpperCase() + viewType.slice(1)} View`;
  if (viewType !== "annual") subtitle += ` - ${year}`;
  if (compare) subtitle += " (vs Prior Year)";
  return subtitle;
}

function getOverviewTableHtml() {
  const viewType = document.getElementById("overviewViewType")?.value || "monthly";
  const year = parseInt(document.getElementById("overviewYear")?.value) || new Date().getFullYear();
  const compare = document.getElementById("overviewCompare")?.checked;
  
  if (!isAccountGroups) return "<p>No data available</p>";
  
  const groups = isAccountGroups.income_statement.groups;
  let labels = [];
  let periods = [];
  
  if (viewType === "monthly") {
    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    for (let m = 1; m <= 12; m++) {
      labels.push(monthNames[m - 1]);
      periods.push([`${year}-${String(m).padStart(2, "0")}`]);
    }
  } else if (viewType === "quarterly") {
    for (let q = 1; q <= 4; q++) {
      labels.push(`Q${q}`);
      const qMonths = [];
      for (let m = (q - 1) * 3 + 1; m <= q * 3; m++) {
        qMonths.push(`${year}-${String(m).padStart(2, "0")}`);
      }
      periods.push(qMonths);
    }
  } else {
    const start = parseInt(document.getElementById("overviewRangeStart")?.value) || 2018;
    const end = parseInt(document.getElementById("overviewRangeEnd")?.value) || 2025;
    for (let y = start; y <= end; y++) {
      labels.push(String(y));
      const yearMonths = [];
      for (let m = 1; m <= 12; m++) {
        yearMonths.push(`${y}-${String(m).padStart(2, "0")}`);
      }
      periods.push(yearMonths);
    }
  }
  
  const metrics = ["Revenue", "Gross Profit", "GP %", "Operating Expenses", "Operating Profit", "OP %"];
  
  let html = `<table><tr><th>Metric</th>${labels.map(l => `<th>${l}</th>`).join("")}</tr>`;
  
  metrics.forEach(metric => {
    html += `<tr><td><strong>${metric}</strong></td>`;
    periods.forEach(periodMonths => {
      const rows = buildIncomeStatementRows(periodMonths, groups);
      let value = 0;
      
      if (metric === "Revenue") {
        const row = rows.find(r => r.label === "Revenue");
        value = row ? row.value : 0;
      } else if (metric === "Gross Profit") {
        const row = rows.find(r => r.label === "Gross Profit");
        value = row ? row.value : 0;
      } else if (metric === "GP %") {
        const revRow = rows.find(r => r.label === "Revenue");
        const gpRow = rows.find(r => r.label === "Gross Profit");
        const rev = revRow ? revRow.value : 0;
        const gp = gpRow ? gpRow.value : 0;
        value = rev ? (gp / rev) * 100 : 0;
        html += `<td>${value.toFixed(1)}%</td>`;
        return;
      } else if (metric === "Operating Expenses") {
        const row = rows.find(r => r.label === "Operating Expenses");
        value = row ? row.value : 0;
      } else if (metric === "Operating Profit") {
        const row = rows.find(r => r.label === "Operating Income");
        value = row ? row.value : 0;
      } else if (metric === "OP %") {
        const revRow = rows.find(r => r.label === "Revenue");
        const opRow = rows.find(r => r.label === "Operating Income");
        const rev = revRow ? revRow.value : 0;
        const op = opRow ? opRow.value : 0;
        value = rev ? (op / rev) * 100 : 0;
        html += `<td>${value.toFixed(1)}%</td>`;
        return;
      }
      
      const formatted = Math.abs(value) >= 1000000 
        ? "$" + (value / 1000000).toFixed(1) + "M"
        : "$" + Math.round(value).toLocaleString();
      html += `<td>${formatted}</td>`;
    });
    html += "</tr>";
  });
  
  html += "</table>";
  return html;
}

function getOverviewCsvData() {
  const viewType = document.getElementById("overviewViewType")?.value || "monthly";
  const year = parseInt(document.getElementById("overviewYear")?.value) || new Date().getFullYear();
  
  if (!isAccountGroups) return "";
  
  const groups = isAccountGroups.income_statement.groups;
  let labels = [];
  let periods = [];
  
  if (viewType === "monthly") {
    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    for (let m = 1; m <= 12; m++) {
      labels.push(monthNames[m - 1]);
      periods.push([`${year}-${String(m).padStart(2, "0")}`]);
    }
  } else if (viewType === "quarterly") {
    for (let q = 1; q <= 4; q++) {
      labels.push(`Q${q}`);
      const qMonths = [];
      for (let m = (q - 1) * 3 + 1; m <= q * 3; m++) {
        qMonths.push(`${year}-${String(m).padStart(2, "0")}`);
      }
      periods.push(qMonths);
    }
  } else {
    const start = parseInt(document.getElementById("overviewRangeStart")?.value) || 2018;
    const end = parseInt(document.getElementById("overviewRangeEnd")?.value) || 2025;
    for (let y = start; y <= end; y++) {
      labels.push(String(y));
      const yearMonths = [];
      for (let m = 1; m <= 12; m++) {
        yearMonths.push(`${y}-${String(m).padStart(2, "0")}`);
      }
      periods.push(yearMonths);
    }
  }
  
  const metrics = ["Revenue", "Gross Profit", "GP %", "Operating Expenses", "Operating Profit", "OP %"];
  
  let csv = "Metric," + labels.join(",") + "\n";
  
  metrics.forEach(metric => {
    let row = metric;
    periods.forEach(periodMonths => {
      const rows = buildIncomeStatementRows(periodMonths, groups);
      let value = 0;
      
      if (metric === "Revenue") {
        const r = rows.find(r => r.label === "Revenue");
        value = r ? r.value : 0;
      } else if (metric === "Gross Profit") {
        const r = rows.find(r => r.label === "Gross Profit");
        value = r ? r.value : 0;
      } else if (metric === "GP %") {
        const revRow = rows.find(r => r.label === "Revenue");
        const gpRow = rows.find(r => r.label === "Gross Profit");
        const rev = revRow ? revRow.value : 0;
        const gp = gpRow ? gpRow.value : 0;
        value = rev ? (gp / rev) * 100 : 0;
        row += "," + value.toFixed(1) + "%";
        return;
      } else if (metric === "Operating Expenses") {
        const r = rows.find(r => r.label === "Operating Expenses");
        value = r ? r.value : 0;
      } else if (metric === "Operating Profit") {
        const r = rows.find(r => r.label === "Operating Income");
        value = r ? r.value : 0;
      } else if (metric === "OP %") {
        const revRow = rows.find(r => r.label === "Revenue");
        const opRow = rows.find(r => r.label === "Operating Income");
        const rev = revRow ? revRow.value : 0;
        const op = opRow ? opRow.value : 0;
        value = rev ? (op / rev) * 100 : 0;
        row += "," + value.toFixed(1) + "%";
        return;
      }
      
      row += "," + value;
    });
    csv += row + "\n";
  });
  
  return csv;
}

function getRevenueSubtitle() {
  const viewType = document.getElementById("revViewType")?.value || "monthly";
  const year = document.getElementById("revYear")?.value || new Date().getFullYear();
  return `${viewType.charAt(0).toUpperCase() + viewType.slice(1)} View - ${year}`;
}

function getRevenueTableHtml() {
  const table = document.getElementById("revTable");
  if (table && table.querySelector("tbody tr")) {
    return table.outerHTML;
  }
  
  const { labels, datasets } = currentTableData;
  if (!labels.length) return "<p>No data available</p>";
  
  let html = `<table><tr><th>Period</th>${datasets.map(ds => `<th>${ds.label}</th>`).join("")}</tr>`;
  labels.forEach((lbl, i) => {
    html += `<tr><td>${lbl}</td>`;
    datasets.forEach(ds => {
      const v = ds.data[i] || 0;
      html += `<td>$${v.toLocaleString()}</td>`;
    });
    html += "</tr>";
  });
  html += "</table>";
  return html;
}

function getRevenueCsvData() {
  const { labels, datasets } = currentTableData;
  if (!labels.length) return "";
  
  let csv = "Period," + datasets.map(ds => ds.label).join(",") + "\n";
  labels.forEach((lbl, i) => {
    let row = lbl;
    datasets.forEach(ds => {
      row += "," + (ds.data[i] || 0);
    });
    csv += row + "\n";
  });
  return csv;
}

function isRevenueWide() {
  const { datasets } = currentTableData;
  return datasets && datasets.length > 3;
}

function getAccountSubtitle() {
  const accountSelect = document.getElementById("acctSelect");
  const viewType = document.getElementById("acctViewType")?.value || "monthly";
  const accountName = accountSelect?.options[accountSelect.selectedIndex]?.text || "Account";
  return `${accountName} - ${viewType.charAt(0).toUpperCase() + viewType.slice(1)} View`;
}

function getAccountTableHtml() {
  const table = document.querySelector("#accounts .acct-table");
  if (!table) return "<p>No data available</p>";
  return table.outerHTML;
}

function getAccountCsvData() {
  const table = document.querySelector("#accounts .acct-table");
  if (!table) return "";
  
  let csv = "";
  const rows = table.querySelectorAll("tr");
  rows.forEach(row => {
    const cells = row.querySelectorAll("th, td");
    csv += Array.from(cells).map(c => `"${c.textContent.trim()}"`).join(",") + "\n";
  });
  return csv;
}

function isAccountWide() {
  const viewType = document.getElementById("acctViewType")?.value;
  return viewType === "annual";
}

function getIncomeStatementSubtitle() {
  const periodEl = document.getElementById("isReportPeriod");
  if (periodEl?.textContent) return periodEl.textContent;
  
  const periodType = document.getElementById("isPeriodType")?.value || "month";
  const viewMode = document.getElementById("isViewMode")?.value || "single";
  const compare = document.querySelector('input[name="isCompareRadio"]:checked')?.value || "none";
  
  let subtitle = `${periodType.charAt(0).toUpperCase() + periodType.slice(1)}`;
  if (viewMode === "matrix") subtitle += " - Matrix View";
  if (compare !== "none") subtitle += ` (vs ${compare === "prior_period" ? "Prior Period" : "Prior Year"})`;
  
  return subtitle;
}

function getIncomeStatementTableHtml() {
  const table = document.querySelector("#incomeStatement .is-table");
  if (!table) return "<p>No data available</p>";
  
  const clone = table.cloneNode(true);
  clone.querySelectorAll(".is-row-hidden").forEach(r => r.remove());
  clone.querySelectorAll(".is-spacer-row").forEach(r => r.remove());
  clone.querySelectorAll(".is-toggle").forEach(t => t.remove());
  
  return clone.outerHTML;
}

function getIncomeStatementCsvData() {
  const table = document.querySelector("#incomeStatement .is-table");
  if (!table) return "";
  
  let csv = "";
  const rows = table.querySelectorAll("tr:not(.is-row-hidden):not(.is-spacer-row)");
  rows.forEach(row => {
    const cells = row.querySelectorAll("th, td");
    csv += Array.from(cells).map(c => `"${c.textContent.trim()}"`).join(",") + "\n";
  });
  return csv;
}

function isIncomeStatementWide() {
  const viewMode = document.getElementById("isViewMode")?.value;
  return viewMode === "matrix";
}

function getBalanceSheetSubtitle() {
  const periodEl = document.getElementById("bsReportPeriod");
  if (periodEl?.textContent) return periodEl.textContent;
  
  const periodValue = document.getElementById("bsPeriodSelect")?.value || "";
  const compare = document.querySelector('input[name="bsCompareRadio"]:checked')?.value || "none";
  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  
  let subtitle = "As of ";
  if (periodValue) {
    const [y, mo] = periodValue.split("-");
    subtitle += `${monthNames[parseInt(mo) - 1]} ${y}`;
  }
  if (compare === "prior_year") subtitle += " (vs Prior Year)";
  
  return subtitle;
}

function getBalanceSheetTableHtml() {
  const table = document.querySelector("#balanceSheet .is-table");
  if (!table) return "<p>No data available</p>";
  
  const clone = table.cloneNode(true);
  clone.querySelectorAll(".is-row-hidden").forEach(r => r.remove());
  clone.querySelectorAll(".is-spacer-row").forEach(r => r.remove());
  clone.querySelectorAll(".bs-toggle").forEach(t => t.remove());
  
  return clone.outerHTML;
}

function getBalanceSheetCsvData() {
  const table = document.querySelector("#balanceSheet .is-table");
  if (!table) return "";
  
  let csv = "";
  const rows = table.querySelectorAll("tr:not(.is-row-hidden):not(.is-spacer-row)");
  rows.forEach(row => {
    const cells = row.querySelectorAll("th, td");
    csv += Array.from(cells).map(c => `"${c.textContent.trim()}"`).join(",") + "\n";
  });
  return csv;
}

function isBalanceSheetWide() {
  const viewMode = document.getElementById("bsViewMode")?.value;
  const compare = document.querySelector('input[name="bsCompareRadio"]:checked')?.value;
  return viewMode === "matrix" || compare !== "none";
}

function getBalanceSheetAiAnalysis() {
  return null;
}

function getCashFlowSubtitle() {
  const periodEl = document.getElementById("cfReportPeriod");
  return periodEl?.textContent || "";
}

function getCashFlowTableHtml() {
  const table = document.querySelector("#cashFlows .is-table");
  if (!table) return "<p>No data available</p>";
  
  const clone = table.cloneNode(true);
  clone.querySelectorAll(".is-row-hidden").forEach(r => r.remove());
  clone.querySelectorAll(".is-spacer-row").forEach(r => r.remove());
  clone.querySelectorAll(".cf-toggle").forEach(t => t.remove());
  
  return clone.outerHTML;
}

function getCashFlowCsvData() {
  const table = document.querySelector("#cashFlows .is-table");
  if (!table) return "";
  
  let csv = "";
  const rows = table.querySelectorAll("tr:not(.is-row-hidden):not(.is-spacer-row)");
  rows.forEach(row => {
    const cells = row.querySelectorAll("th, td");
    csv += Array.from(cells).map(c => `"${c.textContent.trim()}"`).join(",") + "\n";
  });
  return csv;
}

function isCashFlowWide() {
  const viewMode = document.getElementById("cfViewMode")?.value;
  const compare = document.querySelector('input[name="cfCompareRadio"]:checked')?.value;
  return viewMode === "matrix" || compare !== "none";
}

function getCashFlowAiAnalysis() {
  const panel = document.getElementById("cfAiAnalysisPanel");
  if (!panel || panel.classList.contains("collapsed")) return null;
  const content = document.getElementById("cfAiAnalysisContent");
  if (!content || !content.innerHTML.trim()) return null;
  return content.innerHTML;
}

function getCashBalancesSubtitle() {
  const rangeValue = document.getElementById("cashDaysRange")?.value || "30";
  const selectedCount = cashSelectedAccounts?.length || 0;
  const totalAccounts = cashData?.accounts?.length || 0;
  
  let rangeText = "";
  if (rangeValue === "custom") {
    const startDate = document.getElementById("cashStartDate")?.value;
    const endDate = document.getElementById("cashEndDate")?.value;
    if (startDate && endDate) {
      rangeText = `${formatDateForDisplay(startDate)} - ${formatDateForDisplay(endDate)}`;
    } else {
      rangeText = "Custom Range";
    }
  } else {
    rangeText = `Last ${rangeValue} Days`;
  }
  
  return `${rangeText} | ${selectedCount} of ${totalAccounts} accounts selected`;
}

function getCashBalancesTableHtml() {
  if (!cashData?.accounts || cashSelectedAccounts?.length === 0) {
    return "<p>No accounts selected</p>";
  }
  
  const selectedAccounts = cashData.accounts
    .filter(a => cashSelectedAccounts.includes(a.name))
    .sort((a, b) => b.balance - a.balance);
  
  const dates = getCashDateRange();
  const total = selectedAccounts.reduce((sum, a) => sum + a.balance, 0);
  
  let html = `<div style="margin-bottom:15px;"><strong>Current Total Balance: ${formatCurrency(total)}</strong></div>`;
  html += `<table><tr><th>Account</th><th style="text-align:right;">Current Balance</th></tr>`;
  
  selectedAccounts.forEach(acct => {
    html += `<tr><td>${acct.name}</td><td style="text-align:right;">${formatCurrency(acct.balance)}</td></tr>`;
  });
  
  html += `<tr style="font-weight:bold;border-top:2px solid #000;"><td>Total</td><td style="text-align:right;">${formatCurrency(total)}</td></tr>`;
  html += `</table>`;
  
  const dailyTableContainer = document.getElementById("dailyBalanceTableContainer");
  if (dailyTableContainer) {
    const dailyTable = dailyTableContainer.querySelector(".daily-balance-table");
    if (dailyTable) {
      const tableClone = dailyTable.cloneNode(true);
      tableClone.classList.add("expanded");
      html += `<h3 style="margin-top:25px;margin-bottom:10px;font-size:16px;color:#1f2937;">Daily Balances</h3>`;
      html += tableClone.outerHTML;
    }
  }
  
  const transactionContainer = document.getElementById("transactionTableContainer");
  if (transactionContainer) {
    const transactionTable = transactionContainer.querySelector(".transaction-table");
    if (transactionTable && transactionTable.querySelector("tbody tr")) {
      html += `<h3 style="margin-top:25px;margin-bottom:10px;font-size:16px;color:#1f2937;">Transactions</h3>`;
      html += transactionTable.outerHTML;
    }
  }
  
  return html;
}

function getCashBalancesCsvData() {
  if (!cashData?.accounts || cashSelectedAccounts?.length === 0) {
    return "";
  }
  
  const selectedAccounts = cashData.accounts
    .filter(a => cashSelectedAccounts.includes(a.name))
    .sort((a, b) => b.balance - a.balance);
  
  const dates = getCashDateRange();
  let csv = "Account,Current Balance\n";
  
  selectedAccounts.forEach(acct => {
    csv += `"${acct.name}",${acct.balance}\n`;
  });
  
  const total = selectedAccounts.reduce((sum, a) => sum + a.balance, 0);
  csv += `"TOTAL",${total}\n`;
  
  return csv;
}

function getJobBudgetsSubtitle() {
  const filters = [];
  const statusFilters = Array.from(document.querySelectorAll('.status-checkbox:checked')).map(cb => cb.value);
  if (statusFilters.length > 0 && statusFilters.length < 4) {
    filters.push(`Status: ${statusFilters.join(', ')}`);
  }
  const pm = document.getElementById('pmFilter')?.value;
  if (pm) filters.push(`PM: ${pm}`);
  const customer = document.getElementById('customerFilter')?.value;
  if (customer) filters.push(`Client: ${customer}`);
  
  const total = jobBudgetsFiltered?.length || 0;
  let subtitle = `${total} Job${total !== 1 ? 's' : ''}`;
  if (filters.length > 0) subtitle += ` | ${filters.join(' | ')}`;
  return subtitle;
}

function getJobBudgetsTableHtml() {
  if (!jobBudgetsFiltered || jobBudgetsFiltered.length === 0) {
    return "<p>No job data available</p>";
  }
  
  // Calculate totals first
  let totalContract = 0, totalCost = 0, totalProfit = 0;
  jobBudgetsFiltered.forEach(job => {
    totalContract += job.contract || 0;
    totalCost += job.revised_cost || 0;
    totalProfit += job.profit || 0;
  });
  const totalMargin = totalContract ? (totalProfit / totalContract) * 100 : 0;
  const totalProfitColor = totalProfit >= 0 ? '#10b981' : '#dc2626';
  
  // Summary metrics section
  const totalProfitColorClass = totalProfit >= 0 ? '#059669' : '#dc2626';
  let html = `<h3>Summary</h3>
    <table class="summary-table">
      <tr>
        <td>Total Jobs</td>
        <td>${jobBudgetsFiltered.length}</td>
      </tr>
      <tr>
        <td>Total Contract</td>
        <td>${formatCurrency(totalContract)}</td>
      </tr>
      <tr>
        <td>Total Cost</td>
        <td>${formatCurrency(totalCost)}</td>
      </tr>
      <tr>
        <td>Total Est. Profit</td>
        <td style="color:${totalProfitColorClass};">${formatCurrency(totalProfit)}</td>
      </tr>
      <tr>
        <td>Avg Margin</td>
        <td>${totalMargin.toFixed(1)}%</td>
      </tr>
    </table>`;
  
  // Top 10 jobs by contract value
  const topJobs = [...jobBudgetsFiltered]
    .sort((a, b) => (b.revised_contract || 0) - (a.revised_contract || 0))
    .slice(0, 10);
  
  html += `<h3>Top ${Math.min(10, jobBudgetsFiltered.length)} Jobs by Contract Value</h3>`;
  html += `<table>
    <thead>
      <tr>
        <th>Job #</th>
        <th>Description</th>
        <th>Client</th>
        <th style="text-align:right;">Contract</th>
        <th style="text-align:right;">Est. Profit</th>
        <th style="text-align:right;">Margin</th>
      </tr>
    </thead>
    <tbody>`;
  
  topJobs.forEach(job => {
    const margin = job.contract ? (job.profit / job.contract) * 100 : 0;
    const profitColor = job.profit >= 0 ? '#059669' : '#dc2626';
    const desc = (job.job_description || '').substring(0, 40) + ((job.job_description || '').length > 40 ? '...' : '');
    
    html += `<tr>
      <td>${job.job_no}</td>
      <td>${desc}</td>
      <td>${(job.customer_name || '').substring(0, 25)}</td>
      <td style="text-align:right;">${formatCurrency(job.contract)}</td>
      <td style="text-align:right;color:${profitColor};">${formatCurrency(job.profit)}</td>
      <td style="text-align:right;">${margin.toFixed(1)}%</td>
    </tr>`;
  });
  
  html += `</tbody></table>`;
  
  if (jobBudgetsFiltered.length > 10) {
    html += `<p style="margin-top:12px;font-size:11px;color:#6b7280;font-style:italic;">Showing top 10 of ${jobBudgetsFiltered.length} jobs. Use CSV or Excel export for complete data.</p>`;
  }
  
  return html;
}

function getJobBudgetsCsvData() {
  if (!jobBudgetsFiltered || jobBudgetsFiltered.length === 0) {
    return "";
  }
  
  let csv = "Job #,Description,Client,Status,Project Manager,Original Contract,Change Orders,Contract Value,Original Cost,Cost Adjustments,Projected Cost,Estimated Profit,Margin %\n";
  
  jobBudgetsFiltered.forEach(job => {
    const status = getJobStatusLabel(job.job_status);
    const margin = job.contract ? (job.profit / job.contract) * 100 : 0;
    
    csv += `"${job.job_no}","${(job.job_description || '').replace(/"/g, '""')}","${(job.customer_name || '').replace(/"/g, '""')}","${status.label}","${(job.project_manager_name || '').replace(/"/g, '""')}",${job.original_contract || 0},${job.tot_income_adj || 0},${job.contract || 0},${job.original_cost || 0},${job.tot_cost_adj || 0},${job.revised_cost || 0},${job.profit || 0},${margin.toFixed(1)}\n`;
  });
  
  return csv;
}

function getJobActualsSubtitle() {
  const filters = [];
  if (document.getElementById('jaStatusActive')?.checked) filters.push('Active');
  if (document.getElementById('jaStatusInactive')?.checked) filters.push('Inactive');
  if (document.getElementById('jaStatusClosed')?.checked) filters.push('Closed');
  if (document.getElementById('jaStatusOverhead')?.checked) filters.push('Overhead');
  
  const pm = document.getElementById('jaPmFilter')?.value;
  const customer = document.getElementById('jaCustomerFilter')?.value;
  
  const total = typeof jobActualsFiltered !== 'undefined' ? jobActualsFiltered.length : 0;
  let subtitle = `${total} Job${total !== 1 ? 's' : ''}`;
  if (filters.length > 0 && filters.length < 4) subtitle += ` | Status: ${filters.join(', ')}`;
  if (pm) subtitle += ` | PM: ${pm}`;
  if (customer) subtitle += ` | Client: ${customer}`;
  return subtitle;
}

function getJobActualsTableHtml() {
  if (typeof jobActualsFiltered === 'undefined' || jobActualsFiltered.length === 0) {
    return "<p>No job actuals data available</p>";
  }
  
  const totalBilled = jobActualsFiltered.reduce((sum, j) => sum + (j.billed_revenue || 0), 0);
  const totalEarned = jobActualsFiltered.reduce((sum, j) => sum + (j.earned_revenue || 0), 0);
  const totalCost = jobActualsFiltered.reduce((sum, j) => sum + (j.actual_cost || 0), 0);
  const overUnder = totalBilled - totalEarned;
  const avgComplete = jobActualsFiltered.length > 0 
    ? jobActualsFiltered.reduce((sum, j) => sum + (j.percent_complete || 0), 0) / jobActualsFiltered.length 
    : 0;
  const overUnderColor = overUnder >= 0 ? '#10b981' : '#dc2626';
  
  const overUnderColorStyle = overUnder >= 0 ? '#059669' : '#dc2626';
  let html = `<h3>Summary</h3>
    <table class="summary-table">
      <tr>
        <td>Total Jobs</td>
        <td>${jobActualsFiltered.length}</td>
      </tr>
      <tr>
        <td>Billed Revenue</td>
        <td>${formatCurrency(totalBilled)}</td>
      </tr>
      <tr>
        <td>Earned Revenue</td>
        <td>${formatCurrency(totalEarned)}</td>
      </tr>
      <tr>
        <td>Actual Cost</td>
        <td>${formatCurrency(totalCost)}</td>
      </tr>
      <tr>
        <td>Over/(Under) Bill</td>
        <td style="color:${overUnderColorStyle};">${formatCurrency(overUnder)}</td>
      </tr>
      <tr>
        <td>Avg % Complete</td>
        <td>${avgComplete.toFixed(1)}%</td>
      </tr>
    </table>`;
  
  const topJobs = [...jobActualsFiltered]
    .sort((a, b) => (b.earned_revenue || 0) - (a.earned_revenue || 0))
    .slice(0, 10);
  
  html += `<h3>Top ${Math.min(10, jobActualsFiltered.length)} Jobs by Earned Revenue</h3>`;
  html += `<table>
    <thead>
      <tr>
        <th>Job #</th>
        <th>Description</th>
        <th>Client</th>
        <th style="text-align:right;">Billed Rev</th>
        <th style="text-align:right;">Earned Rev</th>
        <th style="text-align:right;">Over/(Under)</th>
        <th style="text-align:right;">Actual Cost</th>
        <th style="text-align:right;">% Complete</th>
      </tr>
    </thead>
    <tbody>`;
  
  topJobs.forEach(job => {
    const overUnderJob = (job.billed_revenue || 0) - (job.earned_revenue || 0);
    const ouColor = overUnderJob >= 0 ? '#059669' : '#dc2626';
    const desc = (job.job_description || '').substring(0, 35) + ((job.job_description || '').length > 35 ? '...' : '');
    
    html += `<tr>
      <td>${job.job_no}</td>
      <td>${desc}</td>
      <td>${(job.customer_name || '').substring(0, 20)}</td>
      <td style="text-align:right;">${formatCurrency(job.billed_revenue || 0)}</td>
      <td style="text-align:right;">${formatCurrency(job.earned_revenue || 0)}</td>
      <td style="text-align:right;color:${ouColor};">${formatCurrency(overUnderJob)}</td>
      <td style="text-align:right;">${formatCurrency(job.actual_cost || 0)}</td>
      <td style="text-align:right;">${(job.percent_complete || 0).toFixed(0)}%</td>
    </tr>`;
  });
  
  html += `</tbody></table>`;
  
  if (jobActualsFiltered.length > 10) {
    html += `<p style="margin-top:12px;font-size:11px;color:#6b7280;font-style:italic;">Showing top 10 of ${jobActualsFiltered.length} jobs. Use CSV or Excel export for complete data.</p>`;
  }
  
  return html;
}

function getJobActualsCsvData() {
  if (typeof jobActualsFiltered === 'undefined' || jobActualsFiltered.length === 0) {
    return "";
  }
  
  let csv = "Job #,Description,Client,Status,Project Manager,Billed Revenue,Earned Revenue,Over/(Under) Bill,Actual Cost,% Complete\n";
  
  jobActualsFiltered.forEach(job => {
    const status = getJobStatusLabel(job.job_status);
    const overUnder = (job.billed_revenue || 0) - (job.earned_revenue || 0);
    
    csv += `"${job.job_no}","${(job.job_description || '').replace(/"/g, '""')}","${(job.customer_name || '').replace(/"/g, '""')}","${status.label}","${(job.project_manager_name || '').replace(/"/g, '""')}",${job.billed_revenue || 0},${job.earned_revenue || 0},${overUnder},${job.actual_cost || 0},${(job.percent_complete || 0).toFixed(1)}\n`;
  });
  
  return csv;
}

function getIncomeStatementAiAnalysis() {
  const panel = document.getElementById("isAiAnalysisPanel");
  if (!panel || panel.classList.contains("collapsed")) return null;
  const content = document.getElementById("isAiAnalysisContent");
  if (!content || !content.innerHTML.trim()) return null;
  return content.innerHTML;
}

// Over/(Under) Billing Export Helpers
function getOverUnderBillingSubtitle() {
  const statusActive = document.getElementById('oubStatusActive')?.checked;
  const statusInactive = document.getElementById('oubStatusInactive')?.checked;
  const statusClosed = document.getElementById('oubStatusClosed')?.checked;
  const pm = document.getElementById('oubPmFilter')?.value || 'All';
  
  let statuses = [];
  if (statusActive) statuses.push('Active');
  if (statusInactive) statuses.push('Inactive');
  if (statusClosed) statuses.push('Closed');
  
  let subtitle = statuses.length > 0 ? statuses.join(', ') + ' Jobs' : 'All Jobs';
  if (pm && pm !== 'All') subtitle += ` | PM: ${pm}`;
  return subtitle;
}

function getOverUnderBillingTableHtml() {
  if (typeof oubFiltered === 'undefined' || oubFiltered.length === 0) {
    return "<p>No data available</p>";
  }
  
  let html = `<table style="width:100%;border-collapse:collapse;font-size:10pt;">
    <thead>
      <tr style="background:#1e3a5f;color:#fff;">
        <th style="padding:8px;text-align:left;">Job #</th>
        <th style="padding:8px;text-align:left;">Description</th>
        <th style="padding:8px;text-align:left;">Customer</th>
        <th style="padding:8px;text-align:right;">Contract Value</th>
        <th style="padding:8px;text-align:right;">Est. Cost</th>
        <th style="padding:8px;text-align:right;">% Complete</th>
        <th style="padding:8px;text-align:right;">Earned Revenue</th>
        <th style="padding:8px;text-align:right;">Billed Revenue</th>
        <th style="padding:8px;text-align:right;">Over/(Under)</th>
      </tr>
    </thead>
    <tbody>`;
  
  const topJobs = oubFiltered.slice(0, 20);
  topJobs.forEach(job => {
    const overUnder = job.over_under || 0;
    const ouColor = overUnder >= 0 ? '#059669' : '#dc2626';
    const desc = (job.job_description || '').substring(0, 35) + ((job.job_description || '').length > 35 ? '...' : '');
    
    html += `<tr>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;">${job.job_no}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;">${desc}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;">${(job.customer_name || '').substring(0, 20)}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;text-align:right;">${formatCurrency(job.contract_value || 0)}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;text-align:right;">${formatCurrency(job.estimated_cost || 0)}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;text-align:right;">${(job.percent_complete || 0).toFixed(0)}%</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;text-align:right;">${formatCurrency(job.earned_revenue || 0)}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;text-align:right;">${formatCurrency(job.billed_revenue || 0)}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;text-align:right;color:${ouColor};">${formatCurrency(overUnder)}</td>
    </tr>`;
  });
  
  html += `</tbody></table>`;
  
  if (oubFiltered.length > 20) {
    html += `<p style="margin-top:12px;font-size:11px;color:#6b7280;font-style:italic;">Showing top 20 of ${oubFiltered.length} jobs. Use CSV or Excel export for complete data.</p>`;
  }
  
  return html;
}

function getOverUnderBillingCsvData() {
  if (typeof oubFiltered === 'undefined' || oubFiltered.length === 0) {
    return "";
  }
  
  let csv = "Job #,Description,Customer,Status,Project Manager,Contract Value,Est. Cost,% Complete,Earned Revenue,Billed Revenue,Over/(Under)\n";
  
  oubFiltered.forEach(job => {
    const status = getJobStatusLabel(job.job_status);
    const overUnder = job.over_under || 0;
    
    csv += `"${job.job_no}","${(job.job_description || '').replace(/"/g, '""')}","${(job.customer_name || '').replace(/"/g, '""')}","${status.label}","${(job.project_manager_name || '').replace(/"/g, '""')}",${job.contract_value || 0},${job.estimated_cost || 0},${(job.percent_complete || 0).toFixed(1)},${job.earned_revenue || 0},${job.billed_revenue || 0},${overUnder}\n`;
  });
  
  return csv;
}

// Cost Codes Export Helpers
function getCostCodesSubtitle() {
  const statusActive = document.getElementById('ccStatusActive')?.checked;
  const statusInactive = document.getElementById('ccStatusInactive')?.checked;
  const statusClosed = document.getElementById('ccStatusClosed')?.checked;
  // Use PM tabs selection
  const pm = getSelectedPmForPage('cc') || 'All';
  
  let statuses = [];
  if (statusActive) statuses.push('Active');
  if (statusInactive) statuses.push('Inactive');
  if (statusClosed) statuses.push('Closed');
  
  let subtitle = statuses.length > 0 ? statuses.join(', ') + ' Jobs' : 'All Jobs';
  if (pm && pm !== 'All') subtitle += ` | PM: ${pm}`;
  return subtitle;
}

function getCostCodesTableHtml() {
  if (typeof ccFilteredActualsCache === 'undefined' || ccFilteredActualsCache.length === 0) {
    return "<p>No data available</p>";
  }
  
  // Aggregate by cost code
  const costCodeMap = {};
  ccFilteredActualsCache.forEach(a => {
    const key = a.cost_code || 'Unknown';
    if (!costCodeMap[key]) {
      costCodeMap[key] = { cost_code: key, description: a.cost_code_description || '', total_cost: 0 };
    }
    costCodeMap[key].total_cost += parseFloat(a.actual_cost) || 0;
  });
  
  const costCodes = Object.values(costCodeMap).sort((a, b) => b.total_cost - a.total_cost);
  
  let html = `<table style="width:100%;border-collapse:collapse;font-size:10pt;">
    <thead>
      <tr style="background:#1e3a5f;color:#fff;">
        <th style="padding:8px;text-align:left;">Cost Code</th>
        <th style="padding:8px;text-align:left;">Description</th>
        <th style="padding:8px;text-align:right;">Total Cost</th>
      </tr>
    </thead>
    <tbody>`;
  
  const topCodes = costCodes.slice(0, 20);
  topCodes.forEach(cc => {
    html += `<tr>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;">${cc.cost_code}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;">${cc.description}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;text-align:right;">${formatCurrency(cc.total_cost)}</td>
    </tr>`;
  });
  
  html += `</tbody></table>`;
  
  if (costCodes.length > 20) {
    html += `<p style="margin-top:12px;font-size:11px;color:#6b7280;font-style:italic;">Showing top 20 of ${costCodes.length} cost codes. Use CSV or Excel export for complete data.</p>`;
  }
  
  return html;
}

function getCostCodesCsvData() {
  if (typeof ccFilteredActualsCache === 'undefined' || ccFilteredActualsCache.length === 0) {
    return "";
  }
  
  let csv = "Job #,Job Description,Cost Code,Cost Code Description,Total Cost\n";
  
  ccFilteredActualsCache.forEach(a => {
    csv += `"${a.job_no || ''}","${(a.job_description || '').replace(/"/g, '""')}","${a.cost_code || ''}","${(a.cost_code_description || '').replace(/"/g, '""')}",${parseFloat(a.actual_cost) || 0}\n`;
  });
  
  return csv;
}

// Missing Budgets Export Helpers
function getMissingBudgetsSubtitle() {
  const activeTab = document.querySelector('#missingBudgets .mb-tab.active');
  const tabName = activeTab?.dataset.tab === 'no-cost' ? 'No Estimated Cost' : 'No Contract Value';
  
  const statusActive = document.getElementById('mbStatusActive')?.checked;
  const statusInactive = document.getElementById('mbStatusInactive')?.checked;
  const statusClosed = document.getElementById('mbStatusClosed')?.checked;
  
  let statuses = [];
  if (statusActive) statuses.push('Active');
  if (statusInactive) statuses.push('Inactive');
  if (statusClosed) statuses.push('Closed');
  
  return `${tabName} | ${statuses.length > 0 ? statuses.join(', ') : 'All'} Jobs`;
}

function getMissingBudgetsTableHtml() {
  if (typeof missingBudgetsFiltered === 'undefined' || missingBudgetsFiltered.length === 0) {
    return "<p>No data available</p>";
  }
  
  let html = `<table style="width:100%;border-collapse:collapse;font-size:10pt;">
    <thead>
      <tr style="background:#1e3a5f;color:#fff;">
        <th style="padding:8px;text-align:left;">Job #</th>
        <th style="padding:8px;text-align:left;">Description</th>
        <th style="padding:8px;text-align:left;">Customer</th>
        <th style="padding:8px;text-align:left;">Status</th>
        <th style="padding:8px;text-align:left;">Project Manager</th>
        <th style="padding:8px;text-align:right;">Revised Contract</th>
        <th style="padding:8px;text-align:right;">Revised Cost</th>
      </tr>
    </thead>
    <tbody>`;
  
  const topJobs = missingBudgetsFiltered.slice(0, 20);
  topJobs.forEach(job => {
    const status = getJobStatusLabel(job.job_status);
    const desc = (job.job_description || '').substring(0, 35) + ((job.job_description || '').length > 35 ? '...' : '');
    
    html += `<tr>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;">${job.job_no}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;">${desc}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;">${(job.customer_name || '').substring(0, 20)}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;">${status.label}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;">${job.project_manager_name || ''}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;text-align:right;">${formatCurrency(job.contract || 0)}</td>
      <td style="padding:6px;border-bottom:1px solid #e5e7eb;text-align:right;">${formatCurrency(job.revised_cost || 0)}</td>
    </tr>`;
  });
  
  html += `</tbody></table>`;
  
  if (missingBudgetsFiltered.length > 20) {
    html += `<p style="margin-top:12px;font-size:11px;color:#6b7280;font-style:italic;">Showing top 20 of ${missingBudgetsFiltered.length} jobs. Use CSV or Excel export for complete data.</p>`;
  }
  
  return html;
}

function getMissingBudgetsCsvData() {
  if (typeof missingBudgetsFiltered === 'undefined' || missingBudgetsFiltered.length === 0) {
    return "";
  }
  
  let csv = "Job #,Description,Customer,Status,Project Manager,Revised Contract,Revised Cost\n";
  
  missingBudgetsFiltered.forEach(job => {
    const status = getJobStatusLabel(job.job_status);
    
    csv += `"${job.job_no}","${(job.job_description || '').replace(/"/g, '""')}","${(job.customer_name || '').replace(/"/g, '""')}","${status.label}","${(job.project_manager_name || '').replace(/"/g, '""')}",${job.contract || 0},${job.revised_cost || 0}\n`;
  });
  
  return csv;
}

// Payments Export Helpers
function getPaymentsSubtitle() {
  const dateFrom = document.getElementById('paymentsDateFrom')?.value || '';
  const dateTo = document.getElementById('paymentsDateTo')?.value || '';
  
  if (dateFrom && dateTo) {
    return `${dateFrom} to ${dateTo}`;
  } else if (dateFrom) {
    return `From ${dateFrom}`;
  } else if (dateTo) {
    return `Through ${dateTo}`;
  }
  return 'All Payments';
}

function getPaymentsTableHtml() {
  const tbody = document.getElementById('paymentsTableBody');
  if (!tbody || tbody.children.length === 0) {
    return "<p>No payment data available</p>";
  }
  
  const thead = document.getElementById('paymentsTableHead');
  let html = `<table style="width:100%;border-collapse:collapse;font-size:10pt;">`;
  
  if (thead) {
    html += `<thead><tr style="background:#1e3a5f;color:#fff;">`;
    thead.querySelectorAll('th').forEach(th => {
      if (!th.classList.contains('hidden')) {
        html += `<th style="padding:8px;text-align:left;">${th.textContent.trim()}</th>`;
      }
    });
    html += `</tr></thead>`;
  }
  
  html += `<tbody>`;
  Array.from(tbody.children).slice(0, 20).forEach(tr => {
    html += `<tr>`;
    tr.querySelectorAll('td').forEach(td => {
      if (!td.classList.contains('hidden')) {
        html += `<td style="padding:6px;border-bottom:1px solid #e5e7eb;">${td.textContent.trim()}</td>`;
      }
    });
    html += `</tr>`;
  });
  html += `</tbody></table>`;
  
  if (tbody.children.length > 20) {
    html += `<p style="margin-top:12px;font-size:11px;color:#6b7280;font-style:italic;">Showing top 20 of ${tbody.children.length} payments. Use CSV or Excel export for complete data.</p>`;
  }
  
  return html;
}

function getPaymentsCsvData() {
  const table = document.getElementById('paymentsTable');
  if (!table) return "";
  
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  if (!tbody || tbody.children.length === 0) return "";
  
  let csv = "";
  
  // Headers
  if (thead) {
    const headers = [];
    thead.querySelectorAll('th').forEach(th => {
      if (!th.classList.contains('hidden')) {
        headers.push(`"${th.textContent.trim().replace(/"/g, '""')}"`);
      }
    });
    csv += headers.join(',') + '\n';
  }
  
  // Data rows
  Array.from(tbody.children).forEach(tr => {
    const cells = [];
    tr.querySelectorAll('td').forEach(td => {
      if (!td.classList.contains('hidden')) {
        cells.push(`"${td.textContent.trim().replace(/"/g, '""')}"`);
      }
    });
    csv += cells.join(',') + '\n';
  });
  
  return csv;
}

// AP Aging Export Helpers
function getApAgingSubtitle() {
  const selectedPm = pmTabsState?.apa || '__ALL__';
  const pmLabel = (selectedPm === '__ALL__' || selectedPm === 'All Project Managers') ? 'All Project Managers' : selectedPm;
  const asOfDate = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  return pmLabel === 'All Project Managers' ? `As of ${asOfDate}` : `${pmLabel} - As of ${asOfDate}`;
}

function getApAgingTableHtml() {
  const tbody = document.querySelector('#apAging .aging-table tbody');
  if (!tbody || tbody.children.length === 0) {
    return "<p>No AP aging data available</p>";
  }
  
  const thead = document.querySelector('#apAging .aging-table thead');
  let html = `<table style="width:100%;border-collapse:collapse;font-size:10pt;">`;
  
  if (thead) {
    html += `<thead><tr style="background:#1e3a5f;color:#fff;">`;
    thead.querySelectorAll('th').forEach(th => {
      html += `<th style="padding:8px;text-align:left;">${th.textContent.trim()}</th>`;
    });
    html += `</tr></thead>`;
  }
  
  html += `<tbody>`;
  Array.from(tbody.children).slice(0, 30).forEach(tr => {
    html += `<tr>`;
    tr.querySelectorAll('td').forEach(td => {
      html += `<td style="padding:6px;border-bottom:1px solid #e5e7eb;">${td.textContent.trim()}</td>`;
    });
    html += `</tr>`;
  });
  html += `</tbody></table>`;
  
  if (tbody.children.length > 30) {
    html += `<p style="margin-top:12px;font-size:11px;color:#6b7280;font-style:italic;">Showing top 30 of ${tbody.children.length} vendors. Use CSV or Excel export for complete data.</p>`;
  }
  
  return html;
}

function getApAgingCsvData() {
  const table = document.querySelector('#apAging .aging-table');
  if (!table) return "";
  
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  if (!tbody || tbody.children.length === 0) return "";
  
  let csv = "";
  
  if (thead) {
    const headers = [];
    thead.querySelectorAll('th').forEach(th => {
      headers.push(`"${th.textContent.trim().replace(/"/g, '""')}"`);
    });
    csv += headers.join(',') + '\n';
  }
  
  Array.from(tbody.children).forEach(tr => {
    const cells = [];
    tr.querySelectorAll('td').forEach(td => {
      cells.push(`"${td.textContent.trim().replace(/"/g, '""')}"`);
    });
    csv += cells.join(',') + '\n';
  });
  
  return csv;
}

// AR Aging Export Helpers
function getArAgingSubtitle() {
  const selectedPm = pmTabsState?.ara || '__ALL__';
  const pmLabel = (selectedPm === '__ALL__' || selectedPm === 'All Project Managers') ? 'All Project Managers' : selectedPm;
  const asOfDate = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  return pmLabel === 'All Project Managers' ? `As of ${asOfDate}` : `${pmLabel} - As of ${asOfDate}`;
}

function getArAgingTableHtml() {
  const tbody = document.querySelector('#arAging .aging-table tbody');
  if (!tbody || tbody.children.length === 0) {
    return "<p>No AR aging data available</p>";
  }
  
  const thead = document.querySelector('#arAging .aging-table thead');
  let html = `<table style="width:100%;border-collapse:collapse;font-size:10pt;">`;
  
  if (thead) {
    html += `<thead><tr style="background:#1e3a5f;color:#fff;">`;
    thead.querySelectorAll('th').forEach(th => {
      html += `<th style="padding:8px;text-align:left;">${th.textContent.trim()}</th>`;
    });
    html += `</tr></thead>`;
  }
  
  html += `<tbody>`;
  Array.from(tbody.children).slice(0, 30).forEach(tr => {
    html += `<tr>`;
    tr.querySelectorAll('td').forEach(td => {
      html += `<td style="padding:6px;border-bottom:1px solid #e5e7eb;">${td.textContent.trim()}</td>`;
    });
    html += `</tr>`;
  });
  html += `</tbody></table>`;
  
  if (tbody.children.length > 30) {
    html += `<p style="margin-top:12px;font-size:11px;color:#6b7280;font-style:italic;">Showing top 30 of ${tbody.children.length} customers. Use CSV or Excel export for complete data.</p>`;
  }
  
  return html;
}

function getArAgingCsvData() {
  const table = document.querySelector('#arAging .aging-table');
  if (!table) return "";
  
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  if (!tbody || tbody.children.length === 0) return "";
  
  let csv = "";
  
  if (thead) {
    const headers = [];
    thead.querySelectorAll('th').forEach(th => {
      headers.push(`"${th.textContent.trim().replace(/"/g, '""')}"`);
    });
    csv += headers.join(',') + '\n';
  }
  
  Array.from(tbody.children).forEach(tr => {
    const cells = [];
    tr.querySelectorAll('td').forEach(td => {
      cells.push(`"${td.textContent.trim().replace(/"/g, '""')}"`);
    });
    csv += cells.join(',') + '\n';
  });
  
  return csv;
}

// AI Insights Export Helpers
function getAiInsightsSubtitle() {
  const asOfDate = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  return `Generated ${asOfDate}`;
}

function getAiInsightsTableHtml() {
  const contentEl = document.querySelector('#aiInsights .ai-insights-content');
  if (!contentEl || contentEl.textContent.trim() === '') {
    return "<p>No AI insights available. Please generate insights first.</p>";
  }
  return `<div class="ai-insights-export">${contentEl.innerHTML}</div>`;
}

function getAiInsightsCsvData() {
  const contentEl = document.querySelector('#aiInsights .ai-insights-content');
  if (!contentEl) return "";
  return contentEl.textContent.trim();
}

// Dept Head Meeting Export Helpers
function getDeptHeadMeetingSubtitle() {
  const asOfDate = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  return `As of ${asOfDate}`;
}

function getDeptHeadMeetingTableHtml() {
  const section = document.getElementById('deptHeadMeeting');
  if (!section) return "<p>No data available</p>";
  
  const content = section.querySelector('.section-content');
  if (content) {
    return content.innerHTML || "<p>Report content not yet available</p>";
  }
  return "<p>Report content not yet available</p>";
}

function getDeptHeadMeetingCsvData() {
  return "Dept Head Meeting Report - Export from page for full data";
}

// Month End Report Export Helpers
function getMonthEndReportSubtitle() {
  const asOfDate = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  return `As of ${asOfDate}`;
}

function getMonthEndReportTableHtml() {
  const section = document.getElementById('monthEndReporting');
  if (!section) return "<p>No data available</p>";
  
  const content = section.querySelector('.section-content');
  if (content) {
    return content.innerHTML || "<p>Report content not yet available</p>";
  }
  return "<p>Report content not yet available</p>";
}

function getMonthEndReportCsvData() {
  return "Month End Report - Export from page for full data";
}

function generateReportHtml(data, forEmail = false) {
  const orientation = data.isWide ? "landscape" : "portrait";
  const pageSize = data.isWide ? "11in 8.5in" : "8.5in 11in";
  
  const isFinancialStatement = ["Income Statement", "Balance Sheet", "Statement of Cash Flows"].includes(data.title);
  const isJobReport = data.title.includes("Job");
  
  let aiAnalysisHtml = "";
  if (data.aiAnalysis) {
    aiAnalysisHtml = `
      <div class="ai-analysis-section">
        <div class="ai-analysis-header">AI ANALYSIS</div>
        <div class="ai-analysis-content">${data.aiAnalysis}</div>
      </div>
    `;
  }
  
  let headerHtml;
  if (isFinancialStatement) {
    headerHtml = `
      <div class="report-header">
        <div class="report-company">FTG Builders</div>
        <div class="report-title">${data.title}</div>
        <div class="report-period">${data.subtitle}</div>
      </div>
    `;
  } else if (isJobReport) {
    headerHtml = `
      <div class="job-report-header">
        <div class="company-name">FTG Builders</div>
        <div class="report-title">${data.title}</div>
        <div class="report-subtitle">${data.subtitle}</div>
      </div>
    `;
  } else {
    headerHtml = `
      <div class="header">
        <div>
          <h1>FTG Builders - ${data.title}</h1>
          <h2>${data.subtitle}</h2>
        </div>
        <div class="logo-section">
        </div>
      </div>
    `;
  }
  
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>FTG Builders - ${data.title}</title>
      <style>
        @page { size: ${pageSize}; margin: 0.5in; }
        @media print {
          body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
          .no-print { display: none !important; }
        }
        * { box-sizing: border-box; }
        body { 
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
          padding: ${forEmail ? "0" : "0.5in"}; 
          margin: 0;
          font-size: 10pt;
          line-height: 1.5;
          color: #1f2937;
          background: ${forEmail ? "#ffffff" : "transparent"};
        }
        .header { 
          display: flex; 
          justify-content: space-between; 
          align-items: center; 
          border-bottom: 2px solid #1f2937; 
          padding-bottom: 10px; 
          margin-bottom: 15px; 
        }
        .header h1 { color: #1f2937; margin: 0; font-size: ${data.isWide ? "16pt" : "18pt"}; }
        .header h2 { color: #6b7280; margin: 5px 0 0 0; font-weight: normal; font-size: ${data.isWide ? "11pt" : "12pt"}; }
        .logo-section { text-align: right; }
        .logo-section img { height: 40px; }
        .report-header { text-align: center; margin-bottom: 20px; }
        .report-company { font-size: 16pt; font-weight: 600; color: #1f2937; margin-bottom: 4px; }
        .report-title { font-size: 14pt; font-weight: 500; color: #374151; margin-bottom: 4px; }
        .report-period { font-size: 11pt; color: #6b7280; }
        
        /* Job Report Header - Professional Look */
        .job-report-header {
          background: linear-gradient(135deg, #1e3a5f 0%, #2d5a87 100%);
          color: white;
          padding: 24px 28px;
          margin: ${forEmail ? "0" : "-0.5in -0.5in 20px -0.5in"};
          border-radius: ${forEmail ? "0" : "0"};
        }
        .job-report-header .company-name {
          font-size: 12pt;
          font-weight: 500;
          opacity: 0.9;
          margin-bottom: 6px;
          letter-spacing: 0.5px;
        }
        .job-report-header .report-title {
          font-size: 20pt;
          font-weight: 700;
          color: white;
          margin-bottom: 8px;
        }
        .job-report-header .report-subtitle {
          font-size: 11pt;
          opacity: 0.85;
          font-weight: 400;
        }
        
        .ai-analysis-section { 
          background: #f8fafc; 
          border: 1px solid #e2e8f0; 
          border-radius: 8px; 
          padding: 18px; 
          margin: 20px 0;
        }
        .ai-analysis-header { 
          font-weight: 600; 
          color: #1e3a5f; 
          margin-bottom: 12px; 
          font-size: 11pt;
          border-bottom: 2px solid #e2e8f0;
          padding-bottom: 10px;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }
        .ai-analysis-content { font-size: 10pt; line-height: 1.6; color: #374151; }
        .ai-analysis-content h4 { margin: 14px 0 8px 0; font-size: 11pt; color: #1e3a5f; }
        .ai-analysis-content ul { margin: 8px 0; padding-left: 22px; }
        .ai-analysis-content li { margin-bottom: 5px; }
        
        /* Content area */
        .content-area {
          padding: ${forEmail ? "24px 28px" : "0"};
        }
        
        /* Tables - Not 100% width for job reports */
        table { 
          border-collapse: collapse; 
          margin-top: 12px;
          font-size: 10pt;
        }
        ${isJobReport ? '' : 'table { width: 100%; }'}
        
        th, td { 
          border: 1px solid #e2e8f0; 
          padding: 10px 14px; 
          text-align: left;
        }
        th { 
          background: #f1f5f9; 
          font-weight: 600; 
          color: #1e3a5f;
          white-space: nowrap;
        }
        tbody tr:nth-child(even) { background: #f8fafc; }
        tbody tr:hover { background: #f1f5f9; }
        
        .is-major-total td, .is-major-total th { 
          background: #e2e8f0; 
          font-weight: bold; 
        }
        
        /* Section headers in job reports */
        h3 { 
          color: #1e3a5f; 
          font-size: 13pt; 
          margin: 24px 0 14px 0; 
          font-weight: 600;
          border-bottom: 2px solid #e2e8f0;
          padding-bottom: 8px;
        }
        h3:first-child { margin-top: 0; }
        
        /* Summary tables in job reports */
        .summary-table { margin-bottom: 24px; }
        .summary-table td { border: none; padding: 6px 0; }
        .summary-table td:first-child { 
          color: #64748b; 
          padding-right: 24px; 
          font-weight: 500;
        }
        .summary-table td:last-child { font-weight: 600; }
        
        /* Footer */
        .footer { 
          margin-top: 30px; 
          padding: 16px 0; 
          border-top: 2px solid #e2e8f0; 
          color: #94a3b8; 
          font-size: 9pt; 
          display: flex; 
          justify-content: space-between; 
        }
        
        /* Number formatting */
        .number-col { text-align: right; font-variant-numeric: tabular-nums; }
        .positive { color: #059669; }
        .negative { color: #dc2626; }
      </style>
    </head>
    <body>
      ${headerHtml}
      <div class="content-area">
        ${aiAnalysisHtml}
        ${data.tableHtml}
      </div>
      <div class="footer">
        <span>Generated on ${new Date().toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' })} at ${new Date().toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}</span>
        <span>FTG Dashboard</span>
      </div>
    </body>
    </html>
  `;
}

function universalPrint() {
  window.print();
}

async function universalExportToPdf() {
  const viewId = getCurrentView();
  const section = document.getElementById(viewId);
  
  if (!section) {
    alert("Could not find section: " + viewId);
    return;
  }
  
  console.log('[PDF] Exporting view:', viewId);
  
  const filename = `ftg_${viewId}_${new Date().toISOString().split("T")[0]}.pdf`;
  
  // Show loading overlay
  const loadingOverlay = document.createElement('div');
  loadingOverlay.id = 'pdfLoadingOverlay';
  loadingOverlay.innerHTML = '<div style="background:#fff;padding:30px 50px;border-radius:12px;text-align:center;font-size:16px;color:#1f2937;box-shadow:0 4px 20px rgba(0,0,0,0.3);"><div class="ai-spinner"></div><div>Generating PDF...</div></div>';
  loadingOverlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:100000;';
  document.body.appendChild(loadingOverlay);
  
  // Hide elements that shouldn't be in PDF from the original section
  const hideSelectors = '.config-panel, .config-header, .ai-run-btn, .export-bar, .saved-views-row, .chart-expand-btn, .page-chart-expand-btn, .loading-overlay:not(#pdfLoadingOverlay), .loading-spinner, .skeleton, .table-export-btn-row, .ai-analysis-section, .ai-button-container';
  const hiddenEls = [];
  section.querySelectorAll(hideSelectors).forEach(el => {
    if (el.style.display !== 'none') {
      hiddenEls.push({ el, display: el.style.display });
      el.style.display = 'none';
    }
  });
  
  // Add pdf-export-mode class to body for CSS overrides that kill pseudo-elements
  document.body.classList.add('pdf-export-mode');
  
  try {
    await LazyLoader.loadMultiple(['html2canvas', 'jspdf']);
    await new Promise(r => setTimeout(r, 150));
    
    // Create a clean container for PDF export with forced desktop width
    const pdfContainer = document.createElement('div');
    const desktopWidth = Math.max(1200, section.scrollWidth);
    pdfContainer.style.cssText = 'position:absolute;left:-9999px;top:0;background:#fff;width:' + desktopWidth + 'px;min-width:1200px;';
    document.body.appendChild(pdfContainer);
    
    // Clone the section
    const cleanClone = section.cloneNode(true);
    cleanClone.style.width = desktopWidth + 'px';
    cleanClone.style.minWidth = '1200px';
    cleanClone.style.maxWidth = 'none';
    // CRITICAL: Force visibility on clone - the original has opacity:0 from CSS animation
    cleanClone.style.display = 'block';
    cleanClone.style.opacity = '1';
    cleanClone.style.transform = 'none';
    cleanClone.style.visibility = 'visible';
    cleanClone.style.animation = 'none';
    pdfContainer.appendChild(cleanClone);
    
    // Force solid backgrounds on all elements in the clone - removes glassmorphism haze
    const allElements = cleanClone.querySelectorAll('*');
    allElements.forEach(el => {
      const style = el.style;
      style.backdropFilter = 'none';
      style.webkitBackdropFilter = 'none';
      style.filter = 'none';
      // Force visibility on all elements in case they have opacity: 0 or are hidden
      style.opacity = '1';
      style.visibility = 'visible';
      
      // Check if element has translucent background
      const computed = window.getComputedStyle(el);
      const bg = computed.backgroundColor;
      if (bg && bg.includes('rgba')) {
        style.backgroundColor = '#ffffff';
      }
      // Force backgrounds for common glass elements
      if (el.classList.contains('summary-card') || 
          el.classList.contains('metric-tile') ||
          el.classList.contains('chart-card') ||
          el.classList.contains('pm-tab-btn') ||
          el.classList.contains('glass-panel') ||
          el.classList.contains('overview-tile') ||
          el.classList.contains('glass-card') ||
          el.classList.contains('welcome-card') ||
          el.classList.contains('config-panel') ||
          el.classList.contains('chart-wrapper') ||
          el.classList.contains('ap-aging-summary') ||
          el.classList.contains('ar-aging-summary')) {
        style.backgroundColor = '#ffffff';
        style.backgroundImage = 'none';
      }
    });
    
    // Set solid background on the clone itself
    cleanClone.style.backgroundColor = '#ffffff';
    cleanClone.style.backgroundImage = 'none';
    
    // Copy canvas elements (charts) as images
    const originalCanvases = section.querySelectorAll('canvas');
    const clonedCanvases = cleanClone.querySelectorAll('canvas');
    originalCanvases.forEach((origCanvas, idx) => {
      if (clonedCanvases[idx]) {
        try {
          const dataUrl = origCanvas.toDataURL();
          const img = document.createElement('img');
          img.src = dataUrl;
          img.style.cssText = origCanvas.style.cssText;
          img.style.width = origCanvas.offsetWidth + 'px';
          img.style.height = origCanvas.offsetHeight + 'px';
          clonedCanvases[idx].parentNode.replaceChild(img, clonedCanvases[idx]);
        } catch (e) {
          console.log('Could not convert canvas to image:', e);
        }
      }
    });
    
    // Capture the clean clone
    const canvas = await html2canvas(cleanClone, {
      scale: 1.5,
      useCORS: true,
      allowTaint: true,
      backgroundColor: '#ffffff',
      logging: false,
      windowWidth: Math.max(1200, cleanClone.scrollWidth),
      windowHeight: cleanClone.scrollHeight,
      ignoreElements: (el) => {
        return el.classList && (
          el.classList.contains('loading-overlay') ||
          el.classList.contains('loading-spinner') ||
          el.id?.includes('Loading')
        );
      }
    });
    
    // Generate PDF
    const imgData = canvas.toDataURL('image/png');
    const imgWidth = canvas.width;
    const imgHeight = canvas.height;
    
    const isLandscape = imgWidth > imgHeight * 1.2;
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
      orientation: isLandscape ? 'landscape' : 'portrait',
      unit: 'px',
      format: [imgWidth / 1.5 + 40, imgHeight / 1.5 + 80]
    });
    
    pdf.setFontSize(10);
    pdf.setTextColor(100);
    pdf.text('FTG Builders Dashboard', 20, 20);
    pdf.text(new Date().toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' }), pdf.internal.pageSize.getWidth() - 20, 20, { align: 'right' });
    pdf.addImage(imgData, 'PNG', 20, 40, imgWidth / 1.5, imgHeight / 1.5);
    pdf.save(filename);
    
  } catch (err) {
    console.error('PDF export error:', err);
    alert('PDF export failed: ' + err.message);
  } finally {
    // Remove pdf-export-mode class from body
    document.body.classList.remove('pdf-export-mode');
    
    // Clean up PDF container if it exists
    const pdfCont = document.querySelector('div[style*="left:-9999px"]');
    if (pdfCont) pdfCont.remove();
    
    // Restore hidden elements
    hiddenEls.forEach(({ el, display }) => {
      el.style.display = display || '';
    });
    
    loadingOverlay.remove();
  }
}

function universalExportToCsv() {
  const data = getReportData();
  if (!data) return alert("Please navigate to a supported report view to export CSV.");
  
  const view = getCurrentView();
  const filename = `ftg_${view}_${new Date().toISOString().split("T")[0]}.csv`;
  
  const blob = new Blob([data.csvData], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

async function universalExportToExcel() {
  const data = getReportData();
  if (!data) return alert("Please navigate to a report view to export to Excel.");
  
  try {
    await LazyLoader.load('exceljs');
  } catch (err) {
    return alert("Failed to load Excel library. Please check your internet connection.");
  }
  
  const view = getCurrentView();
  const filename = `ftg_${view}_${new Date().toISOString().split("T")[0]}.xlsx`;
  
  const tableSelectors = {
    "revenue": "#revTable",
    "accounts": "#accounts .acct-table",
    "incomeStatement": "#incomeStatement .is-table",
    "balanceSheet": "#balanceSheet .bs-table",
    "cashFlows": "#cashFlowTable",
    "cashReports": ".daily-balance-table",
    "jobBudgets": "#jobBudgetsTable",
    "jobActuals": "#jobActualsTable",
    "overUnderBilling": "#oubTable",
    "costCodes": "#costCodesTable",
    "missingBudgets": "#missingBudgetsTable",
    "payments": "#paymentsTable",
    "apAging": "#apAging .aging-table",
    "arAging": "#arAging .aging-table"
  };
  
  let rows = [];
  let headerRowCount = 1;
  const tableSelector = tableSelectors[view];
  
  if (tableSelector) {
    const tableEl = document.querySelector(tableSelector);
    if (tableEl) {
      const headerRows = tableEl.querySelectorAll("thead tr");
      const bodyRows = tableEl.querySelectorAll("tbody tr");
      headerRowCount = headerRows.length || 1;
      
      headerRows.forEach(tr => {
        const cells = [];
        tr.querySelectorAll("th").forEach(th => cells.push(th.textContent.trim()));
        if (cells.length > 0) rows.push({ cells, isHeader: true });
      });
      
      bodyRows.forEach(tr => {
        const cells = [];
        const isGroupHeader = tr.classList.contains("is-group-header") || 
                              tr.classList.contains("bs-group-header") ||
                              tr.classList.contains("cf-group-header");
        const isTotalRow = tr.classList.contains("is-total") || 
                           tr.classList.contains("bs-total") ||
                           tr.classList.contains("cf-total") ||
                           tr.classList.contains("grand-total");
        tr.querySelectorAll("td").forEach(td => cells.push(td.textContent.trim()));
        if (cells.length > 0) rows.push({ cells, isHeader: false, isGroupHeader, isTotalRow });
      });
    }
  }
  
  if (rows.length === 0) {
    const csvRows = data.csvData.split("\n").map(row => {
      const result = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0; i < row.length; i++) {
        const char = row[i];
        if (char === '"') inQuotes = !inQuotes;
        else if (char === "," && !inQuotes) { result.push(current.trim()); current = ""; }
        else current += char;
      }
      result.push(current.trim());
      return result;
    }).filter(r => r.length > 0 && r.some(c => c !== ""));
    
    rows = csvRows.map((cells, idx) => ({ cells, isHeader: idx === 0 }));
  }
  
  if (rows.length === 0) return alert("No data to export.");
  
  const workbook = new ExcelJS.Workbook();
  workbook.creator = "FTG Dashboard";
  workbook.created = new Date();
  
  const sheetName = data.title.substring(0, 31);
  const worksheet = workbook.addWorksheet(sheetName);
  
  const headerFill = { type: "pattern", pattern: "solid", fgColor: { argb: "FF1F2937" } };
  const headerFont = { bold: true, color: { argb: "FFFFFFFF" }, size: 11 };
  const groupHeaderFill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFE5E7EB" } };
  const groupHeaderFont = { bold: true, color: { argb: "FF374151" }, size: 11 };
  const totalFill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFF3F4F6" } };
  const totalFont = { bold: true, color: { argb: "FF111827" }, size: 11 };
  const borderStyle = { style: "thin", color: { argb: "FFD1D5DB" } };
  const allBorders = { top: borderStyle, left: borderStyle, bottom: borderStyle, right: borderStyle };
  
  const currencyColumns = new Set();
  rows.forEach((row, idx) => {
    if (row.isHeader) return;
    row.cells.forEach((cell, colIdx) => {
      if (cell.includes("$")) currencyColumns.add(colIdx);
    });
  });
  
  rows.forEach((row, rowIdx) => {
    const excelRow = worksheet.addRow(row.cells.map((cell, colIdx) => {
      if (row.isHeader) return cell;
      const cleanValue = cell.replace(/[$,]/g, "").replace(/\(([^)]+)\)/g, "-$1");
      const numValue = parseFloat(cleanValue);
      if (!isNaN(numValue) && cleanValue !== "" && !cell.includes("%")) return numValue;
      return cell;
    }));
    
    excelRow.eachCell({ includeEmpty: true }, (cell, colNumber) => {
      cell.border = allBorders;
      cell.alignment = { vertical: "middle" };
      
      if (row.isHeader) {
        cell.fill = headerFill;
        cell.font = headerFont;
        cell.alignment = { horizontal: "center", vertical: "middle" };
      } else if (row.isGroupHeader) {
        cell.fill = groupHeaderFill;
        cell.font = groupHeaderFont;
      } else if (row.isTotalRow) {
        cell.fill = totalFill;
        cell.font = totalFont;
      }
      
      if (!row.isHeader && currencyColumns.has(colNumber - 1) && typeof cell.value === "number") {
        cell.numFmt = '"$"#,##0';
        cell.alignment = { horizontal: "right", vertical: "middle" };
      }
    });
  });
  
  const colCount = rows[0]?.cells.length || 0;
  for (let i = 1; i <= colCount; i++) {
    let maxWidth = 12;
    worksheet.getColumn(i).eachCell({ includeEmpty: false }, cell => {
      const len = String(cell.value || "").length;
      maxWidth = Math.max(maxWidth, len + 2);
    });
    worksheet.getColumn(i).width = Math.min(maxWidth, 45);
  }
  
  worksheet.views = [{ state: "frozen", ySplit: headerRowCount }];
  
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function openEmailModal() {
  const view = getCurrentView();
  console.log('[Email] getCurrentView returned:', view);
  console.log('[Email] arAging visible:', document.getElementById('arAging')?.classList.contains('visible'));
  
  // Special handling for AP Aging - use embedded HTML email
  if (view === 'apAging') {
    showAgingEmailModal('ap');
    return;
  }
  
  // Special handling for AR Aging - use embedded HTML email
  if (view === 'arAging') {
    showAgingEmailModal('ar');
    return;
  }
  
  // Special handling for Cash Report
  if (view === 'cashReport') {
    const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    setElValue("emailSubject", `FTG Builders Weekly Cash Report: ${dateStr}`);
    setElValue("emailTo", "");
    setElText("emailStatus", "");
    const modal = getEl("emailModal");
    if (modal) modal.classList.remove("hidden");
    return;
  }
  
  const data = getReportData();
  if (!data) return alert("Please navigate to a supported report view to send email.");
  
  const dateStr = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  setElValue("emailSubject", `FTG Dashboard - ${data.title} - ${dateStr}`);
  setElValue("emailTo", "");
  setElText("emailStatus", "");
  const modal = getEl("emailModal");
  if (modal) modal.classList.remove("hidden");
}

function closeEmailModal() {
  const modal = getEl("emailModal");
  if (modal) modal.classList.add("hidden");
}
// Add email recipient from quick button
function addEmailRecipient(email) {
  const emailInput = document.getElementById('emailTo');
  if (!emailInput) return;
  
  const currentValue = emailInput.value.trim();
  const existingEmails = currentValue ? currentValue.split(',').map(e => e.trim().toLowerCase()) : [];
  
  // Check if email already exists
  if (existingEmails.includes(email.toLowerCase())) {
    // Remove it (toggle behavior)
    const newEmails = existingEmails.filter(e => e !== email.toLowerCase());
    emailInput.value = newEmails.join(', ');
    // Update button state
    updateQuickRecipientButtons();
    return;
  }
  
  // Add the email
  if (currentValue) {
    emailInput.value = currentValue + ', ' + email;
  } else {
    emailInput.value = email;
  }
  
  // Update button state
  updateQuickRecipientButtons();
}

// Update quick recipient button active states
function updateQuickRecipientButtons() {
  const emailInput = document.getElementById('emailTo');
  if (!emailInput) return;
  
  const currentEmails = emailInput.value.split(',').map(e => e.trim().toLowerCase());
  const buttons = document.querySelectorAll('.quick-recipient-btn');
  
  buttons.forEach(btn => {
    const btnEmail = btn.getAttribute('onclick').match(/'([^']+)'/)?.[1]?.toLowerCase();
    if (btnEmail && currentEmails.includes(btnEmail)) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });
}

// Expose functions to global scope for inline onclick handlers
window.addEmailRecipient = addEmailRecipient;
window.updateQuickRecipientButtons = updateQuickRecipientButtons;

// EmailJS Configuration
const EMAILJS_CONFIG = {
  publicKey: "g7M4wCTIOOn2D65le",
  serviceId: "service_x8zz5uy",
  templateId: "template_44g2s84"
};

async function captureRevenueAsImage() {
  try {
    if (!revChartInstance) {
      console.log("No revenue chart instance");
      return null;
    }
    
    // Get chart image
    const base64 = revChartInstance.toBase64Image("image/png", 1);
    
    // Load as image
    const img = await new Promise((resolve) => {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = () => resolve(null);
      image.src = base64;
    });
    
    if (!img) return null;
    
    // Get stats from the page
    const stats = {
      avg: document.getElementById("revAvgValue")?.textContent || "-",
      max: document.getElementById("revMaxValue")?.textContent || "-",
      maxPeriod: document.getElementById("revMaxPeriod")?.textContent || "",
      min: document.getElementById("revMinValue")?.textContent || "-",
      minPeriod: document.getElementById("revMinPeriod")?.textContent || "",
      cagr: document.getElementById("revCagrValue")?.textContent || "-"
    };
    
    // Get title info
    const title1 = document.getElementById("revChartTitleLine1")?.textContent || "Revenue";
    const title2 = document.getElementById("revChartTitleLine2")?.textContent || "";
    
    // Create composite canvas
    const chartWidth = img.width;
    const chartHeight = img.height;
    const headerHeight = 60;
    const statsHeight = 80;
    const padding = 20;
    
    const canvas = document.createElement("canvas");
    canvas.width = chartWidth + padding * 2;
    canvas.height = headerHeight + chartHeight + statsHeight + padding * 2;
    const ctx = canvas.getContext("2d");
    
    // Background
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Title
    ctx.fillStyle = "#1f2937";
    ctx.font = "bold 18px Arial";
    ctx.textAlign = "center";
    ctx.fillText(title1, canvas.width / 2, padding + 25);
    ctx.font = "14px Arial";
    ctx.fillStyle = "#6b7280";
    ctx.fillText(title2, canvas.width / 2, padding + 45);
    
    // Chart
    ctx.drawImage(img, padding, headerHeight + padding, chartWidth, chartHeight);
    
    // Stats row
    const statsY = headerHeight + chartHeight + padding + 20;
    const statLabels = ["AVERAGE", "HIGHEST", "LOWEST", "CAGR"];
    const statValues = [stats.avg, stats.max, stats.min, stats.cagr];
    const statWidth = chartWidth / 4;
    
    ctx.font = "bold 10px Arial";
    ctx.textAlign = "center";
    
    for (let i = 0; i < 4; i++) {
      const x = padding + i * statWidth + statWidth / 2;
      ctx.fillStyle = "#6b7280";
      ctx.fillText(statLabels[i], x, statsY);
      ctx.fillStyle = "#1f2937";
      ctx.font = "bold 14px Arial";
      ctx.fillText(statValues[i], x, statsY + 20);
      ctx.font = "bold 10px Arial";
    }
    
    const dataUrl = canvas.toDataURL("image/jpeg", 0.9);
    return dataUrl.split(",")[1];
  } catch (err) {
    console.error("Revenue capture error:", err);
    return null;
  }
}

async function captureAccountAsImage() {
  try {
    if (!acctChartInstance) {
      console.log("No account chart instance");
      return null;
    }
    
    // Get chart image
    const base64 = acctChartInstance.toBase64Image("image/png", 1);
    
    // Load as image
    const img = await new Promise((resolve) => {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = () => resolve(null);
      image.src = base64;
    });
    
    if (!img) return null;
    
    // Get stats from the page
    const stats = {
      avg: document.getElementById("acctAvgValue")?.textContent || "-",
      max: document.getElementById("acctMaxValue")?.textContent || "-",
      maxPeriod: document.getElementById("acctMaxPeriod")?.textContent || "",
      min: document.getElementById("acctMinValue")?.textContent || "-",
      minPeriod: document.getElementById("acctMinPeriod")?.textContent || "",
      cagr: document.getElementById("acctCagrValue")?.textContent || "-"
    };
    
    // Get title info
    const title1 = document.getElementById("acctChartTitleLine1")?.textContent || "Account Detail";
    const title2 = document.getElementById("acctChartTitleLine2")?.textContent || "";
    
    // Create composite canvas
    const chartWidth = img.width;
    const chartHeight = img.height;
    const headerHeight = 60;
    const statsHeight = 80;
    const padding = 20;
    
    const canvas = document.createElement("canvas");
    canvas.width = chartWidth + padding * 2;
    canvas.height = headerHeight + chartHeight + statsHeight + padding * 2;
    const ctx = canvas.getContext("2d");
    
    // Background
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Title
    ctx.fillStyle = "#1f2937";
    ctx.font = "bold 18px Arial";
    ctx.textAlign = "center";
    ctx.fillText(title1, canvas.width / 2, padding + 25);
    ctx.font = "14px Arial";
    ctx.fillStyle = "#6b7280";
    ctx.fillText(title2, canvas.width / 2, padding + 45);
    
    // Chart
    ctx.drawImage(img, padding, headerHeight + padding, chartWidth, chartHeight);
    
    // Stats row
    const statsY = headerHeight + chartHeight + padding + 20;
    const statLabels = ["AVERAGE", "HIGHEST", "LOWEST", "CAGR"];
    const statValues = [stats.avg, stats.max, stats.min, stats.cagr];
    const statWidth = chartWidth / 4;
    
    ctx.font = "bold 10px Arial";
    ctx.textAlign = "center";
    
    for (let i = 0; i < 4; i++) {
      const x = padding + i * statWidth + statWidth / 2;
      ctx.fillStyle = "#6b7280";
      ctx.fillText(statLabels[i], x, statsY);
      ctx.fillStyle = "#1f2937";
      ctx.font = "bold 14px Arial";
      ctx.fillText(statValues[i], x, statsY + 20);
      ctx.font = "bold 10px Arial";
    }
    
    const dataUrl = canvas.toDataURL("image/jpeg", 0.9);
    return dataUrl.split(",")[1];
  } catch (err) {
    console.error("Account capture error:", err);
    return null;
  }
}

async function captureCashAsImage() {
  try {
    if (!cashChartInstance) {
      console.log("No cash chart instance");
      return null;
    }
    
    // Get chart image
    const base64 = cashChartInstance.toBase64Image("image/png", 1);
    
    // Load as image
    const img = await new Promise((resolve) => {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = () => resolve(null);
      image.src = base64;
    });
    
    if (!img) return null;
    
    // Get stats from the page
    const stats = {
      avg: document.getElementById("cashAvgValue")?.textContent || "-",
      max: document.getElementById("cashMaxValue")?.textContent || "-",
      min: document.getElementById("cashMinValue")?.textContent || "-",
      growth: document.getElementById("cashGrowthValue")?.textContent || "-"
    };
    
    // Get title info
    const title1 = "Cash Balances";
    const periodSelect = document.getElementById("cashPeriodType");
    const title2 = periodSelect ? periodSelect.options[periodSelect.selectedIndex]?.text || "" : "";
    
    // Create composite canvas
    const chartWidth = img.width;
    const chartHeight = img.height;
    const headerHeight = 60;
    const statsHeight = 80;
    const padding = 20;
    
    const canvas = document.createElement("canvas");
    canvas.width = chartWidth + padding * 2;
    canvas.height = headerHeight + chartHeight + statsHeight + padding * 2;
    const ctx = canvas.getContext("2d");
    
    // Background
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Title
    ctx.fillStyle = "#1f2937";
    ctx.font = "bold 18px Arial";
    ctx.textAlign = "center";
    ctx.fillText(title1, canvas.width / 2, padding + 25);
    ctx.font = "14px Arial";
    ctx.fillStyle = "#6b7280";
    ctx.fillText(title2, canvas.width / 2, padding + 45);
    
    // Chart
    ctx.drawImage(img, padding, headerHeight + padding, chartWidth, chartHeight);
    
    // Stats row
    const statsY = headerHeight + chartHeight + padding + 20;
    const statLabels = ["AVERAGE", "HIGHEST", "LOWEST", "GROWTH"];
    const statValues = [stats.avg, stats.max, stats.min, stats.growth];
    const statWidth = chartWidth / 4;
    
    ctx.font = "bold 10px Arial";
    ctx.textAlign = "center";
    
    for (let i = 0; i < 4; i++) {
      const x = padding + i * statWidth + statWidth / 2;
      ctx.fillStyle = "#6b7280";
      ctx.fillText(statLabels[i], x, statsY);
      ctx.fillStyle = "#1f2937";
      ctx.font = "bold 14px Arial";
      ctx.fillText(statValues[i], x, statsY + 20);
      ctx.font = "bold 10px Arial";
    }
    
    const dataUrl = canvas.toDataURL("image/jpeg", 0.9);
    return dataUrl.split(",")[1];
  } catch (err) {
    console.error("Cash capture error:", err);
    return null;
  }
}

async function captureOverviewAsImage() {
  try {
    // Chart configurations with their chart instance keys and metric keys (all 10 metrics)
    const allChartConfigs = [
      { id: "overviewRevenueChart", title: "Revenue", metric: "revenue" },
      { id: "overviewGrossProfitChart", title: "Gross Profit", metric: "grossProfit" },
      { id: "overviewGrossMarginChart", title: "Gross Margin %", metric: "grossMargin" },
      { id: "overviewOpexChart", title: "Operating Expenses", metric: "opExpenses" },
      { id: "overviewOpProfitChart", title: "Operating Profit", metric: "opProfit" },
      { id: "overviewOpMarginChart", title: "Operating Margin %", metric: "opMargin" },
      { id: "overviewCashChart", title: "Cash", metric: "cash" },
      { id: "overviewReceivablesChart", title: "Receivables", metric: "receivables" },
      { id: "overviewPayablesChart", title: "Payables", metric: "payables" },
    ];
    
    // Filter to only visible metrics based on checkbox state
    const chartConfigs = allChartConfigs.filter(cfg => {
      const checkbox = document.querySelector(`[data-metric="${cfg.metric}"]`);
      return checkbox && checkbox.checked;
    });
    
    if (chartConfigs.length === 0) {
      console.log("No visible metrics to capture");
      return null;
    }
    
    // Load chart images using Chart.js toBase64Image
    const loadImage = (src) => new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = src;
    });
    
    const chartImages = [];
    for (const cfg of chartConfigs) {
      const chartInstance = overviewChartInstances[cfg.id];
      if (chartInstance) {
        try {
          const base64 = chartInstance.toBase64Image("image/png", 1);
          const img = await loadImage(base64);
          chartImages.push({ img, title: cfg.title });
        } catch (e) {
          console.log("Error getting chart image:", cfg.id, e);
        }
      }
    }
    
    console.log("Captured", chartImages.length, "chart images");
    
    if (chartImages.length === 0) {
      console.log("No chart images captured");
      return null;
    }
    
    // Create composite canvas with dynamic grid based on visible charts
    const chartWidth = 350;
    const chartHeight = 200;
    const titleHeight = 25;
    const padding = 12;
    const tileHeight = titleHeight + chartHeight;
    
    // Determine grid layout based on number of visible charts (supports up to 10)
    let cols, rows;
    const count = chartImages.length;
    if (count <= 1) {
      cols = 1; rows = 1;
    } else if (count <= 2) {
      cols = 2; rows = 1;
    } else if (count <= 4) {
      cols = 2; rows = 2;
    } else if (count <= 6) {
      cols = 3; rows = 2;
    } else if (count <= 8) {
      cols = 4; rows = 2;
    } else {
      cols = 5; rows = 2;
    }
    
    const compositeCanvas = document.createElement("canvas");
    compositeCanvas.width = cols * chartWidth + (cols + 1) * padding;
    compositeCanvas.height = rows * tileHeight + (rows + 1) * padding;
    const ctx = compositeCanvas.getContext("2d");
    
    // Fill background
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);
    
    // Draw all visible charts with title (no limit)
    for (let i = 0; i < chartImages.length; i++) {
      const { img, title } = chartImages[i];
      const col = i % cols;
      const row = Math.floor(i / cols);
      const x = padding + col * (chartWidth + padding);
      const y = padding + row * (tileHeight + padding);
      
      // Draw title
      ctx.fillStyle = "#374151";
      ctx.font = "bold 13px Arial";
      ctx.textAlign = "left";
      ctx.fillText(title, x, y + 16);
      
      // Draw chart image
      if (img) {
        ctx.drawImage(img, x, y + titleHeight, chartWidth, chartHeight);
      }
    }
    
    // Convert to JPEG
    const dataUrl = compositeCanvas.toDataURL("image/jpeg", 0.85);
    const base64Data = dataUrl.split(",")[1];
    const sizeKB = Math.round(base64Data.length / 1024);
    console.log("Composite chart image size:", sizeKB, "KB");
    
    return base64Data;
  } catch (err) {
    console.error("Chart capture error:", err.message);
    return null;
  }
}

async function captureVisibleSectionAsImage() {
  const visibleSection = document.querySelector('.dashboard-section.visible');
  if (!visibleSection) return null;
  
  // Hide UI elements that shouldn't appear in the screenshot
  const elementsToHide = visibleSection.querySelectorAll('.config-panel, .config-header, .config-body, .ai-analysis-panel:not(.has-analysis), .ai-run-btn, .export-bar, .saved-views-row, .chart-expand-btn, .page-chart-expand-btn, .loading-overlay, .loading-spinner, [class*="LoadingOverlay"]');
  const hiddenElements = [];
  elementsToHide.forEach(el => {
    if (el.style.display !== 'none') {
      hiddenElements.push({ el, display: el.style.display, opacity: el.style.opacity });
      el.style.display = 'none';
    }
  });
  
  // Also ensure any loading overlays with 'hidden' class stay hidden
  const loadingOverlays = visibleSection.querySelectorAll('.loading-overlay');
  loadingOverlays.forEach(overlay => {
    if (!overlay.classList.contains('hidden')) {
      overlay.classList.add('hidden');
      hiddenElements.push({ el: overlay, removeClass: 'hidden' });
    }
  });
  
  // Prepare for capture
  
  try {
    await new Promise(resolve => setTimeout(resolve, 150));
    
    // Create a clean container for PDF export with forced desktop width
    const pdfContainer = document.createElement('div');
    // Force desktop-like width to avoid mobile responsive styles
    const desktopWidth = Math.max(1200, visibleSection.scrollWidth);
    pdfContainer.style.cssText = 'position:absolute;left:-9999px;top:0;background:#fff;width:' + desktopWidth + 'px;min-width:1200px;';
    document.body.appendChild(pdfContainer);
    
    // Clone the section
    const cleanClone = visibleSection.cloneNode(true);
    cleanClone.style.width = desktopWidth + 'px';
    cleanClone.style.minWidth = '1200px';
    cleanClone.style.maxWidth = 'none';
    // CRITICAL: Force visibility on clone - the original has opacity:0 from CSS animation
    cleanClone.style.display = 'block';
    cleanClone.style.opacity = '1';
    cleanClone.style.transform = 'none';
    cleanClone.style.visibility = 'visible';
    cleanClone.style.animation = 'none';
    pdfContainer.appendChild(cleanClone);
    
    // Force solid backgrounds on all elements in the clone
    const allElements = cleanClone.querySelectorAll('*');
    allElements.forEach(el => {
      const style = el.style;
      style.backdropFilter = 'none';
      style.webkitBackdropFilter = 'none';
      style.filter = 'none';
      // Force visibility on all elements in case they have opacity: 0 or are hidden
      style.opacity = '1';
      style.visibility = 'visible';
      
      // Check if element has translucent background
      const computed = window.getComputedStyle(el);
      const bg = computed.backgroundColor;
      if (bg && bg.includes('rgba')) {
        // Force solid white for translucent backgrounds
        style.backgroundColor = '#ffffff';
      }
      // Force backgrounds for common glass elements
      if (el.classList.contains('summary-card') || 
          el.classList.contains('metric-tile') ||
          el.classList.contains('chart-card') ||
          el.classList.contains('pm-tab-btn') ||
          el.classList.contains('glass-panel') ||
          el.classList.contains('overview-tile')) {
        style.backgroundColor = '#ffffff';
        style.backgroundImage = 'none';
      }
    });
    
    // Remove all pseudo-element-generating classes' visual effects by adding inline backgrounds
    cleanClone.style.backgroundColor = '#ffffff';
    cleanClone.style.backgroundImage = 'none';
    
    // Copy canvas elements (charts) as images
    const originalCanvases = visibleSection.querySelectorAll('canvas');
    const clonedCanvases = cleanClone.querySelectorAll('canvas');
    originalCanvases.forEach((origCanvas, idx) => {
      if (clonedCanvases[idx]) {
        try {
          const dataUrl = origCanvas.toDataURL();
          const img = document.createElement('img');
          img.src = dataUrl;
          img.style.cssText = origCanvas.style.cssText;
          img.style.width = origCanvas.offsetWidth + 'px';
          img.style.height = origCanvas.offsetHeight + 'px';
          clonedCanvases[idx].parentNode.replaceChild(img, clonedCanvases[idx]);
        } catch (e) {
          console.log('Could not convert canvas to image:', e);
        }
      }
    });
    
    // Now capture the clean clone
    const canvas = await html2canvas(cleanClone, {
      scale: 1.5,
      useCORS: true,
      allowTaint: true,
      backgroundColor: '#ffffff',
      logging: false,
      windowWidth: Math.max(1200, cleanClone.scrollWidth),
      windowHeight: cleanClone.scrollHeight,
      ignoreElements: (el) => {
        return el.classList && (
          el.classList.contains('loading-overlay') ||
          el.classList.contains('loading-spinner') ||
          el.id?.includes('Loading')
        );
      }
    });
    
    // Clean up
    pdfContainer.remove();
    
    const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
    const base64Data = dataUrl.split(',')[1];
    const sizeKB = Math.round(base64Data.length / 1024);
    console.log('Section screenshot size:', sizeKB, 'KB');
    
    return base64Data;
  } catch (err) {
    console.error('Screenshot capture error:', err);
    return null;
  } finally {
    // Capture complete
    hiddenElements.forEach(item => {
      if (item.removeClass) {
        item.el.classList.remove(item.removeClass);
      } else {
        item.el.style.display = item.display;
      }
    });
  }
}

async function sendReportEmail() {
  const toEmail = document.getElementById("emailTo").value.trim();
  const subject = document.getElementById("emailSubject").value.trim();
  const statusEl = document.getElementById("emailStatus");
  const sendBtn = document.getElementById("sendEmailBtn");
  
  if (!toEmail) {
    statusEl.textContent = "Please enter a recipient email address.";
    statusEl.className = "email-status error";
    return;
  }

// Send Cash Report email via ribbon button using new HTML email API
async function sendCashReportViaRibbon(toEmail, statusEl, sendBtn) {
  sendBtn.disabled = true;
  statusEl.textContent = "Preparing report...";
  statusEl.className = "email-status";
  
  try {
    // Gather current report data using the same function as the old Email Report button
    const reportData = gatherCashReportDataForEmail();
    const aiAnalysis = document.getElementById('dcrAiAnalysisContent')?.textContent || '';
    
    statusEl.textContent = "Sending email...";
    
    const response = await fetch('/api/email-cash-report', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        to: toEmail,
        reportData: reportData,
        aiAnalysis: aiAnalysis
      })
    });
    
    const result = await response.json();
    
    if (result.success) {
      statusEl.textContent = "Email sent successfully!";
      statusEl.className = "email-status success";
      setTimeout(closeEmailModal, 2000);
    } else {
      statusEl.textContent = "Error: " + (result.error || "Failed to send email");
      statusEl.className = "email-status error";
    }
  } catch (e) {
    console.error('Cash report email error:', e);
    statusEl.textContent = "Error sending email: " + e.message;
    statusEl.className = "email-status error";
  } finally {
    sendBtn.disabled = false;
  }
}

  
  const view = getCurrentView();
  
  // Route to view-specific HTML email handlers
  if (view === 'cashReport') {
    await sendCashReportViaRibbon(toEmail, statusEl, sendBtn);
    return;
  }
  
  if (view === 'arAging') {
    await sendARAgingEmail(toEmail);
    return;
  }
  
  if (view === 'apAging') {
    await sendAPAgingEmail(toEmail);
    return;
  }
  
  if (view === 'overview') {
    await sendOverviewEmail(toEmail, statusEl, sendBtn);
    return;
  }
  
  if (view === 'incomeStatement') {
    await sendIncomeStatementEmail(toEmail, statusEl, sendBtn);
    return;
  }
  
  if (view === 'balanceSheet') {
    await sendBalanceSheetEmail(toEmail, statusEl, sendBtn);
    return;
  }
  
  if (view === 'cashFlow') {
    await sendCashFlowEmail(toEmail, statusEl, sendBtn);
    return;
  }
  
  if (view === 'jobOverview') {
    await sendJobOverviewEmail(toEmail, statusEl, sendBtn);
    return;
  }
  
  if (view === 'jobBudgets') {
    await sendJobBudgetsEmail(toEmail, statusEl, sendBtn);
    return;
  }
  
  if (view === 'jobActuals') {
    await sendJobActualsEmail(toEmail, statusEl, sendBtn);
    return;
  }
  
  if (!EMAILJS_CONFIG.publicKey || !EMAILJS_CONFIG.serviceId || !EMAILJS_CONFIG.templateId) {
    statusEl.textContent = "Email service not configured. Please set up EmailJS.";
    statusEl.className = "email-status error";
    return;
  }
  
  const data = getReportData();
  if (!data) {
    statusEl.textContent = "No report data available.";
    statusEl.className = "email-status error";
    return;
  }
  
  statusEl.textContent = "Loading email libraries...";
  statusEl.className = "email-status";
  sendBtn.disabled = true;
  
  try {
    await LazyLoader.loadMultiple(['emailjs', 'html2canvas']);
    statusEl.textContent = "Capturing screenshot...";
    emailjs.init(EMAILJS_CONFIG.publicKey);
    
    const view = getCurrentView();
    console.log("Current view:", view);
    let screenshotImage = null;
    
    statusEl.textContent = "Capturing view...";
    try {
      screenshotImage = await captureVisibleSectionAsImage();
      if (screenshotImage) {
        statusEl.textContent = "Sending with screenshot...";
      }
    } catch (captureErr) {
      console.error("Screenshot capture error:", captureErr);
      screenshotImage = null;
    }
    
    let messageHtml = `
      <div style="font-family: Arial, sans-serif; padding: 20px;">
        <h1 style="color: #1f2937; margin: 0 0 5px 0;">FTG Builders - ${data.title}</h1>
        <p style="color: #6b7280; margin: 0 0 20px 0;">${data.subtitle}</p>
        ${screenshotImage ? '<p style="margin-bottom: 10px;">Dashboard screenshot is attached below.</p>' : '<p>Screenshot could not be captured. Please view the dashboard directly.</p>'}
        <p style="color: #9ca3af; font-size: 12px; margin-top: 20px;">Generated on ${new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} at ${new Date().toLocaleTimeString()} | FTG Dashboard</p>
        <p style="text-align: center; margin-top: 16px;"><a href="https://ftg-dashboard.replit.app/" style="color: #3b82f6; font-size: 12px; text-decoration: none;">Visit FTG Dashboard for additional detail</a></p>
      </div>
    `;
    
    statusEl.textContent = "Sending...";
    
    // Generate proper filename based on current view
    const viewFilename = `${view.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '')}-${new Date().toISOString().split('T')[0]}`;
    
    const templateParams = {
      to_email: toEmail,
      subject: subject,
      message_html: messageHtml,
      report_title: data.title,
      chart_attachment: screenshotImage ? "data:image/jpeg;base64," + screenshotImage : "",
      attachment_name: `${viewFilename}.jpg`,
      chart_filename: `${viewFilename}.jpg`,
      file_name: `${viewFilename}.jpg`,
      image_name: `${viewFilename}.jpg`,
      filename: `${viewFilename}.jpg`
    };
    
    const response = await emailjs.send(
      EMAILJS_CONFIG.serviceId,
      EMAILJS_CONFIG.templateId,
      templateParams
    );
    
    if (response.status === 200) {
      statusEl.textContent = screenshotImage ? "Email sent with screenshot!" : "Email sent!";
      statusEl.className = "email-status success";
      setTimeout(closeEmailModal, 2000);
    } else {
      throw new Error("Failed to send email");
    }
  } catch (err) {
    console.error("EmailJS error:", err);
    statusEl.textContent = "Error sending email: " + (err.text || err.message || "Please try again");
    statusEl.className = "email-status error";
  } finally {
    sendBtn.disabled = false;
  }
}

/* ------------------------------------------------------------
   UI SETUP: YEAR DROPDOWN, RANGE SLIDERS, VIEW SWITCHING
------------------------------------------------------------ */
function setupRevenueUI(data) {
  try {
    if (!data || !data.revenue) {
      console.error("Revenue data not available");
      return;
    }
    
    const years = Object.keys(data.revenue)
      .map(Number)
      .sort((a, b) => a - b);

    if (years.length === 0) {
      console.error("No years found in revenue data");
      return;
    }

    /* ------------------ YEAR DROPDOWN ------------------ */
    const yearSelect = document.getElementById("revYear");
    if (!yearSelect) {
      console.error("Revenue year select not found");
      return;
    }
    
    yearSelect.innerHTML = years.map(y => `<option value="${y}">${y}</option>`).join("");
    yearSelect.value = Math.max(...years);

    /* ------------------ SLIDER SETUP ------------------ */
    const s = document.getElementById("revRangeStart");
    const e = document.getElementById("revRangeEnd");

    if (s && e) {
      s.min = e.min = years[0];
      s.max = e.max = years[years.length - 1];
      s.value = years[0];
      e.value = years[years.length - 1];
    }

    const startLabel = document.getElementById("revRangeStartLabel");
    const endLabel = document.getElementById("revRangeEndLabel");
    if (startLabel && s) startLabel.innerText = s.value;
    if (endLabel && e) endLabel.innerText = e.value;

  // Make sure start ≤ end
  s.oninput = () => {
    if (+s.value > +e.value) s.value = e.value;
    document.getElementById("revRangeStartLabel").innerText = s.value;
  };

  e.oninput = () => {
    if (+e.value < +s.value) e.value = s.value;
    document.getElementById("revRangeEndLabel").innerText = e.value;
  };

  /* ------------------ VIEW SWITCHER ------------------ */
  document.getElementById("revViewType").onchange = () => {
    const view = document.getElementById("revViewType").value;

    const compareCheckbox = document.getElementById("revCompare");
    const compareLabel = compareCheckbox ? compareCheckbox.closest("label") : null;
    const yearWrap = document.getElementById("revYearWrapper");
    const rangeWrap = document.getElementById("revRangeWrapper");
    const excludeLabel = document.getElementById("revExcludeLabel");

    if (view === "annual") {
      if (compareLabel) compareLabel.style.display = "none";
      if (yearWrap) yearWrap.style.display = "none";
      if (rangeWrap) rangeWrap.classList.remove("hidden");
      if (excludeLabel) excludeLabel.textContent = "Exclude Current Year";
    } else if (view === "quarterly") {
      if (compareLabel) compareLabel.style.display = "";
      if (yearWrap) yearWrap.style.display = "flex";
      if (rangeWrap) rangeWrap.classList.add("hidden");
      if (excludeLabel) excludeLabel.textContent = "Exclude Current Quarter";
    } else {
      if (compareLabel) compareLabel.style.display = "";
      if (yearWrap) yearWrap.style.display = "flex";
      if (rangeWrap) rangeWrap.classList.add("hidden");
      if (excludeLabel) excludeLabel.textContent = "Exclude Current Month";
    }
    
    updateRevenueView(data);
    saveRevenueConfig();
  };
  
  document.getElementById("revYear").onchange = () => {
    updateRevenueView(data);
    saveRevenueConfig();
  };
  
  document.getElementById("revCompare").onchange = () => {
    updateRevenueView(data);
    saveRevenueConfig();
  };
  
  document.getElementById("revTrendline").onchange = () => {
    updateRevenueView(data);
    saveRevenueConfig();
  };
  document.getElementById("revDataLabels").onchange = () => {
    updateRevenueView(data);
    saveRevenueConfig();
  };
  document.getElementById("revExcludeCurrent").onchange = () => {
    updateRevenueView(data);
    saveRevenueConfig();
  };
  
  document.getElementById("revRangeStart").oninput = () => {
    const start = parseInt(document.getElementById("revRangeStart").value);
    const end = parseInt(document.getElementById("revRangeEnd").value);
    if (start > end) document.getElementById("revRangeEnd").value = start;
    document.getElementById("revRangeStartLabel").textContent = start;
    document.getElementById("revRangeEndLabel").textContent = document.getElementById("revRangeEnd").value;
    updateRevenueView(data);
    saveRevenueConfig();
  };
  
  document.getElementById("revRangeEnd").oninput = () => {
    const start = parseInt(document.getElementById("revRangeStart").value);
    const end = parseInt(document.getElementById("revRangeEnd").value);
    if (end < start) document.getElementById("revRangeStart").value = end;
    document.getElementById("revRangeStartLabel").textContent = document.getElementById("revRangeStart").value;
    document.getElementById("revRangeEndLabel").textContent = end;
    updateRevenueView(data);
    saveRevenueConfig();
  };
  
  // Setup expand button for revenue table
  const revExpandBtn = document.querySelector('#revenue .breakdown-expand-btn[data-target="revTableWrapper"]');
  if (revExpandBtn && !revExpandBtn.dataset.listenerAttached) {
    revExpandBtn.dataset.listenerAttached = 'true';
    revExpandBtn.addEventListener('click', () => {
      const tableWrapper = document.getElementById('revTableWrapper');
      const textSpan = revExpandBtn.querySelector('.expand-text');
      const chartBox = revExpandBtn.closest('.chart-box');
      
      if (tableWrapper) {
        const isCollapsed = tableWrapper.classList.contains('collapsed');
        tableWrapper.classList.toggle('collapsed');
        revExpandBtn.classList.toggle('expanded');
        
        if (chartBox) {
          chartBox.classList.toggle('table-expanded', isCollapsed);
        }
        
        if (textSpan) {
          textSpan.textContent = isCollapsed ? 'Collapse' : 'Expand';
        }
      }
    });
  }
  } catch (err) {
    console.error("Error setting up revenue UI:", err);
  }
}

/* ============================================================
   REVENUE VIEW — MAIN UPDATE ENGINE
============================================================ */

// Helper: flip negative values to positive for display
function toPositive(arr) {
  return (arr || []).map(v => Math.abs(v));
}

function formatTileValue(val) {
  const absVal = Math.abs(val);
  if (absVal >= 1000000) {
    return "$" + (val / 1000000).toFixed(1) + "M";
  } else if (absVal >= 1000) {
    return "$" + (val / 1000).toFixed(0) + "K";
  }
  return "$" + val.toLocaleString();
}

function formatCurrency(value) {
  if (value === null || value === undefined || value === 0) return "-";
  const absVal = Math.abs(value);
  const formatted = absVal.toLocaleString(undefined, {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  });
  if (value < 0) {
    return `($${formatted})`;
  }
  return `$${formatted}`;
}

function calculateCAGR(values) {
  if (values.length < 2) return 0;
  const first = values[0];
  const last = values[values.length - 1];
  if (first <= 0 || last <= 0) return 0;
  const years = values.length - 1;
  return (Math.pow(last / first, 1 / years) - 1) * 100;
}

function updateSummaryTiles(prefix, values, labels) {
  const validValues = values.filter(v => v !== null && v !== undefined);
  const validLabels = values.map((v, i) => v !== null && v !== undefined ? labels[i] : null).filter(l => l !== null);
  
  const avg = validValues.length > 0 ? validValues.reduce((a, b) => a + b, 0) / validValues.length : 0;
  
  let maxVal = -Infinity, maxIdx = 0;
  let minVal = Infinity, minIdx = 0;
  
  validValues.forEach((v, i) => {
    if (v > maxVal) { maxVal = v; maxIdx = i; }
    if (v < minVal) { minVal = v; minIdx = i; }
  });
  
  if (!isFinite(maxVal)) maxVal = 0;
  if (!isFinite(minVal)) minVal = 0;
  
  const cagr = calculateCAGR(validValues);
  
  document.getElementById(prefix + "AvgValue").innerText = formatTileValue(avg);
  document.getElementById(prefix + "MaxValue").innerText = formatTileValue(maxVal);
  document.getElementById(prefix + "MaxPeriod").innerText = validLabels[maxIdx] || "-";
  document.getElementById(prefix + "MinValue").innerText = formatTileValue(minVal);
  document.getElementById(prefix + "MinPeriod").innerText = validLabels[minIdx] || "-";
  const cagrEl = document.getElementById(prefix + "CagrValue");
  cagrEl.innerText = (cagr >= 0 ? "+" : "") + cagr.toFixed(1) + "%";
  cagrEl.style.color = cagr < 0 ? "#dc2626" : cagr > 0 ? "#10b981" : "";
}

function updateRevenueView(data) {
  const view = document.getElementById("revViewType").value;
  const compare = document.getElementById("revCompare").checked;
  const year = parseInt(document.getElementById("revYear").value);
  const excludeCurrent = document.getElementById("revExcludeCurrent").checked;
  
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth();

  let labels = [];
  let datasets = [];
  let hasPartialPeriod = false;

  /* ============================================================
     MONTHLY VIEW
  ============================================================= */
  if (view === "monthly") {
    labels = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

    let current = toPositive(data.revenue[year]);
    const prior = toPositive(data.revenue[year - 1]);
    
    const isCurrentYear = year === currentYear;
    
    if (excludeCurrent && isCurrentYear && current) {
      current = current.map((v, i) => i === currentMonth ? null : v);
    }
    
    const barColors = current ? current.map((v, i) => {
      if (isCurrentYear && i === currentMonth && !excludeCurrent) {
        hasPartialPeriod = true;
        return "#f59e0b";
      }
      return "#3b82f6";
    }) : "#3b82f6";

    // Prior year FIRST (left)
    if (compare && prior) {
      datasets.push({
        label: `${year - 1}`,
        data: prior,
        backgroundColor: "#dc2626"
      });
    }

    // Current year SECOND (right)
    datasets.push({
      label: `${year}`,
      data: current,
      backgroundColor: barColors,
      partialIndex: isCurrentYear && !excludeCurrent ? currentMonth : -1
    });

    setRevenueTitle(`Monthly – ${year}`);
  }

  /* ============================================================
     QUARTERLY VIEW
  ============================================================= */
  else if (view === "quarterly") {
    labels = ["Q1","Q2","Q3","Q4"];
    
    const isCurrentYear = year === currentYear;
    const currentQuarter = Math.floor(currentMonth / 3);

    let months = toPositive(data.revenue[year]);
    
    if (excludeCurrent && isCurrentYear && months) {
      months = months.map((v, i) => i === currentMonth ? 0 : v);
    }
    
    const sumQ = q => {
      const slice = months ? months.slice((q - 1) * 3, q * 3) : [];
      return slice.length > 0 ? slice.reduce((a,b) => a + b, 0) : 0;
    };
    let currentQ = [sumQ(1), sumQ(2), sumQ(3), sumQ(4)];
    
    const barColors = currentQ.map((v, i) => {
      if (isCurrentYear && i === currentQuarter) {
        hasPartialPeriod = true;
        return "#f59e0b";
      }
      return "#3b82f6";
    });

    if (compare && data.revenue[year - 1]) {
      const pm = toPositive(data.revenue[year - 1]);
      const sumPQ = q => {
        const slice = pm.slice((q - 1) * 3, q * 3);
        return slice.length > 0 ? slice.reduce((a,b) => a + b, 0) : 0;
      };

      const priorQ = [sumPQ(1), sumPQ(2), sumPQ(3), sumPQ(4)];

      // Prior year FIRST
      datasets.push({
        label: `${year - 1}`,
        data: priorQ,
        backgroundColor: "#dc2626"
      });
    }

    // Current year SECOND
    datasets.push({
      label: `${year}`,
      data: currentQ,
      backgroundColor: barColors
    });

    setRevenueTitle(`Quarterly – ${year}`);
  }

  /* ============================================================
     ANNUAL VIEW
  ============================================================= */
  else if (view === "annual") {
    const start = +document.getElementById("revRangeStart").value;
    const end   = +document.getElementById("revRangeEnd").value;

    labels = [];
    const annualTotals = [];
    const barColors = [];
    
    for (let y = start; y <= end; y++) {
      labels.push(y.toString());
      let yearData = toPositive(data.revenue[y]);
      
      if (excludeCurrent && y === currentYear && yearData) {
        yearData = yearData.map((v, i) => i === currentMonth ? 0 : v);
      }
      
      const total = yearData && yearData.length > 0 ? yearData.reduce((a,b) => a + b, 0) : 0;
      
      annualTotals.push(total);
      
      if (y === currentYear) {
        hasPartialPeriod = true;
        barColors.push("#f59e0b");
      } else {
        barColors.push("#3b82f6");
      }
    }

    datasets = [
      {
        label: "Annual Revenue",
        data: annualTotals,
        backgroundColor: barColors
      }
    ];

    setRevenueTitle(`Annual – ${start} to ${end}`);
  }

  /* ============================================================
     ADD TRENDLINES IF ENABLED
  ============================================================= */
  const showTrendline = document.getElementById("revTrendline").checked;
  if (showTrendline) {
    const barDatasets = [...datasets];
    const currentYearLabel = String(year);
    barDatasets.forEach((ds) => {
      if (compare && ds.label !== currentYearLabel && ds.label !== "Annual Revenue") return;
      const trendData = calculateTrendline(ds.data);
      datasets.push({
        label: `${ds.label} Trend`,
        data: trendData,
        type: "line",
        borderColor: "#10b981",
        backgroundColor: "transparent",
        borderWidth: 2,
        borderDash: [5, 5],
        pointRadius: 0,
        tension: 0,
        order: 0,
        datalabels: { display: false }
      });
    });
  }

  /* ============================================================
     APPLY UPDATES
  ============================================================= */
  const tableDatasets = datasets.filter(ds => ds.type !== "line");
  currentTableData = { labels, datasets: tableDatasets };
  
  renderRevenueChart(labels, datasets);
  renderRevenueTable(labels, tableDatasets);
  updateTimestamp();
  
  const currentYearDataset = tableDatasets.find(ds => ds.label === String(year)) || tableDatasets[tableDatasets.length - 1];
  const currentValues = currentYearDataset ? currentYearDataset.data : [];
  
  let tileLabels = labels;
  if (view === "monthly") {
    tileLabels = labels.map(l => `${l} ${year}`);
  } else if (view === "quarterly") {
    tileLabels = labels.map(l => `${l} ${year}`);
  }
  updateSummaryTiles("rev", currentValues, tileLabels);
  
  const partialLegend = document.getElementById("revPartialLegend");
  if (hasPartialPeriod) {
    partialLegend.classList.remove("hidden");
  } else {
    partialLegend.classList.add("hidden");
  }
}

/* ------------------------------------------------------------
   TITLE + TIMESTAMP
------------------------------------------------------------ */
function setRevenueTitle(sub) {
  document.getElementById("revChartTitleLine1").innerText = "FTG Builders Revenue";
  document.getElementById("revChartTitleLine2").innerText = sub;
}

function updateTimestamp() {
  const now = new Date();
  const t = now.toLocaleDateString(undefined, {
    year: "numeric",
    month: "short",
    day: "numeric"
  });
  document.getElementById("revChartUpdated").innerText = `Updated: ${t}`;
}

/* ------------------------------------------------------------
   CHART RENDERING (SOLID BARS + RESPONSIVE)
------------------------------------------------------------ */
function applyGradientToDatasets(datasets, chart) {
  const { ctx, chartArea } = chart;
  if (!chartArea) return;
  
  datasets.forEach(ds => {
    if (ds.type === "line") return;
    
    // Apply consistent bar styling
    if (ds.borderRadius === undefined) ds.borderRadius = 4;
    if (ds.barPercentage === undefined) ds.barPercentage = 0.9;
    if (ds.categoryPercentage === undefined) ds.categoryPercentage = 0.85;
    
    const origBg = ds._originalBg || ds.backgroundColor;
    ds._originalBg = origBg;
    
    if (Array.isArray(origBg)) {
      ds.backgroundColor = origBg.map(color => {
        if (color === "#3b82f6") return createBarGradient(ctx, chartArea, gradientColors.blue.start, gradientColors.blue.end);
        if (color === "#dc2626") return createBarGradient(ctx, chartArea, gradientColors.red.start, gradientColors.red.end);
        if (color === "#f59e0b") return createBarGradient(ctx, chartArea, gradientColors.orange.start, gradientColors.orange.end);
        return color;
      });
    } else if (typeof origBg === "string") {
      if (origBg === "#3b82f6") ds.backgroundColor = createBarGradient(ctx, chartArea, gradientColors.blue.start, gradientColors.blue.end);
      else if (origBg === "#dc2626") ds.backgroundColor = createBarGradient(ctx, chartArea, gradientColors.red.start, gradientColors.red.end);
      else if (origBg === "#f59e0b") ds.backgroundColor = createBarGradient(ctx, chartArea, gradientColors.orange.start, gradientColors.orange.end);
    }
  });
}

function renderRevenueChart(labels, datasets) {
  console.log("renderRevenueChart called", { labels, datasets });
  
  try {
    const canvas = document.getElementById("revChart");
    console.log("Canvas element:", canvas);
    
    if (!canvas) {
      console.error("Chart canvas not found");
      showChartError("Canvas element not found");
      return;
    }
    
    if (revChartInstance) {
      revChartInstance.destroy();
      revChartInstance = null;
    }

    const ctx = canvas.getContext("2d");
    console.log("2D context:", ctx);
    
    if (!ctx) {
      console.error("Could not get 2D context");
      showChartError("Could not initialize chart");
      return;
    }
    
    // Check if Chart is available
    if (typeof Chart === 'undefined') {
      console.error("Chart.js not loaded");
      showChartError("Chart library not loaded");
      return;
    }
    
    console.log("Creating Chart instance...");
    
    const gradientPlugin = {
      id: 'gradientPlugin',
      beforeDraw: (chart) => applyGradientToDatasets(chart.data.datasets, chart)
    };
    
    const dataLabelsCheckbox = document.getElementById("revDataLabels");
    const showDataLabels = dataLabelsCheckbox ? dataLabelsCheckbox.checked : false;
    
    // Calculate Y-axis minimum based on data
    let allValues = [];
    datasets.forEach(ds => {
      if (ds.type !== 'line' && ds.data) {
        allValues = allValues.concat(ds.data.filter(v => v !== null && v !== undefined && !isNaN(v)));
      }
    });
    const dataMin = allValues.length > 0 ? Math.min(...allValues) : 0;
    const dataMax = allValues.length > 0 ? Math.max(...allValues) : 0;
    
    // Calculate appropriate Y-axis min (start just below the lowest value)
    let yMin = undefined;
    if (dataMin > 0) {
      const range = dataMax - dataMin;
      // Use 15% of range as padding, or 10% of dataMin if flat data
      const padding = range > 0 ? range * 0.15 : dataMin * 0.1;
      
      let step;
      if (dataMin >= 1000000) {
        step = 100000;
      } else if (dataMin >= 100000) {
        step = 10000;
      } else if (dataMin >= 10000) {
        step = 5000;
      } else if (dataMin >= 1000) {
        step = 500;
      } else {
        step = 100;
      }
      yMin = Math.floor((dataMin - padding) / step) * step;
      if (yMin < 0) yMin = 0;
    }

    const themeColors = getChartThemeColors();
    
    revChartInstance = new Chart(ctx, {
      type: "bar",
      data: { labels, datasets },
      plugins: [ChartDataLabels, gradientPlugin],
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: {
          duration: 800,
          easing: "easeOutQuart",
          delay: (context) => {
            let delay = 0;
            if (context.type === 'data' && context.mode === 'default') {
              delay = context.dataIndex * 40 + context.datasetIndex * 80;
            }
            return delay;
          }
        },
        transitions: {
          active: { animation: { duration: 200 } }
        },
        layout: {
          padding: { top: showDataLabels ? 30 : 0 }
        },
        plugins: {
          legend: { position: "bottom", labels: { color: themeColors.legendColor } },
          tooltip: {
            backgroundColor: "rgba(31, 41, 55, 0.95)",
            titleFont: { size: 14 },
            bodyFont: { size: 13 },
            padding: 12,
            callbacks: {
              title: function(tooltipItems) {
                return tooltipItems[0].label;
              },
              label: function(context) {
                if (context.dataset.type === "line") return null;
                const value = context.parsed.y;
                const prefix = context.dataset.label === selectedYear.toString() ? "" : context.dataset.label + ": ";
                return prefix + "$" + value.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
              }
            }
          },
          datalabels: {
            display: (context) => {
              if (!showDataLabels) return false;
              if (context.dataset.type === "line") return false;
              return true;
            },
            anchor: "end",
            align: "top",
            offset: 4,
            font: {
              size: 12,
              weight: "600"
            },
            color: function(context) {
              return context.dataset.borderColor || themeColors.textColor;
            },
            formatter: function(value) {
              if (value === 0 || value === null) return "";
              if (Math.abs(value) >= 1000000) {
                return "$" + (value / 1000000).toFixed(1) + "M";
              } else if (Math.abs(value) >= 1000) {
                return "$" + (value / 1000).toFixed(0) + "K";
              }
              return "$" + value.toLocaleString();
            }
          }
        },
        scales: {
          x: {
            ticks: {
              padding: 10,
              font: { size: 12 },
              color: themeColors.textColor
            },
            grid: {
              drawOnChartArea: false,
              color: themeColors.gridColor
            }
          },
          y: {
            min: yMin,
            grid: { color: themeColors.gridColor },
            ticks: {
              font: { size: 11 },
              color: themeColors.textColor,
              callback: v => "$" + (v / 1000000).toFixed(1) + "M"
            }
          }
        }
      }
    });
    
    console.log("Chart created successfully:", revChartInstance);
    hideChartError();
  } catch (err) {
    console.error("Chart render error:", err);
    showChartError("Error: " + err.message);
  }
}

function showChartError(msg) {
  let errDiv = document.getElementById("chartErrorMsg");
  if (!errDiv) {
    errDiv = document.createElement("div");
    errDiv.id = "chartErrorMsg";
    errDiv.style.cssText = "padding:40px;text-align:center;color:#dc2626;font-weight:600;";
    const chartBox = document.getElementById("revChartBox");
    if (chartBox) chartBox.appendChild(errDiv);
  }
  errDiv.textContent = msg;
  errDiv.style.display = "block";
}

function hideChartError() {
  const errDiv = document.getElementById("chartErrorMsg");
  if (errDiv) errDiv.style.display = "none";
}

/* ------------------------------------------------------------
   TABLE RENDERING WITH GROWTH INDICATORS
------------------------------------------------------------ */
function renderRevenueTable(labels, datasets) {
  const head = document.getElementById("revTableHead");
  const body = document.getElementById("revTableBody");

  head.innerHTML = "";
  body.innerHTML = "";

  const hasComparison = datasets.length > 1;

  let header = "<tr><th>Period</th>";
  datasets.forEach(ds => {
    header += `<th>${ds.label}</th>`;
  });
  if (hasComparison) {
    header += "<th>Change</th>";
  }
  header += "</tr>";
  head.innerHTML = header;

  labels.forEach((lbl, i) => {
    let row = `<tr><td>${lbl}</td>`;
    
    const values = datasets.map(ds => ds.data[i] || 0);
    
    datasets.forEach(ds => {
      const v = Math.round(ds.data[i] || 0);
      row += `<td>$${v.toLocaleString()}</td>`;
    });
    
    if (hasComparison && values.length >= 2) {
      const prior = values[0];
      const current = values[1];
      const change = prior > 0 ? ((current - prior) / prior * 100) : 0;
      const sign = change >= 0 ? "+" : "";
      const colorClass = change > 0 ? "growth-positive" : change < 0 ? "growth-negative" : "growth-neutral";
      row += `<td class="${colorClass}">${sign}${change.toFixed(1)}%</td>`;
    }
    
    row += "</tr>";
    body.innerHTML += row;
  });
  
  const exportBtn = document.getElementById("revTableExportBtn");
  if (exportBtn) {
    exportBtn.onclick = () => exportTableToCSV("revTable", "revenue-breakdown");
  }
}

function exportTableToCSV(tableId, filename) {
  const table = document.getElementById(tableId);
  if (!table) return;
  
  let csv = [];
  const rows = table.querySelectorAll("tr");
  
  rows.forEach(row => {
    const cols = row.querySelectorAll("td, th");
    const csvRow = [];
    cols.forEach(col => {
      csvRow.push('"' + col.textContent.trim().replace(/"/g, '""') + '"');
    });
    csv.push(csvRow.join(","));
  });
  
  const csvContent = "data:text/csv;charset=utf-8," + encodeURIComponent(csv.join("\n"));
  const link = document.createElement("a");
  link.setAttribute("href", csvContent);
  link.setAttribute("download", filename + ".csv");
  link.click();
}

/* ============================================================
   ACCOUNT VIEW MODULE — GL ACCOUNT DRILLDOWN
============================================================ */

let acctChartInstance = null;
let acctDataCache = null;
let acctUIInitialized = false;

async function initAccountModule() {
  console.log('[AccountDetail] Initializing...');
  const spinner = document.getElementById("acctLoadingSpinner");
  
  try {
    spinner?.classList.remove("hidden");
    
    if (!acctDataCache) {
      if (revenueDataCache) {
        acctDataCache = revenueDataCache;
        console.log('[AccountDetail] Using cached revenue data');
      } else {
        const response = await fetch("/data/financials_gl.json");
        if (!response.ok) throw new Error("Failed to fetch account data");
        acctDataCache = await response.json();
        revenueDataCache = acctDataCache;
        console.log('[AccountDetail] Data loaded:', acctDataCache.gl_history_all?.length || 0, 'GL records');
      }
    }

    if (!acctUIInitialized) {
      setupAccountUI(acctDataCache);
      loadAccountConfig();
      acctUIInitialized = true;
    }
    
    spinner?.classList.add("hidden");
    updateAccountView(acctDataCache);

  } catch (err) {
    console.error("[AccountDetail] Module error:", err);
    spinner?.classList.add("hidden");
  }
}

function setupAccountUI(data) {
  try {
    const acctSelect = document.getElementById("acctSelect");
    const yearSelect = document.getElementById("acctYear");
    
    if (!acctSelect || !yearSelect) {
      console.error("Account UI elements not found");
      return;
    }
    
    if (!data || !data.gl_history_all || data.gl_history_all.length === 0) {
      acctSelect.innerHTML = '<option value="">No accounts available</option>';
      return;
    }
  
  const accounts = data.gl_history_all
    .map(row => ({
      num: row.Account_Num || "",
      desc: row.Account_Description || ""
    }))
    .filter(a => {
      const numVal = parseInt(a.num) || 0;
      return numVal >= 4000;
    });
  
  accounts.sort((a, b) => {
    const numA = parseInt(a.num) || 0;
    const numB = parseInt(b.num) || 0;
    return numA - numB;
  });
  
  acctSelect.innerHTML = accounts.map(a => 
    `<option value="${a.num}">${a.num} – ${a.desc}</option>`
  ).join("");
  
  if (accounts.length > 0) {
    acctSelect.value = accounts[0].num;
  }
  
  // Extract years from gl_history_all column names (format: YYYY-MM)
  const yearSet = new Set();
  if (data.gl_history_all && data.gl_history_all.length > 0) {
    const firstRecord = data.gl_history_all[0];
    Object.keys(firstRecord).forEach(key => {
      const match = key.match(/^(\d{4})-\d{2}$/);
      if (match) yearSet.add(parseInt(match[1]));
    });
  }
  const years = Array.from(yearSet).sort((a, b) => a - b);
  
  if (years.length === 0) {
    console.error("No years found in data");
    return;
  }
  
  yearSelect.innerHTML = years.map(y => `<option value="${y}">${y}</option>`).join("");
  yearSelect.value = Math.max(...years);
  
  const s = document.getElementById("acctRangeStart");
  const e = document.getElementById("acctRangeEnd");
  s.min = e.min = years[0];
  s.max = e.max = years[years.length - 1];
  s.value = years[0];
  e.value = years[years.length - 1];
  document.getElementById("acctRangeStartLabel").innerText = s.value;
  document.getElementById("acctRangeEndLabel").innerText = e.value;
  
  s.oninput = () => {
    if (+s.value > +e.value) s.value = e.value;
    document.getElementById("acctRangeStartLabel").innerText = s.value;
    updateAccountView(data);
    saveAccountConfig();
  };
  e.oninput = () => {
    if (+e.value < +s.value) e.value = s.value;
    document.getElementById("acctRangeEndLabel").innerText = e.value;
    updateAccountView(data);
    saveAccountConfig();
  };
  
  document.getElementById("acctViewType").onchange = () => {
    const view = document.getElementById("acctViewType").value;
    const yearWrap = document.getElementById("acctYearWrapper");
    const compareCheckbox = document.getElementById("acctCompare");
    const compareLabel = compareCheckbox ? compareCheckbox.closest("label") : null;
    const rangeWrap = document.getElementById("acctRangeWrapper");
    const excludeLabel = document.getElementById("acctExcludeLabel");
    
    if (view === "annual") {
      if (yearWrap) yearWrap.style.display = "none";
      if (compareLabel) compareLabel.style.display = "none";
      if (rangeWrap) rangeWrap.classList.remove("hidden");
      if (excludeLabel) excludeLabel.textContent = "Exclude Current Year";
    } else if (view === "quarterly") {
      if (yearWrap) yearWrap.style.display = "flex";
      if (compareLabel) compareLabel.style.display = "";
      if (rangeWrap) rangeWrap.classList.add("hidden");
      if (excludeLabel) excludeLabel.textContent = "Exclude Current Quarter";
    } else {
      if (yearWrap) yearWrap.style.display = "flex";
      if (compareLabel) compareLabel.style.display = "";
      if (rangeWrap) rangeWrap.classList.add("hidden");
      if (excludeLabel) excludeLabel.textContent = "Exclude Current Month";
    }
    updateAccountView(data);
    saveAccountConfig();
  };
  
  acctSelect.onchange = () => { updateAccountView(data); saveAccountConfig(); };
  yearSelect.onchange = () => { updateAccountView(data); saveAccountConfig(); };
  document.getElementById("acctCompare").onchange = () => { updateAccountView(data); saveAccountConfig(); };
  document.getElementById("acctTrendline").onchange = () => { updateAccountView(data); saveAccountConfig(); };
  document.getElementById("acctDataLabels").onchange = () => { updateAccountView(data); saveAccountConfig(); };
  document.getElementById("acctExcludeCurrent").onchange = () => { updateAccountView(data); saveAccountConfig(); };
  
  // Setup expand button for account table
  const acctExpandBtn = document.querySelector('#accounts .breakdown-expand-btn[data-target="acctTableWrapper"]');
  if (acctExpandBtn && !acctExpandBtn.dataset.listenerAttached) {
    acctExpandBtn.dataset.listenerAttached = 'true';
    acctExpandBtn.addEventListener('click', () => {
      const tableWrapper = document.getElementById('acctTableWrapper');
      const textSpan = acctExpandBtn.querySelector('.expand-text');
      const chartBox = acctExpandBtn.closest('.chart-box');
      
      if (tableWrapper) {
        const isCollapsed = tableWrapper.classList.contains('collapsed');
        tableWrapper.classList.toggle('collapsed');
        acctExpandBtn.classList.toggle('expanded');
        
        if (chartBox) {
          chartBox.classList.toggle('table-expanded', isCollapsed);
        }
        
        if (textSpan) {
          textSpan.textContent = isCollapsed ? 'Collapse' : 'Expand';
        }
      }
    });
  }
  } catch (err) {
    console.error("Error setting up account UI:", err);
  }
}

function isIncomeAccount(accountNum) {
  const num = parseInt(accountNum) || 0;
  return (num >= 4000 && num < 5000) || (num >= 8000 && num < 9000);
}

function getAccountMonthlyValues(accountNum, year, data) {
  if (!data.gl_history_all) return Array(12).fill(0);
  
  const row = data.gl_history_all.find(r => r.Account_Num === accountNum);
  if (!row) return Array(12).fill(0);
  
  const flipSign = isIncomeAccount(accountNum);
  
  const months = [];
  for (let m = 1; m <= 12; m++) {
    const key = `${year}-${String(m).padStart(2, "0")}`;
    const rawVal = row[key];
    let val = (rawVal === "" || rawVal === null || rawVal === undefined) ? 0 : parseFloat(rawVal);
    if (isNaN(val)) val = 0;
    months.push(flipSign ? Math.abs(val) : val);
  }
  return months;
}

function getAccountQuarterlyValues(accountNum, year, data) {
  const monthly = getAccountMonthlyValues(accountNum, year, data);
  return [
    monthly.slice(0, 3).reduce((a, b) => a + b, 0),
    monthly.slice(3, 6).reduce((a, b) => a + b, 0),
    monthly.slice(6, 9).reduce((a, b) => a + b, 0),
    monthly.slice(9, 12).reduce((a, b) => a + b, 0)
  ];
}

function getAccountAnnualValue(accountNum, year, data) {
  const monthly = getAccountMonthlyValues(accountNum, year, data);
  return monthly.reduce((a, b) => a + b, 0);
}

function updateAccountView(data) {
  console.log('[AccountDetail] Updating view...');
  if (!data || !data.gl_history_all || data.gl_history_all.length === 0) {
    console.log('[AccountDetail] No GL data available');
    document.getElementById("acctChartTitleLine1").innerText = "No Account Data";
    document.getElementById("acctChartTitleLine2").innerText = "GL history not available";
    return;
  }
  
  const acctNum = document.getElementById("acctSelect")?.value;
  if (!acctNum) {
    console.log('[AccountDetail] No account selected');
    return;
  }
  console.log('[AccountDetail] Rendering account:', acctNum);
  
  const view = document.getElementById("acctViewType").value;
  const year = parseInt(document.getElementById("acctYear").value);
  const compare = document.getElementById("acctCompare").checked;
  const excludeCurrent = document.getElementById("acctExcludeCurrent").checked;
  
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth();
  const currentQuarter = Math.floor(currentMonth / 3);
  
  const row = data.gl_history_all.find(r => r.Account_Num === acctNum);
  const acctDesc = row ? row.Account_Description : "";
  
  let labels = [];
  let datasets = [];
  let subtitle = "";
  let hasPartialPeriod = false;
  
  if (view === "monthly") {
    labels = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    let currentValues = getAccountMonthlyValues(acctNum, year, data);
    const isCurrentYear = year === currentYear;
    
    if (excludeCurrent && isCurrentYear) {
      currentValues = currentValues.map((v, i) => i === currentMonth ? null : v);
    }
    
    // Track which indices are current month (partial period)
    const currentMonthIdx = isCurrentYear && !excludeCurrent ? currentMonth : -1;
    if (isCurrentYear && !excludeCurrent) hasPartialPeriod = true;
    
    if (compare) {
      const priorValues = getAccountMonthlyValues(acctNum, year - 1, data);
      datasets.push({
        label: `${year - 1}`,
        data: priorValues,
        backgroundColor: function(context) {
          const chart = context.chart;
          const { ctx, chartArea } = chart;
          return createBarGradient(ctx, chartArea, gradientColors.red.start, gradientColors.red.end);
        },
        borderRadius: 4,
        barPercentage: 0.9,
        categoryPercentage: 0.85
      });
    }
    
    datasets.push({
      label: `${year}`,
      data: currentValues,
      backgroundColor: function(context) {
        const chart = context.chart;
        const { ctx, chartArea } = chart;
        const dataIndex = context.dataIndex;
        // Use orange gradient for current month
        if (dataIndex === currentMonthIdx) {
          return createBarGradient(ctx, chartArea, gradientColors.orange.start, gradientColors.orange.end);
        }
        return createBarGradient(ctx, chartArea, gradientColors.blue.start, gradientColors.blue.end);
      },
      borderRadius: 4,
      barPercentage: 0.9,
      categoryPercentage: 0.85
    });
    
    subtitle = `Monthly – ${year}`;
  } else if (view === "quarterly") {
    labels = ["Q1","Q2","Q3","Q4"];
    const isCurrentYear = year === currentYear;
    
    let monthly = getAccountMonthlyValues(acctNum, year, data);
    if (excludeCurrent && isCurrentYear) {
      monthly = monthly.map((v, i) => i === currentMonth ? 0 : v);
    }
    
    let currentValues = [
      monthly.slice(0, 3).reduce((a, b) => a + b, 0),
      monthly.slice(3, 6).reduce((a, b) => a + b, 0),
      monthly.slice(6, 9).reduce((a, b) => a + b, 0),
      monthly.slice(9, 12).reduce((a, b) => a + b, 0)
    ];
    
    // Track which index is current quarter (partial period)
    const currentQuarterIdx = isCurrentYear ? currentQuarter : -1;
    if (isCurrentYear) hasPartialPeriod = true;
    
    if (compare) {
      const priorValues = getAccountQuarterlyValues(acctNum, year - 1, data);
      datasets.push({
        label: `${year - 1}`,
        data: priorValues,
        backgroundColor: function(context) {
          const chart = context.chart;
          const { ctx, chartArea } = chart;
          return createBarGradient(ctx, chartArea, gradientColors.red.start, gradientColors.red.end);
        },
        borderRadius: 4,
        barPercentage: 0.9,
        categoryPercentage: 0.85
      });
    }
    
    datasets.push({
      label: `${year}`,
      data: currentValues,
      backgroundColor: function(context) {
        const chart = context.chart;
        const { ctx, chartArea } = chart;
        const dataIndex = context.dataIndex;
        // Use orange gradient for current quarter
        if (dataIndex === currentQuarterIdx) {
          return createBarGradient(ctx, chartArea, gradientColors.orange.start, gradientColors.orange.end);
        }
        return createBarGradient(ctx, chartArea, gradientColors.blue.start, gradientColors.blue.end);
      },
      borderRadius: 4,
      barPercentage: 0.9,
      categoryPercentage: 0.85
    });
    
    subtitle = `Quarterly – ${year}`;
  } else if (view === "annual") {
    const start = +document.getElementById("acctRangeStart").value;
    const end = +document.getElementById("acctRangeEnd").value;
    const annualValues = [];
    const currentYearIndices = [];
    
    for (let y = start; y <= end; y++) {
      labels.push(y.toString());
      
      let monthly = getAccountMonthlyValues(acctNum, y, data);
      if (excludeCurrent && y === currentYear) {
        monthly = monthly.map((v, i) => i === currentMonth ? 0 : v);
      }
      const annualTotal = monthly.reduce((a, b) => a + b, 0);
      annualValues.push(annualTotal);
      
      if (y === currentYear) {
        hasPartialPeriod = true;
        currentYearIndices.push(annualValues.length - 1);
      }
    }
    
    datasets.push({
      label: `Account ${acctNum}`,
      data: annualValues,
      backgroundColor: function(context) {
        const chart = context.chart;
        const { ctx, chartArea } = chart;
        const dataIndex = context.dataIndex;
        // Use orange gradient for current year
        if (currentYearIndices.includes(dataIndex)) {
          return createBarGradient(ctx, chartArea, gradientColors.orange.start, gradientColors.orange.end);
        }
        return createBarGradient(ctx, chartArea, gradientColors.blue.start, gradientColors.blue.end);
      },
      borderRadius: 4,
      barPercentage: 0.9,
      categoryPercentage: 0.85
    });
    subtitle = `Annual – ${start} to ${end}`;
  }
  
  document.getElementById("acctChartTitleLine1").innerText = `${acctNum}: ${acctDesc}`;
  document.getElementById("acctChartTitleLine2").innerText = subtitle;
  
  const showTrendline = document.getElementById("acctTrendline").checked;
  if (showTrendline && datasets.length > 0) {
    const barDatasets = datasets.filter(ds => ds.type !== "line");
    const currentYearLabel = String(year);
    barDatasets.forEach((ds) => {
      if (compare && ds.label !== currentYearLabel && ds.label !== `Account ${acctNum}`) return;
      if (ds.data.length > 1) {
        const trendData = calculateTrendline(ds.data);
        datasets.push({
          label: `${ds.label} Trend`,
          data: trendData,
          type: "line",
          borderColor: "#10b981",
          backgroundColor: "transparent",
          borderWidth: 2,
          borderDash: [5, 5],
          pointRadius: 0,
          tension: 0,
          order: 0,
          datalabels: { display: false }
        });
      }
    });
  }
  
  renderAccountChart(labels, datasets);
  const tableDatasets = datasets.filter(ds => ds.type !== "line");
  renderAccountTable(labels, tableDatasets);
  
  const currentYearDataset = tableDatasets.find(ds => ds.label === String(year)) || tableDatasets[tableDatasets.length - 1];
  const currentValues = currentYearDataset ? currentYearDataset.data : [];
  
  let tileLabels = labels;
  if (view === "monthly") {
    tileLabels = labels.map(l => `${l} ${year}`);
  } else if (view === "quarterly") {
    tileLabels = labels.map(l => `${l} ${year}`);
  }
  updateSummaryTiles("acct", currentValues, tileLabels);
  
  const partialLegend = document.getElementById("acctPartialLegend");
  if (hasPartialPeriod) {
    partialLegend.classList.remove("hidden");
  } else {
    partialLegend.classList.add("hidden");
  }
  
  const timestamp = now.toLocaleDateString(undefined, {
    year: "numeric",
    month: "short",
    day: "numeric"
  });
  document.getElementById("acctChartUpdated").innerText = `Updated: ${timestamp}`;
}

function renderAccountChart(labels, datasets) {
  const canvas = document.getElementById("acctChart");
  if (!canvas) return;
  
  if (acctChartInstance) {
    acctChartInstance.destroy();
    acctChartInstance = null;
  }
  
  const ctx = canvas.getContext("2d");
  if (!ctx) return;
  
  const gradientPlugin = {
    id: 'gradientPlugin',
    beforeDraw: (chart) => applyGradientToDatasets(chart.data.datasets, chart)
  };
  
  const dataLabelsCheckbox = document.getElementById("acctDataLabels");
  const showDataLabels = dataLabelsCheckbox ? dataLabelsCheckbox.checked : false;
  
  // Calculate Y-axis minimum based on data
  let allValues = [];
  datasets.forEach(ds => {
    if (ds.type !== 'line' && ds.data) {
      allValues = allValues.concat(ds.data.filter(v => v !== null && v !== undefined && !isNaN(v)));
    }
  });
  const dataMin = allValues.length > 0 ? Math.min(...allValues) : 0;
  const dataMax = allValues.length > 0 ? Math.max(...allValues) : 0;
  
  // Calculate appropriate Y-axis min (start just below the lowest value)
  let yMin = undefined;
  if (dataMin > 0) {
    const range = dataMax - dataMin;
    // Use 15% of range as padding, or 10% of dataMin if flat data
    const padding = range > 0 ? range * 0.15 : dataMin * 0.1;
    
    let step;
    if (dataMin >= 1000000) {
      step = 100000;
    } else if (dataMin >= 100000) {
      step = 10000;
    } else if (dataMin >= 10000) {
      step = 5000;
    } else if (dataMin >= 1000) {
      step = 500;
    } else {
      step = 100;
    }
    yMin = Math.floor((dataMin - padding) / step) * step;
    if (yMin < 0) yMin = 0;
  }
  
  const themeColors = getChartThemeColors();
  
  acctChartInstance = new Chart(ctx, {
    type: "bar",
    data: { labels, datasets },
    plugins: [ChartDataLabels, gradientPlugin],
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: {
        duration: 800,
        easing: "easeOutQuart",
        delay: (context) => {
          let delay = 0;
          if (context.type === 'data' && context.mode === 'default') {
            delay = context.dataIndex * 40 + context.datasetIndex * 80;
          }
          return delay;
        }
      },
      transitions: {
        active: { animation: { duration: 200 } }
      },
      layout: {
        padding: { top: showDataLabels ? 30 : 0 }
      },
      plugins: {
        legend: { position: "bottom", labels: { color: themeColors.legendColor } },
        tooltip: {
          backgroundColor: "rgba(31, 41, 55, 0.95)",
          titleFont: { size: 13 },
          bodyFont: { size: 12 },
          padding: 10,
          callbacks: {
            title: function(tooltipItems) {
              return tooltipItems[0].label;
            },
            label: function(context) {
              if (context.dataset.type === "line") return null;
              const value = context.parsed.y;
              const prefix = context.dataset.label === acctSelectedYear.toString() ? "" : context.dataset.label + ": ";
              return prefix + "$" + value.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
          }
        },
        datalabels: {
          display: (context) => {
            if (!showDataLabels) return false;
            if (context.dataset.type === "line") return false;
            return true;
          },
          anchor: "end",
          align: "top",
          offset: 4,
          font: {
            size: 12,
            weight: "600"
          },
          color: function(context) {
            return context.dataset.borderColor || themeColors.textColor;
          },
          formatter: function(value) {
            if (value === 0 || value === null) return "";
            if (Math.abs(value) >= 1000000) {
              return "$" + (value / 1000000).toFixed(1) + "M";
            } else if (Math.abs(value) >= 1000) {
              return "$" + (value / 1000).toFixed(0) + "K";
            }
            return "$" + value.toLocaleString();
          }
        }
      },
      scales: {
        x: {
          grid: { drawOnChartArea: false, color: themeColors.gridColor },
          ticks: { color: themeColors.textColor }
        },
        y: {
          min: yMin,
          grid: { color: themeColors.gridColor },
          ticks: {
            color: themeColors.textColor,
            callback: v => {
              if (Math.abs(v) >= 1000000) {
                return "$" + (v / 1000000).toFixed(1) + "M";
              } else if (Math.abs(v) >= 1000) {
                return "$" + (v / 1000).toFixed(0) + "K";
              }
              return "$" + v.toLocaleString();
            }
          }
        }
      }
    }
  });
}

function renderAccountTable(labels, datasets) {
  const head = document.getElementById("acctTableHead");
  const body = document.getElementById("acctTableBody");
  
  const hasComparison = datasets.length > 1;
  
  let header = "<tr><th>Period</th>";
  datasets.forEach(ds => {
    header += `<th>${ds.label}</th>`;
  });
  if (hasComparison) {
    header += "<th>Change</th>";
  }
  header += "</tr>";
  head.innerHTML = header;
  
  body.innerHTML = labels.map((lbl, i) => {
    let row = `<tr><td>${lbl}</td>`;
    
    const values = datasets.map(ds => ds.data[i] || 0);
    
    datasets.forEach(ds => {
      const v = Math.round(ds.data[i] || 0);
      const formatted = v < 0 
        ? `<span class="growth-negative">($${Math.abs(v).toLocaleString()})</span>`
        : `$${v.toLocaleString()}`;
      row += `<td>${formatted}</td>`;
    });
    
    if (hasComparison && values.length >= 2) {
      const prior = values[0];
      const current = values[1];
      const change = prior > 0 ? ((current - prior) / prior * 100) : 0;
      const sign = change >= 0 ? "+" : "";
      const colorClass = change > 0 ? "growth-positive" : change < 0 ? "growth-negative" : "growth-neutral";
      row += `<td class="${colorClass}">${sign}${change.toFixed(1)}%</td>`;
    }
    
    row += "</tr>";
    return row;
  }).join("");
  
  const exportBtn = document.getElementById("acctTableExportBtn");
  if (exportBtn) {
    exportBtn.onclick = () => exportTableToCSV("acctTable", "account-breakdown");
  }
}

/* ============================================================
   INCOME STATEMENT MODULE
============================================================ */

function applyDetailLevel(level) {
  const summaryExpanded = [];
  
  const mediumExpanded = [
    "Revenue",
    "Total Cost of Sales",
    "Total Direct Expenses",
    "Total Indirect Expenses",
    "Operating Expenses",
    "Other Income/(Expense)",
    "Taxes"
  ];
  
  const accountExpanded = [
    "Revenue",
    "Total Cost of Sales",
    "Total Direct Expenses",
    "Total Indirect Expenses",
    "Direct Labor",
    "Indirect Labor",
    "Vehicle Expense",
    "Operating Expenses",
    "Salaries & Benefits",
    "Facility",
    "Travel & Entertainment",
    "Insurance",
    "Professional Services",
    "Administrative & Other",
    "Other Income/(Expense)",
    "Taxes"
  ];
  
  let expandedLabels = [];
  if (level === "summary") {
    expandedLabels = summaryExpanded;
  } else if (level === "medium") {
    expandedLabels = mediumExpanded;
  } else if (level === "account") {
    expandedLabels = accountExpanded;
  }
  
  Object.keys(isRowStates).forEach(key => {
    isRowStates[key] = false;
  });
  
  expandedLabels.forEach(label => {
    const rowId = `is-row-${label.replace(/\s+/g, '_')}`;
    isRowStates[rowId] = true;
  });
}

let isControlsInitialized = false;

async function loadIncomeStatement() {
  if (!isData || !isAccountGroups) {
    try {
      const [financialsRes, groupsRes] = await Promise.all([
        fetch("/data/financials_gl.json"),
        fetch("/data/account_groups.json")
      ]);
      isData = await financialsRes.json();
      isAccountGroups = await groupsRes.json();
      buildGLLookup();
    } catch (err) {
      console.error("Failed to load Income Statement data:", err);
      return;
    }
  }
  
  if (!isControlsInitialized) {
    initIncomeStatementControls();
    loadIncomeStatementConfig();
    // Re-populate period options after loading config (in case periodType changed)
    populatePeriodOptions();
    // Re-apply period select value after options are populated
    const prefs = getUserPreferences();
    const cfg = prefs.incomeStatementConfig || {};
    if (cfg.periodSelect) {
      const el = document.getElementById("isPeriodSelect");
      if (el && el.querySelector(`option[value="${cfg.periodSelect}"]`)) {
        el.value = cfg.periodSelect;
      }
    }
    isControlsInitialized = true;
  }
  
  renderIncomeStatement();
}

function buildGLLookup() {
  isGLLookup = {};
  const glHistory = isData.gl_history_all || [];
  
  glHistory.forEach(row => {
    const acctNum = parseInt(row.Account_Num || row.Account, 10);
    if (isNaN(acctNum)) return;
    
    if (!isGLLookup[acctNum]) {
      isGLLookup[acctNum] = {};
    }
    
    Object.keys(row).forEach(key => {
      if (/^\d{4}-\d{2}$/.test(key)) {
        const val = parseFloat(row[key]) || 0;
        isGLLookup[acctNum][key] = val;
      }
    });
  });
}

function initIncomeStatementControls() {
  const viewMode = document.getElementById("isViewMode");
  const singleControls = document.getElementById("isSingleControls");
  const matrixControls = document.getElementById("isMatrixControls");
  const periodType = document.getElementById("isPeriodType");
  const periodSelect = document.getElementById("isPeriodSelect");
  const showSubtotal = document.getElementById("isShowSubtotal");
  const matrixYearStart = document.getElementById("isMatrixYearStart");
  const matrixYearEnd = document.getElementById("isMatrixYearEnd");
  
  populatePeriodOptions();
  setupMatrixYearSliders();
  
  viewMode.onchange = () => {
    updateMatrixControlsVisibility();
    renderIncomeStatement();
    saveIncomeStatementConfig();
  };
  
  periodType.onchange = () => {
    populatePeriodOptions();
    updateMatrixControlsVisibility();
    renderIncomeStatement();
    saveIncomeStatementConfig();
  };
  
  periodSelect.onchange = () => { renderIncomeStatement(); saveIncomeStatementConfig(); };
  
  const compareRadios = document.querySelectorAll('input[name="isCompareRadio"]');
  compareRadios.forEach(radio => {
    radio.onchange = () => { renderIncomeStatement(); saveIncomeStatementConfig(); };
  });
  
  showSubtotal.onchange = () => { renderIncomeStatement(); saveIncomeStatementConfig(); };
  
  const showThousands = document.getElementById("isShowThousands");
  showThousands.onchange = () => { renderIncomeStatement(); saveIncomeStatementConfig(); };
  
  const excludeCurrent = document.getElementById("isExcludeCurrent");
  excludeCurrent.onchange = () => { 
    populatePeriodOptions();
    renderIncomeStatement(); 
    saveIncomeStatementConfig(); 
  };
  
  const waterfallDataLabels = document.getElementById("isWaterfallDataLabels");
  if (waterfallDataLabels) {
    waterfallDataLabels.onchange = () => { 
      renderIsWaterfallChart(); 
      saveIncomeStatementConfig(); 
    };
  }
  
  const detailRadios = document.querySelectorAll('input[name="isDetailLevel"]');
  detailRadios.forEach(radio => {
    radio.onchange = () => {
      applyDetailLevel(radio.value);
      renderIncomeStatement();
      saveIncomeStatementConfig();
    };
  });
  
  const initialDetail = document.querySelector('input[name="isDetailLevel"]:checked');
  applyDetailLevel(initialDetail ? initialDetail.value : 'summary');
  
  updateMatrixControlsVisibility();
  
  matrixYearStart.oninput = () => {
    document.getElementById("isMatrixYearStartLabel").textContent = matrixYearStart.value;
    if (parseInt(matrixYearStart.value) > parseInt(matrixYearEnd.value)) {
      matrixYearEnd.value = matrixYearStart.value;
      document.getElementById("isMatrixYearEndLabel").textContent = matrixYearEnd.value;
    }
    renderIncomeStatement();
  };
  
  matrixYearEnd.oninput = () => {
    document.getElementById("isMatrixYearEndLabel").textContent = matrixYearEnd.value;
    if (parseInt(matrixYearEnd.value) < parseInt(matrixYearStart.value)) {
      matrixYearStart.value = matrixYearEnd.value;
      document.getElementById("isMatrixYearStartLabel").textContent = matrixYearStart.value;
    }
    renderIncomeStatement();
  };
  
  // Initialize AI Analysis button
  initAiAnalysis();
}

function initAiAnalysis() {
  const analyzeBtn = document.getElementById("isAiAnalyzeBtn");
  const panel = document.getElementById("isAiAnalysisPanel");
  const header = document.getElementById("isAiAnalysisHeader");
  
  if (analyzeBtn) {
    analyzeBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      performAiAnalysis();
    });
  }
  
  if (header) {
    header.addEventListener("click", (e) => {
      if (e.target === analyzeBtn || analyzeBtn.contains(e.target)) return;
      panel.classList.toggle("collapsed");
    });
  }
}

async function performAiAnalysis() {
  const analyzeBtn = document.getElementById("isAiAnalyzeBtn");
  const panel = document.getElementById("isAiAnalysisPanel");
  const contentContainer = document.getElementById("isAiAnalysisContent");
  
  // Show loading state
  analyzeBtn.disabled = true;
  analyzeBtn.textContent = 'Analyzing...';
  panel.classList.remove("collapsed");
  contentContainer.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div>Analyzing your financial data...</div>';
  
  try {
    // Extract the current Income Statement data
    const statementData = extractIncomeStatementData();
    const periodInfo = getIncomeStatementPeriodInfo();
    
    // Detect environment: use Netlify Functions if on Netlify or custom domain (not Replit), otherwise use local Flask API
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit 
      ? "/api/analyze-income-statement"
      : "/.netlify/functions/analyze-income-statement";
    
    const response = await fetch(apiUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ statementData, periodInfo })
    });
    
    const result = await response.json();
    
    if (result.success && result.analysis) {
      contentContainer.innerHTML = formatMarkdown(result.analysis);
      panel.classList.add('has-analysis');
    } else {
      contentContainer.innerHTML = `<div style="color: #dc2626;">Error: ${result.error || "Failed to get analysis"}</div>`;
    }
  } catch (error) {
    console.error("AI Analysis error:", error);
    contentContainer.innerHTML = `<div style="color: #dc2626;">Error: ${error.message || "Failed to connect to AI service"}</div>`;
  } finally {
    analyzeBtn.disabled = false;
    analyzeBtn.textContent = 'Run Analysis';
  }
}

function extractIncomeStatementData() {
  const table = document.getElementById("incomeStatementTable");
  if (!table) return "";
  
  let text = "";
  const rows = table.querySelectorAll("tr");
  
  rows.forEach(row => {
    if (row.classList.contains("is-spacer-row")) return;
    if (row.classList.contains("is-row-hidden")) return;
    
    const cells = row.querySelectorAll("th, td");
    const rowData = [];
    cells.forEach(cell => {
      let cellText = cell.textContent.trim();
      rowData.push(cellText);
    });
    text += rowData.join("\t") + "\n";
  });
  
  return text;
}

function getIncomeStatementPeriodInfo() {
  const viewMode = document.getElementById("isViewMode").value;
  const periodType = document.getElementById("isPeriodType").value;
  const periodSelect = document.getElementById("isPeriodSelect");
  const compare = document.querySelector('input[name="isCompareRadio"]:checked');
  
  let info = "";
  
  if (viewMode === "single") {
    info = `${periodType.toUpperCase()}: ${periodSelect.options[periodSelect.selectedIndex]?.text || ""}`;
  } else {
    if (periodType === "year") {
      const startYear = document.getElementById("isMatrixYearStart").value;
      const endYear = document.getElementById("isMatrixYearEnd").value;
      info = `Annual Matrix: ${startYear} - ${endYear}`;
    } else {
      info = `${periodType.toUpperCase()} Matrix: ${periodSelect.options[periodSelect.selectedIndex]?.text || ""}`;
    }
  }
  
  if (compare && compare.value !== "none") {
    info += ` (compared to ${compare.value.replace("_", " ")})`;
  }
  
  return info;
}

function formatMarkdown(text) {
  // Format dollar amounts to use K and M notation
  text = formatDollarAmounts(text);
  
  const lines = text.split('\n');
  let html = '';
  let inList = false;
  
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i].trim();
    if (!line) continue;
    
    // Apply inline formatting
    line = line
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>');
    
    // Headers
    if (line.startsWith('### ')) {
      if (inList) { html += '</ul>'; inList = false; }
      html += '<h3>' + line.slice(4) + '</h3>';
    } else if (line.startsWith('## ')) {
      if (inList) { html += '</ul>'; inList = false; }
      html += '<h2>' + line.slice(3) + '</h2>';
    } else if (line.startsWith('# ')) {
      if (inList) { html += '</ul>'; inList = false; }
      html += '<h1>' + line.slice(2) + '</h1>';
    }
    // Bullet points
    else if (/^[-*]\s+/.test(line)) {
      if (!inList) { html += '<ul>'; inList = true; }
      html += '<li>' + line.replace(/^[-*]\s+/, '') + '</li>';
    }
    // Numbered lists
    else if (/^\d+\.\s+/.test(line)) {
      if (!inList) { html += '<ul>'; inList = true; }
      html += '<li>' + line.replace(/^\d+\.\s+/, '') + '</li>';
    }
    // Regular text - skip if empty or just whitespace
    else {
      if (inList) { html += '</ul>'; inList = false; }
      html += '<p>' + line + '</p>';
    }
  }
  
  if (inList) html += '</ul>';
  
  return html;
}

function formatDollarAmounts(text) {
  // Match dollar amounts with optional K/M/B suffix
  // Handles: $3,844K, $3.8K, $50,310K, $1,234,567, $1234, etc.
  return text.replace(/\$\s*([\d,]+(?:\.\d+)?)\s*([KkMmBb])?(?![KkMmBb])/g, (match, numStr, suffix) => {
    // Remove commas and parse
    let num = parseFloat(numStr.replace(/,/g, ''));
    if (isNaN(num)) return match;
    
    // Convert to actual value based on existing suffix
    if (suffix) {
      const s = suffix.toUpperCase();
      if (s === 'K') num *= 1000;
      else if (s === 'M') num *= 1000000;
      else if (s === 'B') num *= 1000000000;
    }
    
    const absNum = Math.abs(num);
    const sign = num < 0 ? '-' : '';
    
    if (absNum >= 1000000) {
      return sign + '$' + (absNum / 1000000).toFixed(1) + 'M';
    } else if (absNum >= 1000) {
      return sign + '$' + (absNum / 1000).toFixed(1) + 'K';
    }
    return sign + '$' + Math.round(absNum);
  });
}

function updateMatrixControlsVisibility() {
  const viewMode = document.getElementById("isViewMode").value;
  const periodType = document.getElementById("isPeriodType").value;
  const periodTypeSelect = document.getElementById("isPeriodType");
  const yearControls = document.getElementById("isMatrixYearControls");
  const singleControls = document.getElementById("isSingleControls");
  const matrixControls = document.getElementById("isMatrixControls");
  const periodSelectLabel = document.getElementById("isPeriodSelectLabel");
  const periodSelect = document.getElementById("isPeriodSelect");
  const showSubtotalWrapper = document.getElementById("isShowSubtotalWrapper");
  
  const ytdOption = periodTypeSelect.querySelector('option[value="ytd"]');
  const ttmOption = periodTypeSelect.querySelector('option[value="ttm"]');
  
  if (viewMode === "matrix") {
    singleControls.classList.add("hidden");
    matrixControls.classList.remove("hidden");
    if (showSubtotalWrapper) showSubtotalWrapper.classList.remove("hidden");
    
    if (ytdOption) ytdOption.disabled = true;
    if (ttmOption) ttmOption.disabled = true;
    
    if (periodType === "ytd" || periodType === "ttm") {
      periodTypeSelect.value = "month";
      populatePeriodOptions();
    }
    
    if (periodType === "year") {
      yearControls.classList.remove("hidden");
      periodSelect.classList.add("hidden");
      if (periodSelectLabel) periodSelectLabel.classList.add("hidden");
    } else {
      yearControls.classList.add("hidden");
      periodSelect.classList.remove("hidden");
      if (periodSelectLabel) periodSelectLabel.classList.remove("hidden");
      
      if (periodType === "quarter" || periodType === "month") {
        populateMatrixYearOptions();
      }
    }
  } else {
    singleControls.classList.remove("hidden");
    matrixControls.classList.add("hidden");
    periodSelect.classList.remove("hidden");
    if (periodSelectLabel) periodSelectLabel.classList.remove("hidden");
    if (showSubtotalWrapper) showSubtotalWrapper.classList.add("hidden");
    
    if (ytdOption) ytdOption.disabled = false;
    if (ttmOption) ttmOption.disabled = false;
  }
}

function populateMatrixYearOptions() {
  const periodSelect = document.getElementById("isPeriodSelect");
  const months = getAvailableMonths();
  const years = new Set();
  months.forEach(m => years.add(m.split("-")[0]));
  
  periodSelect.innerHTML = Array.from(years).sort().reverse().map(y => 
    `<option value="${y}">${y}</option>`
  ).join("");
}

function setupMatrixYearSliders() {
  const months = getAvailableMonths();
  const years = new Set();
  months.forEach(m => years.add(m.split("-")[0]));
  const sortedYears = Array.from(years).sort();
  
  if (sortedYears.length > 0) {
    const minYear = sortedYears[0];
    const maxYear = sortedYears[sortedYears.length - 1];
    
    const startSlider = document.getElementById("isMatrixYearStart");
    const endSlider = document.getElementById("isMatrixYearEnd");
    
    startSlider.min = minYear;
    startSlider.max = maxYear;
    startSlider.value = Math.max(minYear, maxYear - 5);
    
    endSlider.min = minYear;
    endSlider.max = maxYear;
    endSlider.value = maxYear;
    
    document.getElementById("isMatrixYearStartLabel").textContent = startSlider.value;
    document.getElementById("isMatrixYearEndLabel").textContent = endSlider.value;
  }
}

function populatePeriodOptions() {
  const periodType = document.getElementById("isPeriodType").value;
  const periodSelect = document.getElementById("isPeriodSelect");
  
  // Get months with exclude filter applied for dropdowns
  const months = getAvailableMonths(true);
  if (months.length === 0) return;
  
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth() + 1;
  
  let options = [];
  
  if (periodType === "month") {
    months.slice().reverse().forEach(m => {
      const [y, mo] = m.split("-");
      const monthName = new Date(y, mo - 1).toLocaleString("default", { month: "short" });
      options.push({ value: m, label: `${monthName} ${y}` });
    });
  } else if (periodType === "quarter") {
    const quarters = new Set();
    months.forEach(m => {
      const [y, mo] = m.split("-").map(Number);
      const q = Math.ceil(mo / 3);
      quarters.add(`${y}-Q${q}`);
    });
    Array.from(quarters).sort().reverse().forEach(q => {
      options.push({ value: q, label: q });
    });
  } else if (periodType === "year") {
    const years = new Set();
    months.forEach(m => years.add(m.split("-")[0]));
    Array.from(years).sort().reverse().forEach(y => {
      options.push({ value: y, label: y });
    });
  } else if (periodType === "ytd") {
    const years = new Set();
    months.forEach(m => years.add(m.split("-")[0]));
    Array.from(years).sort().reverse().forEach(y => {
      for (let mo = 12; mo >= 1; mo--) {
        const key = `${y}-${String(mo).padStart(2, "0")}`;
        if (months.includes(key)) {
          const monthName = new Date(y, mo - 1).toLocaleString("default", { month: "short" });
          options.push({ value: `${y}-YTD-${mo}`, label: `YTD ${monthName} ${y}` });
          break;
        }
      }
    });
  } else if (periodType === "ttm") {
    months.slice(-24).reverse().forEach(m => {
      const [y, mo] = m.split("-");
      const monthName = new Date(y, mo - 1).toLocaleString("default", { month: "short" });
      options.push({ value: `TTM-${m}`, label: `TTM ending ${monthName} ${y}` });
    });
  }
  
  periodSelect.innerHTML = options.map(o => 
    `<option value="${o.value}">${o.label}</option>`
  ).join("");
}

function getAvailableMonths(respectExclude = false) {
  const allMonths = new Set();
  Object.values(isGLLookup).forEach(acctData => {
    Object.keys(acctData).forEach(k => {
      if (/^\d{4}-\d{2}$/.test(k)) allMonths.add(k);
    });
  });
  let months = Array.from(allMonths).sort();
  
  // Filter out current month if exclude is checked
  if (respectExclude) {
    const excludeCurrent = document.getElementById("isExcludeCurrent")?.checked;
    if (excludeCurrent) {
      const currentMonthKey = getCurrentMonthKey();
      months = months.filter(m => m !== currentMonthKey);
    }
  }
  return months;
}

function getCurrentMonthKey() {
  const now = new Date();
  const y = now.getFullYear();
  const m = now.getMonth() + 1;
  return `${y}-${String(m).padStart(2, "0")}`;
}

function getPeriodMonths(periodValue, periodType) {
  const months = getAvailableMonths();
  const excludeCurrent = document.getElementById("isExcludeCurrent")?.checked;
  const currentMonthKey = getCurrentMonthKey();
  
  let result = [];
  
  if (periodType === "month") {
    result = [periodValue];
  } else if (periodType === "quarter") {
    const [y, qStr] = periodValue.split("-Q");
    const q = parseInt(qStr);
    const startMonth = (q - 1) * 3 + 1;
    for (let m = startMonth; m < startMonth + 3; m++) {
      const key = `${y}-${String(m).padStart(2, "0")}`;
      if (months.includes(key)) result.push(key);
    }
  } else if (periodType === "year") {
    result = months.filter(m => m.startsWith(periodValue + "-"));
  } else if (periodType === "ytd") {
    const parts = periodValue.split("-YTD-");
    const y = parts[0];
    const endMonth = parseInt(parts[1]);
    for (let m = 1; m <= endMonth; m++) {
      const key = `${y}-${String(m).padStart(2, "0")}`;
      if (months.includes(key)) result.push(key);
    }
  } else if (periodType === "ttm") {
    const endMonth = periodValue.replace("TTM-", "");
    const endIdx = months.indexOf(endMonth);
    if (endIdx < 0) return [];
    const startIdx = Math.max(0, endIdx - 11);
    result = months.slice(startIdx, endIdx + 1);
  }
  
  if (excludeCurrent) {
    result = result.filter(m => m !== currentMonthKey);
  }
  
  return result;
}

function getMatrixPeriods(matrixCount) {
  const months = getAvailableMonths();
  const periods = [];
  
  if (matrixCount.endsWith("m")) {
    const count = parseInt(matrixCount);
    const recent = months.slice(-count);
    recent.forEach(m => {
      periods.push({ label: formatMonthLabel(m), months: [m] });
    });
  } else if (matrixCount === "4q") {
    const quarters = [];
    months.forEach(m => {
      const [y, mo] = m.split("-").map(Number);
      const q = Math.ceil(mo / 3);
      const qKey = `${y}-Q${q}`;
      if (!quarters.find(x => x.key === qKey)) {
        quarters.push({ key: qKey, months: [] });
      }
      quarters.find(x => x.key === qKey).months.push(m);
    });
    quarters.slice(-4).forEach(q => {
      periods.push({ label: q.key, months: q.months });
    });
  } else if (matrixCount === "5y") {
    const years = [...new Set(months.map(m => m.split("-")[0]))];
    years.slice(-5).forEach(y => {
      const yMonths = months.filter(m => m.startsWith(y + "-"));
      periods.push({ label: y, months: yMonths });
    });
  }
  
  return periods;
}

function formatMonthLabel(m) {
  const [y, mo] = m.split("-");
  const monthName = new Date(y, mo - 1).toLocaleString("default", { month: "short" });
  return `${monthName} ${y}`;
}

function sumAccountsForPeriod(accounts, periodMonths, isRange = false) {
  let total = 0;
  
  let acctList = [];
  if (isRange && accounts.length === 2) {
    const [start, end] = accounts;
    Object.keys(isGLLookup).forEach(acct => {
      const num = parseInt(acct);
      if (num >= start && num <= end) acctList.push(num);
    });
  } else {
    acctList = accounts;
  }
  
  acctList.forEach(acct => {
    const acctData = isGLLookup[acct];
    if (acctData) {
      periodMonths.forEach(m => {
        total += acctData[m] || 0;
      });
    }
  });
  
  return total;
}

function buildIncomeStatementRows(periodMonths, groups, computedValues = {}) {
  const rows = [];
  
  groups.forEach((group, idx) => {
    const rowId = `is-row-${group.label.replace(/\s+/g, '_')}`;
    let value = null;
    
    if (group.accounts) {
      value = sumAccountsForPeriod(group.accounts, periodMonths, false);
      if (group.negate) {
        value = -value;
      } else if (isIncomeAccountGroup(group)) {
        value = Math.abs(value);
      }
    } else if (group.accounts_range) {
      value = sumAccountsForPeriod(group.accounts_range, periodMonths, true);
      if (group.negate) {
        value = -value;
      } else if (isIncomeAccountGroup(group)) {
        value = Math.abs(value);
      }
    } else if (group.formula) {
      value = evaluateFormula(group.formula, computedValues);
    }
    
    computedValues[group.label] = value;
    
    if (group.expandable) {
      if (isRowStates[rowId] === undefined) {
        isRowStates[rowId] = false;
      }
    }
    
    if (group.type === "spacer") {
      rows.push({
        id: `spacer-${idx}`,
        label: "",
        level: 0,
        type: "spacer",
        value: null,
        expandable: false,
        parent: null,
        highlight: null,
        isIncome: false
      });
    } else {
      rows.push({
        id: rowId,
        label: group.label,
        level: group.level || 0,
        type: group.type,
        value: value,
        expandable: group.expandable || false,
        parent: group.parent || null,
        highlight: group.highlight || null,
        isIncome: group.isIncome || false
      });
      
      if (group.label === "Revenue" || group.label === "Total Cost of Sales") {
        rows.push({
          id: `spacer-after-${group.label.replace(/\s+/g, '_')}`,
          label: "",
          level: 0,
          type: "spacer",
          value: null,
          expandable: false,
          parent: null,
          highlight: null,
          isIncome: false
        });
      }
    }
  });
  
  return rows;
}

function isIncomeAccountGroup(group) {
  if (group.accounts) {
    return group.accounts.some(a => (a >= 4000 && a < 5000) || (a >= 8000 && a < 9000));
  }
  if (group.accounts_range) {
    const [start, end] = group.accounts_range;
    return (start >= 4000 && end < 5000) || (start >= 8000 && end < 9000);
  }
  return false;
}

function hasChildRows(groups, idx) {
  const currentLevel = groups[idx].level;
  for (let i = idx + 1; i < groups.length; i++) {
    if (groups[i].level <= currentLevel) return false;
    if (groups[i].level > currentLevel) return true;
  }
  return false;
}

function evaluateFormula(formula, computedValues) {
  let expr = formula;
  
  Object.keys(computedValues).sort((a, b) => b.length - a.length).forEach(label => {
    const val = computedValues[label] || 0;
    expr = expr.split(label).join(`(${val})`);
  });
  
  try {
    expr = expr.replace(/[^0-9+\-*/().]/g, "");
    return eval(expr) || 0;
  } catch (e) {
    console.error("Formula eval error:", formula, e);
    return 0;
  }
}

function getPriorPeriod(periodValue, periodType) {
  const months = getAvailableMonths();
  
  if (periodType === "month") {
    const idx = months.indexOf(periodValue);
    return idx > 0 ? months[idx - 1] : null;
  } else if (periodType === "quarter") {
    const [y, qStr] = periodValue.split("-Q");
    const q = parseInt(qStr);
    if (q > 1) return `${y}-Q${q - 1}`;
    return `${parseInt(y) - 1}-Q4`;
  } else if (periodType === "year") {
    return String(parseInt(periodValue) - 1);
  } else if (periodType === "ytd") {
    const parts = periodValue.split("-YTD-");
    return `${parseInt(parts[0]) - 1}-YTD-${parts[1]}`;
  } else if (periodType === "ttm") {
    const endMonth = periodValue.replace("TTM-", "");
    const idx = months.indexOf(endMonth);
    if (idx >= 12) {
      return `TTM-${months[idx - 1]}`;
    }
    return null;
  }
  return null;
}

function getPriorYearPeriod(periodValue, periodType) {
  if (periodType === "month") {
    const [y, mo] = periodValue.split("-");
    return `${parseInt(y) - 1}-${mo}`;
  } else if (periodType === "quarter") {
    const [y, q] = periodValue.split("-Q");
    return `${parseInt(y) - 1}-Q${q}`;
  } else if (periodType === "year") {
    return String(parseInt(periodValue) - 1);
  } else if (periodType === "ytd") {
    const parts = periodValue.split("-YTD-");
    return `${parseInt(parts[0]) - 1}-YTD-${parts[1]}`;
  } else if (periodType === "ttm") {
    const endMonth = periodValue.replace("TTM-", "");
    const [y, mo] = endMonth.split("-");
    return `TTM-${parseInt(y) - 1}-${mo}`;
  }
  return null;
}

function formatAccountingNumber(value) {
  if (value === null || value === undefined) return "";
  const showThousands = document.getElementById("isShowThousands")?.checked;
  const rounded = Math.round(value);
  
  if (showThousands) {
    const inK = Math.round(rounded / 1000);
    if (rounded < 0) {
      return `<span class="is-negative">($${Math.abs(inK).toLocaleString()}K)</span>`;
    }
    return `$${inK.toLocaleString()}K`;
  } else {
    if (rounded < 0) {
      return `<span class="is-negative">($${Math.abs(rounded).toLocaleString()})</span>`;
    }
    return `$${rounded.toLocaleString()}`;
  }
}

function formatPercent(value) {
  if (value === null || value === undefined || !isFinite(value)) return "";
  return `${(value * 100).toFixed(1)}%`;
}

function formatVariance(current, prior, isIncome) {
  const showThousands = document.getElementById("isShowThousands")?.checked;
  const diff = current - prior;
  const pct = prior !== 0 ? ((current - prior) / Math.abs(prior)) * 100 : 0;
  
  const isPositiveVariance = isIncome ? diff >= 0 : diff <= 0;
  const colorClass = isPositiveVariance ? "is-variance-positive" : "is-variance-negative";
  
  let diffFormatted;
  if (showThousands) {
    const diffK = Math.round(Math.abs(Math.round(diff)) / 1000);
    diffFormatted = diff < 0 
      ? `<span class="${colorClass}">($${diffK.toLocaleString()}K)</span>`
      : `<span class="${colorClass}">$${diffK.toLocaleString()}K</span>`;
  } else {
    diffFormatted = diff < 0 
      ? `<span class="${colorClass}">($${Math.abs(Math.round(diff)).toLocaleString()})</span>`
      : `<span class="${colorClass}">$${Math.round(diff).toLocaleString()}</span>`;
  }
  
  const pctFormatted = `<span class="${colorClass}">${pct.toLocaleString(undefined, {minimumFractionDigits: 1, maximumFractionDigits: 1})}%</span>`;
  
  return { diff: diffFormatted, pct: pctFormatted };
}

function formatPeriodLabel(periodValue, periodType, includePartialIndicator = false) {
  let label = "";
  let isPartial = false;
  
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth() + 1;
  const currentQuarter = Math.ceil(currentMonth / 3);
  
  if (periodType === "month") {
    const [y, mo] = periodValue.split("-").map(Number);
    const monthName = new Date(y, mo - 1).toLocaleString("default", { month: "short" });
    label = `${monthName} ${y}`;
    isPartial = (y === currentYear && mo === currentMonth);
  } else if (periodType === "quarter") {
    const [y, qStr] = periodValue.split("-Q");
    const q = parseInt(qStr);
    label = periodValue;
    isPartial = (parseInt(y) === currentYear && q === currentQuarter);
  } else if (periodType === "year") {
    label = `FY ${periodValue}`;
    isPartial = (parseInt(periodValue) === currentYear);
  } else if (periodType === "ytd") {
    const parts = periodValue.split("-YTD-");
    const monthName = new Date(parts[0], parseInt(parts[1]) - 1).toLocaleString("default", { month: "short" });
    label = `YTD ${monthName} ${parts[0]}`;
    isPartial = (parseInt(parts[0]) === currentYear);
  } else if (periodType === "ttm") {
    const endMonth = periodValue.replace("TTM-", "");
    const [y, mo] = endMonth.split("-").map(Number);
    const monthName = new Date(y, mo - 1).toLocaleString("default", { month: "short" });
    label = `TTM ${monthName} ${y}`;
    isPartial = (y === currentYear && mo === currentMonth);
  } else {
    label = periodValue;
  }
  
  if (includePartialIndicator && isPartial) {
    return `${label}<span class="is-partial-indicator">*</span>`;
  }
  return label;
}

function isPartialPeriod(periodValue, periodType) {
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth() + 1;
  const currentQuarter = Math.ceil(currentMonth / 3);
  
  if (periodType === "month") {
    const [y, mo] = periodValue.split("-").map(Number);
    return (y === currentYear && mo === currentMonth);
  } else if (periodType === "quarter") {
    const [y, qStr] = periodValue.split("-Q");
    return (parseInt(y) === currentYear && parseInt(qStr) === currentQuarter);
  } else if (periodType === "year") {
    return (parseInt(periodValue) === currentYear);
  }
  return false;
}

function updateReportHeader(statementType) {
  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  let periodText = "";
  
  if (statementType === "is") {
    const viewMode = document.getElementById("isViewMode")?.value || "single";
    const periodType = document.getElementById("isPeriodType")?.value || "month";
    const periodValue = document.getElementById("isPeriodSelect")?.value || "";
    const compare = document.querySelector('input[name="isCompareRadio"]:checked')?.value || "none";
    
    if (viewMode === "matrix") {
      const yearStart = document.getElementById("isMatrixYearStart")?.value;
      const yearEnd = document.getElementById("isMatrixYearEnd")?.value;
      const year = periodValue;
      
      if (periodType === "year") {
        periodText = `Annual, ${yearStart} - ${yearEnd}`;
      } else if (periodType === "quarter") {
        periodText = `Quarterly, ${year}`;
      } else {
        periodText = `Monthly, ${year}`;
      }
    } else {
      const currentLabel = formatPeriodLabel(periodValue, periodType, false);
      if (compare !== "none") {
        let compPeriod;
        if (compare === "prior_period") {
          compPeriod = getPriorPeriod(periodValue, periodType);
        } else {
          compPeriod = getPriorYearPeriod(periodValue, periodType);
        }
        if (compPeriod) {
          const compLabel = formatPeriodLabel(compPeriod, periodType, false);
          periodText = `${currentLabel} vs ${compLabel}`;
        } else {
          periodText = currentLabel;
        }
      } else {
        periodText = currentLabel;
      }
    }
    
    const periodEl = document.getElementById("isReportPeriod");
    if (periodEl) periodEl.textContent = periodText;
    
  } else if (statementType === "bs") {
    const viewMode = document.getElementById("bsViewMode")?.value || "single";
    const periodValue = document.getElementById("bsPeriodSelect")?.value || "";
    const compare = document.querySelector('input[name="bsCompareRadio"]:checked')?.value || "none";
    const periodType = document.getElementById("bsPeriodType")?.value || "month";
    
    if (viewMode === "matrix") {
      const yearStart = document.getElementById("bsMatrixYearStart")?.value;
      const yearEnd = document.getElementById("bsMatrixYearEnd")?.value;
      const year = document.getElementById("bsMatrixYear")?.value;
      
      if (periodType === "annual") {
        periodText = `Annual, ${yearStart} - ${yearEnd}`;
      } else if (periodType === "quarter") {
        periodText = `Quarterly, ${year}`;
      } else {
        periodText = `Monthly, ${year}`;
      }
    } else {
      if (periodValue) {
        const [y, mo] = periodValue.split("-");
        const currentLabel = `As of ${monthNames[parseInt(mo) - 1]} ${y}`;
        
        if (compare === "prior_year") {
          const priorYear = parseInt(y) - 1;
          periodText = `${currentLabel} vs ${monthNames[parseInt(mo) - 1]} ${priorYear}`;
        } else if (compare === "prior_month") {
          const availableMonths = getBSAvailableMonths();
          const periodIdx = availableMonths.indexOf(periodValue);
          if (periodIdx > 0) {
            const priorPeriod = availableMonths[periodIdx - 1];
            const [py, pm] = priorPeriod.split("-");
            periodText = `${currentLabel} vs ${monthNames[parseInt(pm) - 1]} ${py}`;
          } else {
            periodText = currentLabel;
          }
        } else {
          periodText = currentLabel;
        }
      }
    }
    
    const periodEl = document.getElementById("bsReportPeriod");
    if (periodEl) periodEl.textContent = periodText;
    
  } else if (statementType === "cf") {
    const viewMode = document.getElementById("cfViewMode")?.value || "single";
    const periodType = document.getElementById("cfPeriodType")?.value || "month";
    const periodValue = document.getElementById("cfPeriodSelect")?.value || "";
    const compare = document.querySelector('input[name="cfCompareRadio"]:checked')?.value || "none";
    
    if (viewMode === "matrix") {
      const yearStart = document.getElementById("cfMatrixYearStart")?.value;
      const yearEnd = document.getElementById("cfMatrixYearEnd")?.value;
      const year = periodValue;
      
      if (periodType === "year") {
        periodText = `Annual, ${yearStart} - ${yearEnd}`;
      } else if (periodType === "quarter") {
        periodText = `Quarterly, ${year}`;
      } else {
        periodText = `Monthly, ${year}`;
      }
    } else {
      const currentLabel = formatPeriodLabel(periodValue, periodType, false);
      if (compare !== "none" && currentLabel) {
        let compPeriod;
        if (compare === "prior_period") {
          compPeriod = getCFPriorPeriod(periodValue, periodType);
        } else {
          compPeriod = getCFPriorYearPeriod(periodValue, periodType);
        }
        if (compPeriod) {
          const compLabel = formatPeriodLabel(compPeriod, periodType, false);
          periodText = `${currentLabel} vs ${compLabel}`;
        } else {
          periodText = currentLabel;
        }
      } else {
        periodText = currentLabel;
      }
    }
    
    const periodEl = document.getElementById("cfReportPeriod");
    if (periodEl) periodEl.textContent = periodText;
  }
}

function showTableLoading(tableId, message = 'Loading...') {
  const table = document.getElementById(tableId);
  if (!table) return;
  
  const container = table.closest('.is-table-box, .bs-table-box, .cf-table-box') || table.parentElement;
  if (!container) return;
  
  container.style.position = 'relative';
  
  // Remove existing overlay if present
  const existing = container.querySelector('.table-loading-overlay');
  if (existing) existing.remove();
  
  const overlay = document.createElement('div');
  overlay.className = 'table-loading-overlay';
  overlay.innerHTML = `<div class="spinner"></div><div class="loading-text">${message}</div>`;
  container.appendChild(overlay);
}

function hideTableLoading(tableId) {
  const table = document.getElementById(tableId);
  if (!table) return;
  
  const container = table.closest('.is-table-box, .bs-table-box, .cf-table-box') || table.parentElement;
  if (!container) return;
  
  const overlay = container.querySelector('.table-loading-overlay');
  if (overlay) {
    overlay.classList.add('fade-out');
    setTimeout(() => overlay.remove(), 300);
  }
}

function renderIncomeStatement() {
  showTableLoading('incomeStatementTable', 'Updating...');
  
  // Use requestAnimationFrame to allow loading indicator to show
  requestAnimationFrame(() => {
    const viewMode = document.getElementById("isViewMode").value;
    const periodType = document.getElementById("isPeriodType").value;
    const periodValue = document.getElementById("isPeriodSelect").value;
    const groups = isAccountGroups.income_statement.groups;
    const thead = document.getElementById("isTableHead");
    const tbody = document.getElementById("isTableBody");
    const footnote = document.getElementById("isPartialFootnote");
    
    updateReportHeader("is");
    
    let hasPartialPeriod = false;
    
    if (viewMode === "matrix") {
      const showSubtotal = document.getElementById("isShowSubtotal").checked;
      const yearStart = document.getElementById("isMatrixYearStart").value;
      const yearEnd = document.getElementById("isMatrixYearEnd").value;
      
      let selectedYear = periodValue;
      
      hasPartialPeriod = renderMatrixView(groups, periodType, selectedYear, yearStart, yearEnd, showSubtotal, thead, tbody);
    } else {
      const compare = document.querySelector('input[name="isCompareRadio"]:checked')?.value || "none";
      hasPartialPeriod = renderSinglePeriodView(groups, periodType, periodValue, compare, thead, tbody);
    }
    
    if (footnote) {
      if (hasPartialPeriod) {
        footnote.classList.remove("hidden");
      } else {
        footnote.classList.add("hidden");
      }
    }
    
    setTimeout(() => {
      autoSizeFirstColumn("incomeStatementTable");
      addResizeHandlesToTable("incomeStatementTable");
      autoScaleFontSize("incomeStatementTable", "isTableBox");
      hideTableLoading('incomeStatementTable');
      // Render waterfall chart (only shows in single period mode) - use longer delay for reliable init
      setTimeout(() => renderIsWaterfallChart(), 100);
    }, 50);
  });
}

function renderSinglePeriodView(groups, periodType, periodValue, compare, thead, tbody) {
  const periodMonths = getPeriodMonths(periodValue, periodType);
  const rows = buildIncomeStatementRows(periodMonths, groups);
  const currentLabel = formatPeriodLabel(periodValue, periodType, true);
  
  let comparisonRows = null;
  let compPeriodLabel = "";
  let compPeriod = null;
  
  if (compare !== "none") {
    if (compare === "prior_period") {
      compPeriod = getPriorPeriod(periodValue, periodType);
    } else {
      compPeriod = getPriorYearPeriod(periodValue, periodType);
    }
    
    if (compPeriod) {
      compPeriodLabel = formatPeriodLabel(compPeriod, periodType, true);
      const compMonths = getPeriodMonths(compPeriod, periodType);
      comparisonRows = buildIncomeStatementRows(compMonths, groups);
    }
  }
  
  let headerHtml = "<tr><th>Account</th>";
  if (comparisonRows) {
    headerHtml += `<th>${compPeriodLabel}</th><th>${currentLabel}</th><th class="var-col-left">$ Var</th><th>% Var</th>`;
  } else {
    headerHtml += `<th>${currentLabel}</th>`;
  }
  headerHtml += "</tr>";
  thead.innerHTML = headerHtml;
  
  let bodyHtml = "";
  const colCount = comparisonRows ? 5 : 2;
  
  rows.forEach((row, i) => {
    if (row.type === "spacer") {
      bodyHtml += `<tr class="is-spacer-row"><td colspan="${colCount}"></td></tr>`;
      return;
    }
    
    const majorTotalLabels = ["Revenue", "Total Cost of Sales", "Gross Profit", "Operating Expenses", "Operating Income", "Net Profit Before Taxes", "Net Profit After Taxes"];
    const isMajorTotal = majorTotalLabels.includes(row.label);
    const profitRowLabels = ["Revenue", "Gross Profit", "Operating Income", "Net Profit Before Taxes", "Net Profit After Taxes"];
    const expenseSectionLabels = ["Total Cost of Sales", "Operating Expenses", "Taxes", "Other Income/Expense"];
    const graySectionLabels = ["Total Direct Expenses", "Total Indirect Expenses"];
    const tanSectionLabels = ["Direct Labor", "Indirect Labor", "Vehicle Expense"];
    const opExpenseGrayLabels = ["Salaries & Benefits", "Facility", "Travel & Entertainment", "Insurance", "Professional Services", "Administrative & Other"];
    const isProfitRow = profitRowLabels.includes(row.label);
    const isExpenseSection = expenseSectionLabels.includes(row.label);
    const isGraySection = graySectionLabels.includes(row.label);
    const isTanSection = tanSectionLabels.includes(row.label);
    const isOpExpenseGray = opExpenseGrayLabels.includes(row.label);
    
    if (!isMajorTotal && row.type !== "ratio" && row.type !== "header") {
      const currentZero = row.value === 0 || row.value === null;
      const compZero = !comparisonRows || comparisonRows[i].value === 0 || comparisonRows[i].value === null;
      if (currentZero && compZero) {
        return;
      }
    }
    
    const isVisible = isRowVisibleByParent(row, rows);
    const hiddenClass = isVisible ? "" : "is-row-hidden";
    const typeClass = `is-row-${row.type}`;
    const indentClass = `is-indent-${row.level}`;
    const isIncome = row.isIncome || false;
    const profitRowClass = isProfitRow ? "is-profit-row" : "";
    
    let expandedSubtotalClass = "";
    let childRowClass = "";
    let expenseSectionClass = "";
    let graySectionClass = "";
    let tanSectionClass = "";
    let opExpenseGrayClass = "";
    
    if (row.expandable && isRowStates[row.id] === true) {
      expandedSubtotalClass = "is-expanded-subtotal";
      if (isExpenseSection) {
        expenseSectionClass = "is-expense-section-expanded";
      }
      if (isGraySection) {
        graySectionClass = "is-gray-section-expanded";
      }
      if (isTanSection) {
        tanSectionClass = "is-tan-section-expanded";
      }
      if (isOpExpenseGray) {
        opExpenseGrayClass = "is-opexp-gray-expanded";
      }
    }
    
    if (row.parent) {
      const parentRow = rows.find(r => r.label === row.parent);
      if (parentRow && isRowStates[parentRow.id] === true) {
        childRowClass = "is-child-row";
      }
    }
    
    let toggleHtml = "";
    if (row.expandable) {
      const expanded = isRowStates[row.id] === true;
      toggleHtml = `<span class="is-toggle" data-row="${row.id}">${expanded ? "▼" : "▶"}</span>`;
    }
    
    let valueHtml = "";
    if (row.type === "header") {
      valueHtml = "";
    } else if (row.type === "ratio") {
      valueHtml = formatPercent(row.value);
    } else {
      valueHtml = formatAccountingNumber(row.value);
    }
    
    bodyHtml += `<tr class="${typeClass} ${indentClass} ${hiddenClass} ${profitRowClass} ${expenseSectionClass} ${graySectionClass} ${tanSectionClass} ${opExpenseGrayClass} ${expandedSubtotalClass} ${childRowClass}" data-row-id="${row.id}">`;
    bodyHtml += `<td>${toggleHtml}${row.label}</td>`;
    
    if (comparisonRows) {
      const compRow = comparisonRows[i];
      let compValueHtml = "";
      
      if (row.type === "header") {
        bodyHtml += `<td></td><td></td><td class="var-col-left"></td><td></td>`;
      } else if (row.type === "ratio") {
        compValueHtml = formatPercent(compRow.value);
        const diffPct = (row.value - compRow.value) * 100;
        const isPositiveVar = isIncome ? diffPct >= 0 : diffPct <= 0;
        const pctClass = isPositiveVar ? "is-variance-positive" : "is-variance-negative";
        bodyHtml += `<td>${compValueHtml}</td>`;
        bodyHtml += `<td>${valueHtml}</td>`;
        bodyHtml += `<td class="var-col-left">-</td>`;
        bodyHtml += `<td class="${pctClass}">${diffPct.toLocaleString(undefined, {minimumFractionDigits: 1, maximumFractionDigits: 1})}%</td>`;
      } else {
        compValueHtml = formatAccountingNumber(compRow.value);
        const variance = formatVariance(row.value, compRow.value, isIncome);
        bodyHtml += `<td>${compValueHtml}</td>`;
        bodyHtml += `<td>${valueHtml}</td>`;
        bodyHtml += `<td class="var-col-left">${variance.diff}</td>`;
        bodyHtml += `<td>${variance.pct}</td>`;
      }
    } else {
      bodyHtml += `<td>${valueHtml}</td>`;
    }
    
    bodyHtml += "</tr>";
  });
  
  tbody.innerHTML = bodyHtml;
  attachToggleListeners();
  
  return isPartialPeriod(periodValue, periodType);
}

function renderMatrixView(groups, periodType, selectedYear, yearStart, yearEnd, showSubtotal, thead, tbody) {
  if (periodType === "ytd" || periodType === "ttm") {
    thead.innerHTML = "<tr><th colspan='2'>Matrix view is not available for YTD or TTM period types</th></tr>";
    tbody.innerHTML = "";
    return false;
  }
  
  const periods = getMatrixPeriodsNew(periodType, selectedYear, yearStart, yearEnd);
  
  if (periods.length === 0) {
    thead.innerHTML = "<tr><th>No data available for selected period</th></tr>";
    tbody.innerHTML = "";
    return false;
  }
  
  let headerHtml = "<tr><th>Account</th>";
  periods.forEach(p => {
    const partialIndicator = p.isPartial ? '<span class="is-partial-indicator">*</span>' : '';
    headerHtml += `<th>${p.label}${partialIndicator}</th>`;
  });
  if (showSubtotal) {
    headerHtml += "<th class=\"is-subtotal-col\">Subtotal</th>";
  }
  headerHtml += "</tr>";
  thead.innerHTML = headerHtml;
  
  const allPeriodRows = periods.map(p => {
    return buildIncomeStatementRows(p.months, groups);
  });
  
  const firstRows = allPeriodRows[0];
  let bodyHtml = "";
  const colCount = periods.length + 1 + (showSubtotal ? 1 : 0);
  
  firstRows.forEach((row, i) => {
    if (row.type === "spacer") {
      bodyHtml += `<tr class="is-spacer-row"><td colspan="${colCount}"></td></tr>`;
      return;
    }
    
    const majorTotalLabels = ["Revenue", "Total Cost of Sales", "Gross Profit", "Operating Expenses", "Operating Income", "Net Profit Before Taxes", "Net Profit After Taxes"];
    const isMajorTotal = majorTotalLabels.includes(row.label);
    const profitRowLabels = ["Revenue", "Gross Profit", "Operating Income", "Net Profit Before Taxes", "Net Profit After Taxes"];
    const expenseSectionLabels = ["Total Cost of Sales", "Operating Expenses", "Taxes", "Other Income/Expense"];
    const graySectionLabels = ["Total Direct Expenses", "Total Indirect Expenses"];
    const tanSectionLabels = ["Direct Labor", "Indirect Labor", "Vehicle Expense"];
    const opExpenseGrayLabels = ["Salaries & Benefits", "Facility", "Travel & Entertainment", "Insurance", "Professional Services", "Administrative & Other"];
    const isProfitRow = profitRowLabels.includes(row.label);
    const isExpenseSection = expenseSectionLabels.includes(row.label);
    const isGraySection = graySectionLabels.includes(row.label);
    const isTanSection = tanSectionLabels.includes(row.label);
    const isOpExpenseGray = opExpenseGrayLabels.includes(row.label);
    
    if (!isMajorTotal && row.type !== "ratio" && row.type !== "header") {
      const allZero = allPeriodRows.every(periodRows => {
        const pRow = periodRows[i];
        return pRow.value === 0 || pRow.value === null;
      });
      if (allZero) {
        return;
      }
    }
    
    const isVisible = isRowVisibleByParent(row, firstRows);
    const hiddenClass = isVisible ? "" : "is-row-hidden";
    const typeClass = `is-row-${row.type}`;
    const indentClass = `is-indent-${row.level}`;
    const profitRowClass = isProfitRow ? "is-profit-row" : "";
    
    let expandedSubtotalClass = "";
    let childRowClass = "";
    let expenseSectionClass = "";
    let graySectionClass = "";
    let tanSectionClass = "";
    let opExpenseGrayClass = "";
    
    if (row.expandable && isRowStates[row.id] === true) {
      expandedSubtotalClass = "is-expanded-subtotal";
      if (isExpenseSection) {
        expenseSectionClass = "is-expense-section-expanded";
      }
      if (isGraySection) {
        graySectionClass = "is-gray-section-expanded";
      }
      if (isTanSection) {
        tanSectionClass = "is-tan-section-expanded";
      }
      if (isOpExpenseGray) {
        opExpenseGrayClass = "is-opexp-gray-expanded";
      }
    }
    
    if (row.parent) {
      const parentRow = firstRows.find(r => r.label === row.parent);
      if (parentRow && isRowStates[parentRow.id] === true) {
        childRowClass = "is-child-row";
      }
    }
    
    let toggleHtml = "";
    if (row.expandable) {
      const expanded = isRowStates[row.id] === true;
      toggleHtml = `<span class="is-toggle" data-row="${row.id}">${expanded ? "▼" : "▶"}</span>`;
    }
    
    bodyHtml += `<tr class="${typeClass} ${indentClass} ${hiddenClass} ${profitRowClass} ${expenseSectionClass} ${graySectionClass} ${tanSectionClass} ${opExpenseGrayClass} ${expandedSubtotalClass} ${childRowClass}" data-row-id="${row.id}">`;
    bodyHtml += `<td>${toggleHtml}${row.label}</td>`;
    
    let rowSubtotal = 0;
    allPeriodRows.forEach(periodRows => {
      const pRow = periodRows[i];
      let valueHtml = "";
      if (pRow.type === "header" || pRow.type === "spacer") {
        valueHtml = "";
      } else if (pRow.type === "ratio") {
        valueHtml = formatPercent(pRow.value);
      } else {
        valueHtml = formatAccountingNumber(pRow.value);
        rowSubtotal += pRow.value || 0;
      }
      bodyHtml += `<td>${valueHtml}</td>`;
    });
    
    if (showSubtotal) {
      if (row.type === "header" || row.type === "ratio") {
        bodyHtml += "<td class=\"is-subtotal-col\"></td>";
      } else {
        bodyHtml += `<td class="is-subtotal-col"><strong>${formatAccountingNumber(rowSubtotal)}</strong></td>`;
      }
    }
    
    bodyHtml += "</tr>";
  });
  
  tbody.innerHTML = bodyHtml;
  attachToggleListeners();
  
  return periods.some(p => p.isPartial);
}

function getMatrixPeriodsNew(periodType, selectedYear, yearStart, yearEnd) {
  const months = getAvailableMonths();
  const periods = [];
  
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth() + 1;
  const currentQuarter = Math.ceil(currentMonth / 3);
  const currentMonthKey = getCurrentMonthKey();
  const excludeCurrent = document.getElementById("isExcludeCurrent")?.checked;
  
  if (periodType === "year") {
    const startYr = parseInt(yearStart);
    const endYr = parseInt(yearEnd);
    for (let y = startYr; y <= endYr; y++) {
      let yearMonths = months.filter(m => m.startsWith(y + "-"));
      if (excludeCurrent) {
        yearMonths = yearMonths.filter(m => m !== currentMonthKey);
      }
      if (yearMonths.length > 0) {
        periods.push({
          label: String(y),
          months: yearMonths,
          isPartial: y === currentYear && !excludeCurrent
        });
      }
    }
  } else if (periodType === "quarter") {
    const selYear = parseInt(selectedYear);
    for (let q = 1; q <= 4; q++) {
      const startMonth = (q - 1) * 3 + 1;
      let quarterMonths = [];
      for (let m = startMonth; m < startMonth + 3; m++) {
        const key = `${selectedYear}-${String(m).padStart(2, "0")}`;
        if (months.includes(key)) quarterMonths.push(key);
      }
      if (excludeCurrent) {
        quarterMonths = quarterMonths.filter(m => m !== currentMonthKey);
      }
      if (quarterMonths.length > 0) {
        periods.push({
          label: `Q${q}`,
          months: quarterMonths,
          isPartial: selYear === currentYear && q === currentQuarter && !excludeCurrent
        });
      }
    }
  } else if (periodType === "month") {
    const selYear = parseInt(selectedYear);
    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    for (let m = 1; m <= 12; m++) {
      const key = `${selectedYear}-${String(m).padStart(2, "0")}`;
      if (excludeCurrent && key === currentMonthKey) continue;
      if (months.includes(key)) {
        periods.push({
          label: monthNames[m - 1],
          months: [key],
          isPartial: selYear === currentYear && m === currentMonth && !excludeCurrent
        });
      }
    }
  } else if (periodType === "ytd" || periodType === "ttm") {
    return [];
  }
  
  return periods;
}

function isRowVisible(groups, idx) {
  const currentLevel = groups[idx].level;
  if (currentLevel === 0) return true;
  
  for (let i = idx - 1; i >= 0; i--) {
    if (groups[i].level < currentLevel) {
      const parentId = `is-row-${i}`;
      if (isRowStates[parentId] === false) return false;
      if (groups[i].level === 0) return true;
    }
  }
  return true;
}

function isRowVisibleByParent(row, rows) {
  if (!row.parent) return true;
  
  const parentRow = rows.find(r => r.label === row.parent);
  if (!parentRow) return true;
  
  const parentExpanded = isRowStates[parentRow.id] === true;
  if (!parentExpanded) return false;
  
  return isRowVisibleByParent(parentRow, rows);
}

function attachToggleListeners() {
  document.querySelectorAll(".is-toggle").forEach(toggle => {
    toggle.onclick = (e) => {
      e.stopPropagation();
      const rowId = toggle.dataset.row;
      isRowStates[rowId] = !isRowStates[rowId];
      renderIncomeStatement();
    };
  });
}

/* ------------------------------------------------------------
   BALANCE SHEET
------------------------------------------------------------ */
let bsData = null;
let bsAccountGroups = null;
let bsGLLookup = {};
let bsRowStates = {};
let bsLastDetailLevel = null;
let bsInceptionDate = "2015-01";

let bsControlsInitialized = false;

function initBalanceSheet() {
  if (bsData && bsAccountGroups) {
    if (!bsControlsInitialized) {
      initBalanceSheetControls();
      loadBalanceSheetConfig();
      bsControlsInitialized = true;
    }
    renderBalanceSheet();
    return;
  }
  
  Promise.all([
    fetch("data/financials_gl.json").then(r => r.json()),
    fetch("data/account_groups.json").then(r => r.json())
  ]).then(([financials, accountGroups]) => {
    bsData = financials;
    bsAccountGroups = accountGroups;
    buildBSGLLookup();
    if (!bsControlsInitialized) {
      initBalanceSheetControls();
      loadBalanceSheetConfig();
      bsControlsInitialized = true;
    }
    renderBalanceSheet();
  }).catch(err => {
    console.error("Balance Sheet data load error:", err);
  });
}

function buildBSGLLookup() {
  bsGLLookup = {};
  const glHistory = bsData.gl_history_all || [];
  
  glHistory.forEach(row => {
    const acctNum = parseInt(row.Account_Num || row.Account, 10);
    if (isNaN(acctNum)) return;
    
    if (!bsGLLookup[acctNum]) {
      bsGLLookup[acctNum] = {};
    }
    
    Object.keys(row).forEach(key => {
      if (/^\d{4}-\d{2}$/.test(key)) {
        const val = parseFloat(row[key]) || 0;
        bsGLLookup[acctNum][key] = val;
      }
    });
  });
}

function initBalanceSheetControls() {
  populateBSPeriodOptions();
  populateBSMatrixYearOptions();
  
  const viewMode = document.getElementById("bsViewMode");
  const periodType = document.getElementById("bsPeriodType");
  const periodSelect = document.getElementById("bsPeriodSelect");
  const matrixYear = document.getElementById("bsMatrixYear");
  const matrixYearStart = document.getElementById("bsMatrixYearStart");
  const matrixYearEnd = document.getElementById("bsMatrixYearEnd");
  
  viewMode.onchange = () => {
    updateBSControlVisibility();
    renderBalanceSheet();
    saveBalanceSheetConfig();
  };
  
  periodType.onchange = () => {
    updateBSControlVisibility();
    renderBalanceSheet();
    saveBalanceSheetConfig();
  };
  
  periodSelect.onchange = () => { renderBalanceSheet(); saveBalanceSheetConfig(); };
  matrixYear.onchange = () => { renderBalanceSheet(); saveBalanceSheetConfig(); };
  
  matrixYearStart.oninput = () => {
    const startVal = parseInt(matrixYearStart.value);
    const endVal = parseInt(matrixYearEnd.value);
    if (startVal > endVal) {
      matrixYearEnd.value = startVal;
    }
    document.getElementById("bsMatrixYearStartLabel").textContent = matrixYearStart.value;
    document.getElementById("bsMatrixYearEndLabel").textContent = matrixYearEnd.value;
    renderBalanceSheet();
    saveBalanceSheetConfig();
  };
  
  matrixYearEnd.oninput = () => {
    const startVal = parseInt(matrixYearStart.value);
    const endVal = parseInt(matrixYearEnd.value);
    if (endVal < startVal) {
      matrixYearStart.value = endVal;
    }
    document.getElementById("bsMatrixYearStartLabel").textContent = matrixYearStart.value;
    document.getElementById("bsMatrixYearEndLabel").textContent = matrixYearEnd.value;
    renderBalanceSheet();
    saveBalanceSheetConfig();
  };
  
  const compareRadios = document.querySelectorAll('input[name="bsCompareRadio"]');
  compareRadios.forEach(radio => {
    radio.onchange = () => { renderBalanceSheet(); saveBalanceSheetConfig(); };
  });
  
  const detailRadios = document.querySelectorAll('input[name="bsDetailLevel"]');
  detailRadios.forEach(radio => {
    radio.onchange = () => { renderBalanceSheet(); saveBalanceSheetConfig(); };
  });
  
  const showThousands = document.getElementById("bsShowThousands");
  if (showThousands) {
    showThousands.onchange = () => { renderBalanceSheet(); saveBalanceSheetConfig(); };
  }
  
  const excludeCurrentMonth = document.getElementById("bsExcludeCurrentMonth");
  if (excludeCurrentMonth) {
    excludeCurrentMonth.onchange = () => {
      populateBSPeriodOptions();
      renderBalanceSheet();
      saveBalanceSheetConfig();
    };
  }
  
  updateBSControlVisibility();
}

function updateBSControlVisibility() {
  const viewMode = document.getElementById("bsViewMode").value;
  const periodType = document.getElementById("bsPeriodType").value;
  
  const periodTypeRow = document.getElementById("bsPeriodTypeRow");
  const singlePeriodRow = document.getElementById("bsSinglePeriodRow");
  const matrixYearRow = document.getElementById("bsMatrixYearRow");
  const matrixRangeControls = document.getElementById("bsMatrixRangeControls");
  const singleCompareBox = document.getElementById("bsSingleCompareBox");
  
  if (viewMode === "single") {
    periodTypeRow.style.display = "none";
    singlePeriodRow.style.display = "";
    matrixYearRow.style.display = "none";
    matrixRangeControls.style.display = "none";
    singleCompareBox.style.display = "";
  } else {
    periodTypeRow.style.display = "";
    singlePeriodRow.style.display = "none";
    singleCompareBox.style.display = "none";
    
    if (periodType === "annual") {
      matrixYearRow.style.display = "none";
      matrixRangeControls.style.display = "";
    } else {
      matrixYearRow.style.display = "";
      matrixRangeControls.style.display = "none";
    }
  }
}

function populateBSMatrixYearOptions() {
  const yearSelect = document.getElementById("bsMatrixYear");
  const months = getBSAvailableMonths();
  const years = [...new Set(months.map(m => m.split("-")[0]))].sort().reverse();
  
  yearSelect.innerHTML = years.map(y => `<option value="${y}">${y}</option>`).join("");
}

function populateBSPeriodOptions() {
  const periodSelect = document.getElementById("bsPeriodSelect");
  let months = getBSAvailableMonths();
  
  if (months.length === 0) return;
  
  // Filter out current month if exclude is checked
  const excludeCurrentMonth = document.getElementById("bsExcludeCurrentMonth")?.checked || false;
  if (excludeCurrentMonth) {
    const now = new Date();
    const currentMonthKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
    months = months.filter(m => m !== currentMonthKey);
  }
  
  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  
  periodSelect.innerHTML = months.slice().reverse().map(m => {
    const [y, mo] = m.split("-");
    const label = `${monthNames[parseInt(mo) - 1]} ${y}`;
    return `<option value="${m}">${label}</option>`;
  }).join("");
}

function getBSAvailableMonths() {
  const months = new Set();
  Object.values(bsGLLookup).forEach(acct => {
    Object.keys(acct).forEach(key => {
      if (/^\d{4}-\d{2}$/.test(key)) {
        months.add(key);
      }
    });
  });
  return Array.from(months).sort();
}

function getCumulativeBalance(accounts, asOfMonth, isDebit) {
  const allMonths = getBSAvailableMonths();
  const monthsUpTo = allMonths.filter(m => m <= asOfMonth);
  
  let total = 0;
  
  accounts.forEach(acct => {
    const acctData = bsGLLookup[acct];
    if (acctData) {
      monthsUpTo.forEach(m => {
        total += acctData[m] || 0;
      });
    }
  });
  
  if (isDebit) {
    return total;
  } else {
    return -total;
  }
}

function getIncomeExpenseAccounts() {
  const accounts = [];
  for (let acct = 4000; acct <= 8999; acct++) {
    if (bsGLLookup[acct]) {
      accounts.push(acct);
    }
  }
  return accounts;
}

function calculateRetainedEarnings(asOfMonth) {
  const [asOfYear] = asOfMonth.split("-").map(Number);
  const priorYearEnd = `${asOfYear - 1}-12`;
  
  const incomeExpenseAccounts = getIncomeExpenseAccounts();
  const allMonths = getBSAvailableMonths();
  const monthsUpToPriorYearEnd = allMonths.filter(m => m <= priorYearEnd);
  const monthsUpToSelected = allMonths.filter(m => m <= asOfMonth);
  
  let total = 0;
  incomeExpenseAccounts.forEach(acct => {
    const acctData = bsGLLookup[acct];
    if (acctData) {
      monthsUpToPriorYearEnd.forEach(m => {
        total += acctData[m] || 0;
      });
    }
  });
  
  let acct3020Total = 0;
  const acct3020Data = bsGLLookup[3020];
  if (acct3020Data) {
    monthsUpToSelected.forEach(m => {
      acct3020Total += acct3020Data[m] || 0;
    });
  }
  
  return -total - acct3020Total;
}

function calculateCurrentYearNetIncome(asOfMonth) {
  const [asOfYear, asOfMo] = asOfMonth.split("-").map(Number);
  const currentYearStart = `${asOfYear}-01`;
  
  const incomeExpenseAccounts = getIncomeExpenseAccounts();
  const allMonths = getBSAvailableMonths();
  const monthsInCurrentYear = allMonths.filter(m => m >= currentYearStart && m <= asOfMonth);
  
  let total = 0;
  incomeExpenseAccounts.forEach(acct => {
    const acctData = bsGLLookup[acct];
    if (acctData) {
      monthsInCurrentYear.forEach(m => {
        total += acctData[m] || 0;
      });
    }
  });
  
  return -total;
}

function buildBalanceSheetRows(asOfMonth, groups, computedValues = {}) {
  const rows = [];
  
  groups.forEach((group, idx) => {
    const rowId = `bs-row-${group.label.replace(/\s+/g, '_')}`;
    let value = null;
    
    if (group.specialCalc === "retained_earnings") {
      value = calculateRetainedEarnings(asOfMonth);
    } else if (group.specialCalc === "current_year_net_income") {
      value = calculateCurrentYearNetIncome(asOfMonth);
    } else if (group.accounts) {
      value = getCumulativeBalance(group.accounts, asOfMonth, group.isDebit);
    } else if (group.formula) {
      value = evaluateBSFormula(group.formula, computedValues);
    }
    
    computedValues[group.label] = value;
    
    if (group.expandable) {
      if (bsRowStates[rowId] === undefined) {
        bsRowStates[rowId] = false;
      }
    }
    
    if (group.type === "spacer") {
      rows.push({
        id: `bs-spacer-${idx}`,
        label: "",
        level: 0,
        type: "spacer",
        value: null,
        expandable: false,
        parent: null,
        highlight: null
      });
    } else {
      rows.push({
        id: rowId,
        label: group.label,
        level: group.level || 0,
        type: group.type,
        value: value,
        expandable: group.expandable || false,
        parent: group.parent || null,
        highlight: group.highlight || null,
        note: group.note || null
      });
    }
  });
  
  return rows;
}

function evaluateBSFormula(formula, computedValues) {
  let expr = formula;
  
  Object.keys(computedValues).sort((a, b) => b.length - a.length).forEach(label => {
    const val = computedValues[label] || 0;
    expr = expr.split(label).join(`(${val})`);
  });
  
  try {
    expr = expr.replace(/[^0-9+\-*/().]/g, "");
    return eval(expr) || 0;
  } catch (e) {
    console.error("BS Formula eval error:", formula, e);
    return 0;
  }
}

function setBSDetailLevelStates(detailLevel) {
  const summaryRows = [
    "bs-row-Current_Assets",
    "bs-row-Long-Term_Assets",
    "bs-row-Current_Liabilities",
    "bs-row-Long-Term_Liabilities",
    "bs-row-Equity"
  ];
  
  const mediumExpandRows = [
    "bs-row-Current_Assets",
    "bs-row-Long-Term_Assets",
    "bs-row-Current_Liabilities",
    "bs-row-Equity"
  ];
  
  const allExpandableRows = [
    "bs-row-Current_Assets",
    "bs-row-Cash_&_Cash_Equivalents",
    "bs-row-Checking",
    "bs-row-Savings_&_Investments",
    "bs-row-Receivables",
    "bs-row-Other_Current_Assets",
    "bs-row-Long-Term_Assets",
    "bs-row-Fixed_Assets",
    "bs-row-Intangible_Assets",
    "bs-row-Prepaid_Assets",
    "bs-row-Other_Long-Term_Assets",
    "bs-row-Current_Liabilities",
    "bs-row-Accounts_Payable",
    "bs-row-Accrued_Expenses",
    "bs-row-Other_Current_Liabilities",
    "bs-row-Long-Term_Liabilities",
    "bs-row-Equity",
    "bs-row-Capital_Contributions",
    "bs-row-Distributions"
  ];
  
  if (detailLevel === "summary") {
    allExpandableRows.forEach(rowId => {
      bsRowStates[rowId] = false;
    });
  } else if (detailLevel === "medium") {
    allExpandableRows.forEach(rowId => {
      bsRowStates[rowId] = false;
    });
    mediumExpandRows.forEach(rowId => {
      bsRowStates[rowId] = true;
    });
  } else if (detailLevel === "account") {
    allExpandableRows.forEach(rowId => {
      bsRowStates[rowId] = true;
    });
  }
}

function renderBalanceSheet() {
  if (!bsAccountGroups || !bsAccountGroups.balance_sheet) {
    console.log("Balance sheet groups not loaded yet");
    return;
  }
  
  showTableLoading('balanceSheetTable', 'Updating...');
  
  requestAnimationFrame(() => {
    renderBalanceSheetContent();
  });
}

function renderBalanceSheetContent() {
  const viewMode = document.getElementById("bsViewMode")?.value || "single";
  const detailLevel = document.querySelector('input[name="bsDetailLevel"]:checked')?.value || "summary";
  
  if (detailLevel !== bsLastDetailLevel) {
    setBSDetailLevelStates(detailLevel);
    bsLastDetailLevel = detailLevel;
  }
  updateReportHeader("bs");
  
  const groups = bsAccountGroups.balance_sheet.groups;
  const thead = document.getElementById("bsTableHead");
  const tbody = document.getElementById("bsTableBody");
  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  const excludeCurrentMonth = document.getElementById("bsExcludeCurrentMonth")?.checked || false;
  
  if (viewMode === "matrix") {
    renderBalanceSheetMatrix();
    return;
  }
  
  const periodValue = document.getElementById("bsPeriodSelect").value;
  if (!periodValue) return;
  
  const compare = document.querySelector('input[name="bsCompareRadio"]:checked')?.value || "none";
  
  const [y, mo] = periodValue.split("-");
  const currentLabel = `${monthNames[parseInt(mo) - 1]} ${y}`;
  
  document.getElementById("bsDataAsOf").textContent = currentLabel;
  
  const rows = buildBalanceSheetRows(periodValue, groups);
  
  let comparisonRows = null;
  let compPeriodLabel = "";
  const availableMonths = getBSAvailableMonths();
  
  if (compare === "prior_year") {
    const priorYear = parseInt(y) - 1;
    const priorPeriod = `${priorYear}-${mo}`;
    
    if (availableMonths.includes(priorPeriod)) {
      compPeriodLabel = `${monthNames[parseInt(mo) - 1]} ${priorYear}`;
      comparisonRows = buildBalanceSheetRows(priorPeriod, groups);
    }
  } else if (compare === "prior_month") {
    const periodIdx = availableMonths.indexOf(periodValue);
    if (periodIdx > 0) {
      const priorPeriod = availableMonths[periodIdx - 1];
      const [py, pm] = priorPeriod.split("-");
      compPeriodLabel = `${monthNames[parseInt(pm) - 1]} ${py}`;
      comparisonRows = buildBalanceSheetRows(priorPeriod, groups);
    }
  }
  
  let headerHtml = "<tr><th>Account</th>";
  if (comparisonRows) {
    headerHtml += `<th>${compPeriodLabel}</th><th>${currentLabel}</th><th class="var-col-left">$ Var</th><th>% Var</th>`;
  } else {
    headerHtml += `<th>${currentLabel}</th>`;
  }
  headerHtml += "</tr>";
  thead.innerHTML = headerHtml;
  
  let bodyHtml = "";
  const colCount = comparisonRows ? 5 : 2;
  
  rows.forEach((row, i) => {
    if (row.type === "spacer") {
      bodyHtml += `<tr class="is-spacer-row"><td colspan="${colCount}"></td></tr>`;
      return;
    }
    
    const isHeaderRow = row.type === "header";
    const isDetailRow = row.type === "detail";
    const isSubtotal = row.type === "subtotal";
    
    let isVisible;
    if (detailLevel === "account") {
      isVisible = true;
    } else {
      isVisible = isBSRowVisibleByParent(row, rows);
    }
    const hiddenClass = isVisible ? "" : "is-row-hidden";
    const typeClass = `is-row-${row.type}`;
    const indentClass = `is-indent-${row.level}`;
    const highlightClass = row.highlight === "total" ? "is-major-total" : "";
    
    let expandedSubtotalClass = "";
    let childRowClass = "";
    
    if (row.expandable && bsRowStates[row.id] === true) {
      expandedSubtotalClass = "is-expanded-subtotal";
    }
    
    if (row.parent) {
      const parentRow = rows.find(r => r.label === row.parent);
      if (parentRow && bsRowStates[parentRow.id] === true) {
        childRowClass = "is-child-row";
      }
    }
    
    let toggleHtml = "";
    if (row.expandable) {
      const expanded = bsRowStates[row.id] === true;
      toggleHtml = `<span class="bs-toggle" data-row="${row.id}">${expanded ? "▼" : "▶"}</span>`;
    } else if (row.parent && detailLevel !== "account") {
      toggleHtml = `<span class="bs-toggle-placeholder"></span>`;
    }
    
    let valueHtml = "";
    if (row.type === "header") {
      valueHtml = "";
    } else {
      valueHtml = formatBSNumber(row.value);
    }
    
    bodyHtml += `<tr class="${typeClass} ${indentClass} ${hiddenClass} ${highlightClass} ${expandedSubtotalClass} ${childRowClass}" data-row-id="${row.id}">`;
    bodyHtml += `<td>${toggleHtml}${row.label}</td>`;
    
    if (comparisonRows) {
      const compRow = comparisonRows[i];
      
      if (row.type === "header") {
        bodyHtml += `<td></td><td></td><td class="var-col-left"></td><td></td>`;
      } else {
        const compValueHtml = formatBSNumber(compRow.value);
        const variance = formatBSVariance(row.value, compRow.value);
        bodyHtml += `<td>${compValueHtml}</td>`;
        bodyHtml += `<td>${valueHtml}</td>`;
        bodyHtml += `<td class="var-col-left">${variance.diff}</td>`;
        bodyHtml += `<td>${variance.pct}</td>`;
      }
    } else {
      if (row.type !== "header") {
        bodyHtml += `<td>${valueHtml}</td>`;
      } else {
        bodyHtml += `<td></td>`;
      }
    }
    
    bodyHtml += "</tr>";
  });
  
  tbody.innerHTML = bodyHtml;
  attachBSToggleListeners();
  setTimeout(() => {
    autoSizeFirstColumn("balanceSheetTable");
    addResizeHandlesToTable("balanceSheetTable");
    autoScaleFontSize("balanceSheetTable", "bsTableBox");
    hideTableLoading('balanceSheetTable');
  }, 50);
}

function formatBSNumber(value) {
  const showThousands = document.getElementById("bsShowThousands")?.checked || false;
  
  if (value === null || value === undefined) return "";
  
  let displayValue = value;
  let suffix = "";
  
  if (showThousands) {
    displayValue = value / 1000;
    suffix = "K";
  }
  
  const absVal = Math.abs(displayValue);
  const formatted = absVal.toLocaleString(undefined, {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  });
  
  if (value < 0) {
    return `<span class="bs-negative">($${formatted}${suffix})</span>`;
  }
  return `$${formatted}${suffix}`;
}

function formatBSVariance(current, prior) {
  if (current === null || prior === null) {
    return { diff: "-", pct: "-" };
  }
  
  const diff = current - prior;
  const showThousands = document.getElementById("bsShowThousands")?.checked || false;
  let displayDiff = diff;
  let suffix = "";
  
  if (showThousands) {
    displayDiff = diff / 1000;
    suffix = "K";
  }
  
  const absDiff = Math.abs(displayDiff);
  const diffFormatted = absDiff.toLocaleString(undefined, {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  });
  
  let pctStr = "-";
  if (prior !== 0) {
    const pctChange = ((current - prior) / Math.abs(prior)) * 100;
    if (pctChange > 1000) {
      pctStr = "1,000%+";
    } else if (pctChange < -1000) {
      pctStr = "-1,000%+";
    } else {
      pctStr = pctChange.toLocaleString(undefined, {
        minimumFractionDigits: 1,
        maximumFractionDigits: 1
      }) + "%";
    }
  } else if (current !== 0) {
    pctStr = "N/A";
  } else {
    pctStr = "0.0%";
  }
  
  const isPositive = diff >= 0;
  const pctClass = isPositive ? "is-variance-positive" : "is-variance-negative";
  
  return {
    diff: diff < 0 ? `($${diffFormatted}${suffix})` : `$${diffFormatted}${suffix}`,
    pct: `<span class="${pctClass}">${pctStr}</span>`
  };
}

function isBSRowVisibleByParent(row, rows) {
  if (!row.parent) return true;
  
  const parentRow = rows.find(r => r.label === row.parent);
  if (!parentRow) return true;
  
  const parentExpanded = bsRowStates[parentRow.id] === true;
  if (!parentExpanded) return false;
  
  return isBSRowVisibleByParent(parentRow, rows);
}

function attachBSToggleListeners() {
  document.querySelectorAll(".bs-toggle").forEach(toggle => {
    toggle.onclick = (e) => {
      e.stopPropagation();
      const rowId = toggle.dataset.row;
      bsRowStates[rowId] = !bsRowStates[rowId];
      renderBalanceSheet();
    };
  });
}

function renderBalanceSheetMatrix() {
  const periodType = document.getElementById("bsPeriodType").value;
  const detailLevel = document.querySelector('input[name="bsDetailLevel"]:checked')?.value || "summary";
  
  if (detailLevel !== bsLastDetailLevel) {
    setBSDetailLevelStates(detailLevel);
    bsLastDetailLevel = detailLevel;
  }
  
  const groups = bsAccountGroups.balance_sheet.groups;
  const thead = document.getElementById("bsTableHead");
  const tbody = document.getElementById("bsTableBody");
  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  const excludeCurrentMonth = document.getElementById("bsExcludeCurrentMonth")?.checked || false;
  
  let periods = [];
  let periodLabels = [];
  const availableMonths = getBSAvailableMonths();
  const currentMonth = availableMonths[availableMonths.length - 1];
  
  if (periodType === "month") {
    const selectedYear = document.getElementById("bsMatrixYear").value;
    for (let m = 1; m <= 12; m++) {
      const period = `${selectedYear}-${String(m).padStart(2, '0')}`;
      if (availableMonths.includes(period)) {
        if (excludeCurrentMonth && period === currentMonth) continue;
        periods.push(period);
        periodLabels.push(monthNames[m - 1]);
      }
    }
    document.getElementById("bsDataAsOf").textContent = `${selectedYear} Monthly`;
  } else if (periodType === "quarter") {
    const selectedYear = document.getElementById("bsMatrixYear").value;
    const quarterEnds = [`${selectedYear}-03`, `${selectedYear}-06`, `${selectedYear}-09`, `${selectedYear}-12`];
    const quarterLabels = ["Q1", "Q2", "Q3", "Q4"];
    quarterEnds.forEach((period, idx) => {
      if (availableMonths.includes(period)) {
        if (excludeCurrentMonth && period === currentMonth) return;
        periods.push(period);
        periodLabels.push(`${quarterLabels[idx]} ${selectedYear}`);
      }
    });
    document.getElementById("bsDataAsOf").textContent = `${selectedYear} Quarterly`;
  } else if (periodType === "annual") {
    const startYear = parseInt(document.getElementById("bsMatrixYearStart").value);
    const endYear = parseInt(document.getElementById("bsMatrixYearEnd").value);
    for (let y = startYear; y <= endYear; y++) {
      const period = `${y}-12`;
      if (availableMonths.includes(period)) {
        if (excludeCurrentMonth && period === currentMonth) continue;
        periods.push(period);
        periodLabels.push(String(y));
      }
    }
    document.getElementById("bsDataAsOf").textContent = `${startYear} - ${endYear} Annual`;
  }
  
  if (periods.length === 0) {
    thead.innerHTML = "<tr><th>No data available for selected period</th></tr>";
    tbody.innerHTML = "";
    return;
  }
  
  const allRowsData = periods.map(period => buildBalanceSheetRows(period, groups));
  const baseRows = allRowsData[0];
  
  let headerHtml = "<tr><th>Account</th>";
  periodLabels.forEach(label => {
    headerHtml += `<th>${label}</th>`;
  });
  headerHtml += "</tr>";
  thead.innerHTML = headerHtml;
  
  let bodyHtml = "";
  const colCount = periods.length + 1;
  
  baseRows.forEach((row, rowIdx) => {
    if (row.type === "spacer") {
      bodyHtml += `<tr class="is-spacer-row"><td colspan="${colCount}"></td></tr>`;
      return;
    }
    
    const isHeaderRow = row.type === "header";
    const isDetailRow = row.type === "detail";
    
    let isVisible;
    if (detailLevel === "account") {
      isVisible = true;
    } else {
      isVisible = isBSRowVisibleByParent(row, baseRows);
    }
    
    const hiddenClass = isVisible ? "" : "is-row-hidden";
    const typeClass = `is-row-${row.type}`;
    const indentClass = `is-indent-${row.level}`;
    const highlightClass = row.highlight === "total" ? "is-major-total" : "";
    
    let expandedSubtotalClass = "";
    if (row.expandable && bsRowStates[row.id] === true) {
      expandedSubtotalClass = "is-expanded-subtotal";
    }
    
    let toggleHtml = "";
    if (row.expandable) {
      const expanded = bsRowStates[row.id] === true;
      toggleHtml = `<span class="bs-toggle" data-row="${row.id}">${expanded ? "▼" : "▶"}</span>`;
    } else if (row.parent && detailLevel !== "account") {
      toggleHtml = `<span class="bs-toggle-placeholder"></span>`;
    }
    
    bodyHtml += `<tr class="${typeClass} ${indentClass} ${hiddenClass} ${highlightClass} ${expandedSubtotalClass}" data-row-id="${row.id}">`;
    bodyHtml += `<td>${toggleHtml}${row.label}</td>`;
    
    allRowsData.forEach(rows => {
      const periodRow = rows[rowIdx];
      if (row.type === "header") {
        bodyHtml += `<td></td>`;
      } else {
        bodyHtml += `<td>${formatBSNumber(periodRow?.value)}</td>`;
      }
    });
    
    bodyHtml += "</tr>";
  });
  
  tbody.innerHTML = bodyHtml;
  attachBSToggleListeners();
  setTimeout(() => {
    addResizeHandlesToTable("balanceSheetTable");
    autoScaleFontSize("balanceSheetTable", "bsTableBox");
    hideTableLoading('balanceSheetTable');
  }, 50);
}

/* ============================================================
   STATEMENT OF CASH FLOWS
============================================================ */
let cfData = null;
let cfAccountGroups = null;
let cfGLLookup = {};
let cfRowStates = {};
let cfControlsInitialized = false;
let cfInceptionDate = "2015-01";
let cfAvailableMonthsCache = null;
let cfCumulativeBalanceCache = {};

async function loadCashFlowStatement() {
  if (!cfData || !cfAccountGroups) {
    try {
      const [financialsRes, groupsRes] = await Promise.all([
        fetch("/data/financials_gl.json"),
        fetch("/data/account_groups.json")
      ]);
      cfData = await financialsRes.json();
      cfAccountGroups = await groupsRes.json();
      buildCFGLLookup();
    } catch (err) {
      console.error("Failed to load Cash Flow data:", err);
      return;
    }
  }
  
  if (!cfControlsInitialized) {
    initCashFlowControls();
    loadCashFlowConfig();
    cfControlsInitialized = true;
  }
  
  renderCashFlowStatement();
}

function buildCFGLLookup() {
  cfGLLookup = {};
  cfAvailableMonthsCache = null;
  cfCumulativeBalanceCache = {};
  const glHistory = cfData.gl_history_all || [];
  const monthSet = new Set();
  
  glHistory.forEach(row => {
    const acctNum = parseInt(row.Account_Num || row.Account, 10);
    if (isNaN(acctNum)) return;
    
    if (!cfGLLookup[acctNum]) {
      cfGLLookup[acctNum] = {};
    }
    
    Object.keys(row).forEach(key => {
      if (/^\d{4}-\d{2}$/.test(key)) {
        const val = parseFloat(row[key]) || 0;
        cfGLLookup[acctNum][key] = val;
        monthSet.add(key);
      }
    });
  });
  
  cfAvailableMonthsCache = Array.from(monthSet).sort();
  
  Object.keys(cfGLLookup).forEach(acctNum => {
    cfCumulativeBalanceCache[acctNum] = {};
    let cumulative = 0;
    cfAvailableMonthsCache.forEach(month => {
      cumulative += cfGLLookup[acctNum][month] || 0;
      cfCumulativeBalanceCache[acctNum][month] = cumulative;
    });
  });
}

function getCFAvailableMonths() {
  if (cfAvailableMonthsCache) return cfAvailableMonthsCache;
  const months = new Set();
  Object.values(cfGLLookup).forEach(acctData => {
    Object.keys(acctData).forEach(key => {
      if (/^\d{4}-\d{2}$/.test(key)) months.add(key);
    });
  });
  cfAvailableMonthsCache = Array.from(months).sort();
  return cfAvailableMonthsCache;
}

function initCashFlowControls() {
  const viewMode = document.getElementById("cfViewMode");
  const periodType = document.getElementById("cfPeriodType");
  const periodSelect = document.getElementById("cfPeriodSelect");
  const showThousands = document.getElementById("cfShowThousands");
  const excludeCurrent = document.getElementById("cfExcludeCurrent");
  const matrixYearStart = document.getElementById("cfMatrixYearStart");
  const matrixYearEnd = document.getElementById("cfMatrixYearEnd");
  
  populateCFPeriodOptions();
  
  viewMode.onchange = () => {
    updateCFMatrixControlsVisibility();
    renderCashFlowStatement();
    saveCashFlowConfig();
  };
  
  periodType.onchange = () => {
    populateCFPeriodOptions();
    updateCFMatrixControlsVisibility();
    renderCashFlowStatement();
    saveCashFlowConfig();
  };
  
  periodSelect.onchange = () => { renderCashFlowStatement(); saveCashFlowConfig(); };
  
  const compareRadios = document.querySelectorAll('input[name="cfCompareRadio"]');
  compareRadios.forEach(radio => {
    radio.onchange = () => { renderCashFlowStatement(); saveCashFlowConfig(); };
  });
  
  const detailRadios = document.querySelectorAll('input[name="cfDetailLevel"]');
  detailRadios.forEach(radio => {
    radio.onchange = () => {
      applyCFDetailLevel(radio.value);
      renderCashFlowStatement();
      saveCashFlowConfig();
    };
  });
  
  if (showThousands) {
    showThousands.onchange = () => { renderCashFlowStatement(); saveCashFlowConfig(); };
  }
  
  const showSubtotalCb = document.getElementById("cfShowSubtotal");
  if (showSubtotalCb) {
    showSubtotalCb.onchange = () => { renderCashFlowStatement(); saveCashFlowConfig(); };
  }
  
  if (excludeCurrent) {
    excludeCurrent.onchange = () => { 
      populateCFPeriodOptions();
      renderCashFlowStatement(); 
      saveCashFlowConfig(); 
    };
  }
  
  const excludeSchwab = document.getElementById("cfExcludeSchwab");
  if (excludeSchwab) {
    excludeSchwab.onchange = () => {
      renderCashFlowStatement();
      saveCashFlowConfig();
    };
  }
  
  if (matrixYearStart) {
    matrixYearStart.oninput = () => {
      document.getElementById("cfMatrixYearStartLabel").textContent = matrixYearStart.value;
      if (parseInt(matrixYearStart.value) > parseInt(matrixYearEnd.value)) {
        matrixYearEnd.value = matrixYearStart.value;
        document.getElementById("cfMatrixYearEndLabel").textContent = matrixYearEnd.value;
      }
      renderCashFlowStatement();
      saveCashFlowConfig();
    };
  }
  
  if (matrixYearEnd) {
    matrixYearEnd.oninput = () => {
      document.getElementById("cfMatrixYearEndLabel").textContent = matrixYearEnd.value;
      if (parseInt(matrixYearEnd.value) < parseInt(matrixYearStart.value)) {
        matrixYearStart.value = matrixYearEnd.value;
        document.getElementById("cfMatrixYearStartLabel").textContent = matrixYearStart.value;
      }
      renderCashFlowStatement();
      saveCashFlowConfig();
    };
  }
  
  const initialDetail = document.querySelector('input[name="cfDetailLevel"]:checked');
  applyCFDetailLevel(initialDetail ? initialDetail.value : 'summary');
  
  updateCFMatrixControlsVisibility();
  initCFAiAnalysis();
}

function updateCFMatrixControlsVisibility() {
  const viewMode = document.getElementById("cfViewMode").value;
  const periodType = document.getElementById("cfPeriodType").value;
  const singleControls = document.getElementById("cfSingleControls");
  const matrixControls = document.getElementById("cfMatrixControls");
  const yearControls = document.getElementById("cfMatrixYearControls");
  const periodSelect = document.getElementById("cfPeriodSelect");
  const periodSelectLabel = document.getElementById("cfPeriodSelectLabel");
  const showSubtotalWrapper = document.getElementById("cfShowSubtotalWrapper");
  const periodTypeSelect = document.getElementById("cfPeriodType");
  const ytdOption = periodTypeSelect.querySelector('option[value="ytd"]');
  const ttmOption = periodTypeSelect.querySelector('option[value="ttm"]');
  
  if (viewMode === "matrix") {
    singleControls.classList.add("hidden");
    matrixControls.classList.remove("hidden");
    if (showSubtotalWrapper) showSubtotalWrapper.classList.remove("hidden");
    
    if (ytdOption) ytdOption.disabled = true;
    if (ttmOption) ttmOption.disabled = true;
    
    if (periodType === "ytd" || periodType === "ttm") {
      periodTypeSelect.value = "month";
      populateCFPeriodOptions();
    }
    
    if (periodType === "year") {
      yearControls.classList.remove("hidden");
      periodSelect.classList.add("hidden");
      if (periodSelectLabel) periodSelectLabel.classList.add("hidden");
    } else {
      yearControls.classList.add("hidden");
      periodSelect.classList.remove("hidden");
      if (periodSelectLabel) {
        periodSelectLabel.classList.remove("hidden");
        periodSelectLabel.textContent = "Year:";
      }
      
      if (periodType === "quarter" || periodType === "month") {
        populateCFMatrixYearOptions();
      }
    }
  } else {
    singleControls.classList.remove("hidden");
    matrixControls.classList.add("hidden");
    periodSelect.classList.remove("hidden");
    if (periodSelectLabel) {
      periodSelectLabel.classList.remove("hidden");
      periodSelectLabel.textContent = "Period:";
    }
    if (showSubtotalWrapper) showSubtotalWrapper.classList.add("hidden");
    
    if (ytdOption) ytdOption.disabled = false;
    if (ttmOption) ttmOption.disabled = false;
    
    populateCFPeriodOptions();
  }
}

function populateCFPeriodOptions() {
  const periodType = document.getElementById("cfPeriodType").value;
  const periodSelect = document.getElementById("cfPeriodSelect");
  const months = getCFAvailableMonths();
  const options = [];
  
  const excludeCurrent = document.getElementById("cfExcludeCurrent")?.checked || false;
  const now = new Date();
  const currentMonthKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
  const filteredMonths = excludeCurrent ? months.filter(m => m !== currentMonthKey) : months;
  
  if (periodType === "month") {
    filteredMonths.slice(-24).reverse().forEach(m => {
      const [y, mo] = m.split("-");
      const monthName = new Date(y, mo - 1).toLocaleString("default", { month: "short" });
      options.push({ value: m, label: `${monthName} ${y}` });
    });
  } else if (periodType === "quarter") {
    const quarters = new Set();
    filteredMonths.forEach(m => {
      const [y, mo] = m.split("-");
      const q = Math.ceil(mo / 3);
      quarters.add(`${y}-Q${q}`);
    });
    Array.from(quarters).sort().reverse().forEach(q => {
      options.push({ value: q, label: q });
    });
  } else if (periodType === "year") {
    const years = new Set();
    filteredMonths.forEach(m => years.add(m.split("-")[0]));
    Array.from(years).sort().reverse().forEach(y => {
      options.push({ value: y, label: y });
    });
  } else if (periodType === "ytd") {
    const years = new Set();
    filteredMonths.forEach(m => years.add(m.split("-")[0]));
    Array.from(years).sort().reverse().forEach(y => {
      for (let mo = 12; mo >= 1; mo--) {
        const key = `${y}-${String(mo).padStart(2, "0")}`;
        if (filteredMonths.includes(key)) {
          const monthName = new Date(y, mo - 1).toLocaleString("default", { month: "short" });
          options.push({ value: `${y}-YTD-${mo}`, label: `YTD ${monthName} ${y}` });
          break;
        }
      }
    });
  } else if (periodType === "ttm") {
    filteredMonths.slice(-24).reverse().forEach(m => {
      const [y, mo] = m.split("-");
      const monthName = new Date(y, mo - 1).toLocaleString("default", { month: "short" });
      options.push({ value: `TTM-${m}`, label: `TTM ending ${monthName} ${y}` });
    });
  }
  
  periodSelect.innerHTML = options.map(o => 
    `<option value="${o.value}">${o.label}</option>`
  ).join("");
}

function populateCFMatrixYearOptions() {
  const periodSelect = document.getElementById("cfPeriodSelect");
  const months = getCFAvailableMonths();
  const years = new Set();
  months.forEach(m => years.add(m.split("-")[0]));
  
  periodSelect.innerHTML = Array.from(years).sort().reverse().map(y => 
    `<option value="${y}">${y}</option>`
  ).join("");
}

function applyCFDetailLevel(level) {
  const allExpandableRows = [
    "cf-row-Cash_from_Operating_Activities",
    "cf-row-Cash_from_Investing_Activities",
    "cf-row-Cash_from_Financing_Activities"
  ];
  
  if (level === "summary") {
    // Collapse all sections - only show subtotals
    allExpandableRows.forEach(rowId => {
      cfRowStates[rowId] = false;
    });
  } else if (level === "detailed") {
    // Expand all sections - show all components
    allExpandableRows.forEach(rowId => {
      cfRowStates[rowId] = true;
    });
  }
}

function getCFPriorPeriod(periodValue, periodType) {
  const months = getCFAvailableMonths();
  
  if (periodType === "month") {
    const idx = months.indexOf(periodValue);
    return idx > 0 ? months[idx - 1] : null;
  } else if (periodType === "quarter") {
    const [y, qStr] = periodValue.split("-Q");
    const q = parseInt(qStr);
    if (q > 1) return `${y}-Q${q - 1}`;
    return `${parseInt(y) - 1}-Q4`;
  } else if (periodType === "year") {
    return String(parseInt(periodValue) - 1);
  } else if (periodType === "ytd") {
    const parts = periodValue.split("-YTD-");
    return `${parseInt(parts[0]) - 1}-YTD-${parts[1]}`;
  } else if (periodType === "ttm") {
    const endMonth = periodValue.replace("TTM-", "");
    const idx = months.indexOf(endMonth);
    if (idx >= 12) {
      return `TTM-${months[idx - 1]}`;
    }
    return null;
  }
  return null;
}

function getCFPriorYearPeriod(periodValue, periodType) {
  if (periodType === "month") {
    const [y, mo] = periodValue.split("-");
    return `${parseInt(y) - 1}-${mo}`;
  } else if (periodType === "quarter") {
    const [y, q] = periodValue.split("-Q");
    return `${parseInt(y) - 1}-Q${q}`;
  } else if (periodType === "year") {
    return String(parseInt(periodValue) - 1);
  } else if (periodType === "ytd") {
    const parts = periodValue.split("-YTD-");
    return `${parseInt(parts[0]) - 1}-YTD-${parts[1]}`;
  } else if (periodType === "ttm") {
    const endMonth = periodValue.replace("TTM-", "");
    const [y, mo] = endMonth.split("-");
    return `TTM-${parseInt(y) - 1}-${mo}`;
  }
  return null;
}

function getCFPeriodMonths(periodType, periodValue) {
  const months = getCFAvailableMonths();
  const excludeCurrent = document.getElementById("cfExcludeCurrent")?.checked || false;
  const now = new Date();
  const currentMonthKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
  
  if (periodType === "month") {
    if (excludeCurrent && periodValue === currentMonthKey) return [];
    return [periodValue];
  } else if (periodType === "quarter") {
    const [y, qStr] = periodValue.split("-Q");
    const q = parseInt(qStr);
    const startMonth = (q - 1) * 3 + 1;
    let result = [];
    for (let m = startMonth; m < startMonth + 3; m++) {
      const key = `${y}-${String(m).padStart(2, "0")}`;
      if (months.includes(key)) {
        if (excludeCurrent && key === currentMonthKey) continue;
        result.push(key);
      }
    }
    return result;
  } else if (periodType === "year") {
    let result = months.filter(m => m.startsWith(periodValue + "-"));
    if (excludeCurrent) {
      result = result.filter(m => m !== currentMonthKey);
    }
    return result;
  } else if (periodType === "ytd") {
    const match = periodValue.match(/(\d{4})-YTD-(\d+)/);
    if (!match) return [];
    const year = match[1];
    const endMonth = parseInt(match[2]);
    let result = [];
    for (let m = 1; m <= endMonth; m++) {
      const key = `${year}-${String(m).padStart(2, "0")}`;
      if (months.includes(key)) {
        if (excludeCurrent && key === currentMonthKey) continue;
        result.push(key);
      }
    }
    return result;
  } else if (periodType === "ttm") {
    const match = periodValue.match(/TTM-(\d{4}-\d{2})/);
    if (!match) return [];
    const endKey = match[1];
    const endIdx = months.indexOf(endKey);
    if (endIdx < 0) return [];
    const startIdx = Math.max(0, endIdx - 11);
    let result = months.slice(startIdx, endIdx + 1);
    if (excludeCurrent) {
      result = result.filter(m => m !== currentMonthKey);
    }
    return result;
  }
  return [];
}

function getCFAccountBalance(acctNum, period) {
  if (!cfGLLookup[acctNum]) return 0;
  return cfGLLookup[acctNum][period] || 0;
}

function getCFCumulativeBalance(acctNum, endPeriod) {
  if (cfCumulativeBalanceCache[acctNum] && cfCumulativeBalanceCache[acctNum][endPeriod] !== undefined) {
    return cfCumulativeBalanceCache[acctNum][endPeriod];
  }
  if (!cfGLLookup[acctNum]) return 0;
  const months = getCFAvailableMonths().filter(m => m <= endPeriod);
  return months.reduce((sum, m) => sum + (cfGLLookup[acctNum][m] || 0), 0);
}

function getCFPeriodActivity(acctNum, periodMonths) {
  if (!cfGLLookup[acctNum]) return 0;
  return periodMonths.reduce((sum, m) => sum + (cfGLLookup[acctNum][m] || 0), 0);
}

function getCFBalanceChange(accounts, periodMonths, changeType) {
  if (!accounts || accounts.length === 0 || periodMonths.length === 0) return 0;
  
  const allMonths = getCFAvailableMonths();
  const firstPeriodMonth = periodMonths[0];
  const lastPeriodMonth = periodMonths[periodMonths.length - 1];
  
  const firstMonthIdx = allMonths.indexOf(firstPeriodMonth);
  const priorMonth = firstMonthIdx > 0 ? allMonths[firstMonthIdx - 1] : null;
  
  let beginningBalance = 0;
  let endingBalance = 0;
  
  accounts.forEach(acctNum => {
    if (priorMonth) {
      beginningBalance += getCFCumulativeBalance(acctNum, priorMonth);
    }
    endingBalance += getCFCumulativeBalance(acctNum, lastPeriodMonth);
  });
  
  const change = endingBalance - beginningBalance;
  
  if (changeType === "decrease_is_positive") {
    return -change;
  } else if (changeType === "increase_is_positive") {
    return change;
  } else if (changeType === "increase_is_negative") {
    return -change;
  }
  
  return change;
}

function buildCashFlowRows(periodMonths, groups) {
  const calculatedValues = {};
  const rows = [];
  
  const allMonths = getCFAvailableMonths();
  const firstPeriodMonth = periodMonths[0];
  const firstMonthIdx = allMonths.indexOf(firstPeriodMonth);
  const priorMonth = firstMonthIdx > 0 ? allMonths[firstMonthIdx - 1] : null;
  
  groups.forEach((group, idx) => {
    const row = {
      label: group.label,
      level: group.level || 0,
      type: group.type,
      expandable: group.expandable || false,
      parent: group.parent || null,
      highlight: group.highlight || null,
      id: `cf-row-${group.label.replace(/[^a-zA-Z0-9]/g, "_")}`,
      value: 0
    };
    
    if (group.type === "spacer" || group.type === "header") {
      rows.push(row);
      return;
    }
    
    if (group.specialCalc === "net_income") {
      // Net Income = negative sum of all accounts 4000 and higher for the selected period
      let sumActivity = 0;
      const incomeExpenseAccounts = Object.keys(cfGLLookup).map(Number).filter(n => n >= 4000);
      incomeExpenseAccounts.forEach(acctNum => {
        sumActivity += getCFPeriodActivity(acctNum, periodMonths);
      });
      // Negate because revenues are credits (negative) and expenses are debits (positive)
      const netIncome = -sumActivity;
      row.value = netIncome;
      calculatedValues[group.label] = netIncome;
    } else if (group.specialCalc === "beginning_balance") {
      let balance = 0;
      if (priorMonth && group.accounts) {
        const excludeSchwab = document.getElementById("cfExcludeSchwab")?.checked ?? true;
        const filteredAccounts = excludeSchwab ? group.accounts.filter(a => a !== 1004) : group.accounts;
        filteredAccounts.forEach(acctNum => {
          balance += getCFCumulativeBalance(acctNum, priorMonth);
        });
      }
      row.value = balance;
      calculatedValues[group.label] = balance;
    } else if (group.accounts || group.accounts_range) {
      let accountList = group.accounts || [];
      if (group.accounts_range) {
        const [start, end] = group.accounts_range;
        const allAccounts = Object.keys(cfGLLookup).map(Number);
        accountList = allAccounts.filter(a => a >= start && a <= end);
      }
      if (group.changeCalc) {
        row.value = getCFBalanceChange(accountList, periodMonths, group.changeCalc);
      } else if (group.addBack) {
        let total = 0;
        accountList.forEach(acctNum => {
          total += getCFPeriodActivity(acctNum, periodMonths);
        });
        row.value = Math.abs(total);
      } else if (group.negate) {
        let total = 0;
        accountList.forEach(acctNum => {
          total += getCFPeriodActivity(acctNum, periodMonths);
        });
        row.value = -total;
      } else {
        let total = 0;
        accountList.forEach(acctNum => {
          total += getCFPeriodActivity(acctNum, periodMonths);
        });
        row.value = total;
      }
      calculatedValues[group.label] = row.value;
    } else if (group.formula) {
      const formula = group.formula;
      let value = 0;
      const parts = formula.split(/\s*([+-])\s*/);
      let op = "+";
      parts.forEach(part => {
        part = part.trim();
        if (part === "+" || part === "-") {
          op = part;
        } else if (part && calculatedValues.hasOwnProperty(part)) {
          if (op === "+") {
            value += calculatedValues[part];
          } else {
            value -= calculatedValues[part];
          }
        }
      });
      row.value = value;
      calculatedValues[group.label] = value;
    }
    
    rows.push(row);
  });
  
  return rows;
}

function isCFRowVisible(groups, idx) {
  const row = groups[idx];
  if (!row.parent) return true;
  
  // Search both backward and forward since parent subtotals come after children in cash flow
  for (let i = 0; i < groups.length; i++) {
    if (i === idx) continue;
    if (groups[i].label === row.parent) {
      if (!groups[i].expandable) return isCFRowVisible(groups, i);
      const parentId = `cf-row-${groups[i].label.replace(/[^a-zA-Z0-9]/g, "_")}`;
      if (cfRowStates[parentId] === true) {
        return isCFRowVisible(groups, i);
      }
      return false;
    }
  }
  return true;
}

function formatCFNumber(value, inThousands = false) {
  if (value === 0 || value === null || value === undefined) return "-";
  
  let displayValue = inThousands ? value / 1000 : value;
  const isNegative = displayValue < 0;
  const suffix = inThousands ? "K" : "";
  
  const absVal = Math.abs(displayValue);
  const formatted = absVal.toLocaleString(undefined, {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  });
  
  if (isNegative) {
    return `<span class="cf-negative">($${formatted}${suffix})</span>`;
  }
  return `$${formatted}${suffix}`;
}

function formatCFVariance(current, prior, inThousands = false) {
  if (current === null || prior === null) {
    return { diff: "-", pct: "-" };
  }
  
  const diff = current - prior;
  let displayDiff = inThousands ? diff / 1000 : diff;
  const suffix = inThousands ? "K" : "";
  
  const absDiff = Math.abs(displayDiff);
  const diffFormatted = absDiff.toLocaleString(undefined, {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  });
  
  let diffStr;
  if (diff < 0) {
    diffStr = `<span class="cf-negative">($${diffFormatted}${suffix})</span>`;
  } else if (diff === 0) {
    diffStr = "-";
  } else {
    diffStr = `$${diffFormatted}${suffix}`;
  }
  
  let pctStr = "-";
  if (prior !== 0) {
    const pctChange = ((current - prior) / Math.abs(prior)) * 100;
    if (pctChange > 1000) {
      pctStr = "1,000%+";
    } else if (pctChange < -1000) {
      pctStr = "<span class=\"cf-negative\">-1,000%+</span>";
    } else {
      const pctFormatted = pctChange.toLocaleString(undefined, {
        minimumFractionDigits: 1,
        maximumFractionDigits: 1
      });
      if (pctChange < 0) {
        pctStr = `<span class="cf-negative">${pctFormatted}%</span>`;
      } else {
        pctStr = `${pctFormatted}%`;
      }
    }
  }
  
  return { diff: diffStr, pct: pctStr };
}

function renderCashFlowStatement(skipDetailLevelReset = false) {
  if (!cfAccountGroups || !cfAccountGroups.cash_flow) {
    console.log("Cash flow groups not loaded yet");
    return;
  }
  
  showTableLoading('cashFlowTable', 'Updating...');
  
  requestAnimationFrame(() => {
    renderCashFlowContent(skipDetailLevelReset);
  });
}

function renderCashFlowContent(skipDetailLevelReset = false) {
  const viewMode = document.getElementById("cfViewMode").value;
  const periodType = document.getElementById("cfPeriodType").value;
  const periodValue = document.getElementById("cfPeriodSelect").value;
  const groups = cfAccountGroups.cash_flow.groups;
  const thead = document.getElementById("cfTableHead");
  const tbody = document.getElementById("cfTableBody");
  const footnote = document.getElementById("cfPartialFootnote");
  const showThousands = document.getElementById("cfShowThousands")?.checked || false;
  const detailLevel = document.querySelector('input[name="cfDetailLevel"]:checked')?.value || "summary";
  
  if (!skipDetailLevelReset) {
    applyCFDetailLevel(detailLevel);
  }
  updateReportHeader("cf");
  
  if (viewMode === "matrix") {
    renderCashFlowMatrix(skipDetailLevelReset);
    return;
  }
  
  if (!periodValue) return;
  
  const periodMonths = getCFPeriodMonths(periodType, periodValue);
  if (periodMonths.length === 0) {
    tbody.innerHTML = '<tr><td colspan="2">No data available for this period</td></tr>';
    return;
  }
  
  const compare = document.querySelector('input[name="cfCompareRadio"]:checked')?.value || "none";
  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  
  let currentLabel = "";
  if (periodType === "month") {
    const [y, mo] = periodValue.split("-");
    currentLabel = `${monthNames[parseInt(mo) - 1]} ${y}`;
  } else if (periodType === "quarter") {
    currentLabel = periodValue;
  } else if (periodType === "year") {
    currentLabel = periodValue;
  } else if (periodType === "ytd") {
    const match = periodValue.match(/(\d{4})-YTD-(\d+)/);
    if (match) {
      currentLabel = `YTD ${monthNames[parseInt(match[2]) - 1]} ${match[1]}`;
    }
  } else if (periodType === "ttm") {
    const match = periodValue.match(/TTM-(\d{4})-(\d{2})/);
    if (match) {
      currentLabel = `TTM ending ${monthNames[parseInt(match[2]) - 1]} ${match[1]}`;
    }
  }
  
  document.getElementById("cfDataAsOf").textContent = currentLabel;
  
  const rows = buildCashFlowRows(periodMonths, groups);
  
  let comparisonRows = null;
  let compPeriodLabel = "";
  
  if (compare !== "none") {
    let compPeriodMonths = [];
    if (compare === "prior_year") {
      if (periodType === "month") {
        const [y, mo] = periodValue.split("-");
        const priorYear = parseInt(y) - 1;
        compPeriodMonths = getCFPeriodMonths("month", `${priorYear}-${mo}`);
        compPeriodLabel = `${monthNames[parseInt(mo) - 1]} ${priorYear}`;
      } else if (periodType === "year") {
        const priorYear = parseInt(periodValue) - 1;
        compPeriodMonths = getCFPeriodMonths("year", String(priorYear));
        compPeriodLabel = String(priorYear);
      } else if (periodType === "quarter") {
        const match = periodValue.match(/(\d{4})-Q(\d)/);
        if (match) {
          const priorYear = parseInt(match[1]) - 1;
          const quarter = match[2];
          compPeriodMonths = getCFPeriodMonths("quarter", `${priorYear}-Q${quarter}`);
          compPeriodLabel = `${priorYear} Q${quarter}`;
        }
      } else if (periodType === "ytd") {
        const match = periodValue.match(/(\d{4})-YTD-(\d+)/);
        if (match) {
          const priorYear = parseInt(match[1]) - 1;
          const monthNum = match[2];
          compPeriodMonths = getCFPeriodMonths("ytd", `${priorYear}-YTD-${monthNum}`);
          compPeriodLabel = `YTD ${monthNames[parseInt(monthNum) - 1]} ${priorYear}`;
        }
      } else if (periodType === "ttm") {
        const match = periodValue.match(/TTM-(\d{4})-(\d{2})/);
        if (match) {
          const priorYear = parseInt(match[1]) - 1;
          const monthNum = match[2];
          compPeriodMonths = getCFPeriodMonths("ttm", `TTM-${priorYear}-${monthNum}`);
          compPeriodLabel = `TTM ending ${monthNames[parseInt(monthNum) - 1]} ${priorYear}`;
        }
      }
    } else if (compare === "prior_period") {
      const allMonths = getCFAvailableMonths();
      if (periodType === "month" && periodMonths.length > 0) {
        const idx = allMonths.indexOf(periodMonths[0]);
        if (idx > 0) {
          compPeriodMonths = [allMonths[idx - 1]];
          const [y, mo] = allMonths[idx - 1].split("-");
          compPeriodLabel = `${monthNames[parseInt(mo) - 1]} ${y}`;
        }
      } else if (periodType === "quarter") {
        const match = periodValue.match(/(\d{4})-Q(\d)/);
        if (match) {
          const year = parseInt(match[1]);
          const quarter = parseInt(match[2]);
          let priorYear = year;
          let priorQuarter = quarter - 1;
          if (priorQuarter < 1) {
            priorQuarter = 4;
            priorYear = year - 1;
          }
          compPeriodMonths = getCFPeriodMonths("quarter", `${priorYear}-Q${priorQuarter}`);
          compPeriodLabel = `${priorYear} Q${priorQuarter}`;
        }
      } else if (periodType === "year") {
        const priorYear = parseInt(periodValue) - 1;
        compPeriodMonths = getCFPeriodMonths("year", String(priorYear));
        compPeriodLabel = String(priorYear);
      }
    }
    
    if (compPeriodMonths.length > 0) {
      comparisonRows = buildCashFlowRows(compPeriodMonths, groups);
    }
  }
  
  let headerHtml = "<tr><th>Account</th>";
  if (comparisonRows) {
    headerHtml += `<th>${compPeriodLabel}</th><th>${currentLabel}</th><th class="var-col-left">$ Var</th><th>% Var</th>`;
  } else {
    headerHtml += `<th>${currentLabel}</th>`;
  }
  headerHtml += "</tr>";
  thead.innerHTML = headerHtml;
  
  let bodyHtml = "";
  
  rows.forEach((row, rowIdx) => {
    if (row.type === "spacer") {
      const colCount = comparisonRows ? 5 : 2;
      bodyHtml += `<tr class="is-spacer-row"><td colspan="${colCount}"></td></tr>`;
      return;
    }
    
    const visible = isCFRowVisible(groups, rowIdx);
    const hiddenClass = visible ? "" : "is-row-hidden";
    
    const typeClass = row.type === "header" ? "is-header" : 
                      row.type === "subtotal" ? "is-subtotal" : "is-detail";
    
    const indentClass = row.level > 0 ? `is-indent-${Math.min(row.level, 3)}` : "";
    
    let highlightClass = "";
    if (row.highlight === "operating") highlightClass = "cf-operating";
    else if (row.highlight === "investing") highlightClass = "cf-investing";
    else if (row.highlight === "financing") highlightClass = "cf-financing";
    else if (row.highlight === "netChange") highlightClass = "is-major-total";
    else if (row.highlight === "total") highlightClass = "is-major-total";
    
    let expandedClass = "";
    if (row.expandable && cfRowStates[row.id] === true) {
      expandedClass = "is-expanded-subtotal";
    }
    
    let toggleHtml = "";
    if (row.expandable) {
      const expanded = cfRowStates[row.id] === true;
      toggleHtml = `<span class="cf-toggle" data-row="${row.id}">${expanded ? "▼" : "▶"}</span>`;
    } else if (row.parent && detailLevel !== "detailed") {
      toggleHtml = `<span class="cf-toggle-placeholder"></span>`;
    }
    
    bodyHtml += `<tr class="${typeClass} ${indentClass} ${hiddenClass} ${highlightClass} ${expandedClass}" data-row-id="${row.id}">`;
    bodyHtml += `<td>${toggleHtml}${row.label}</td>`;
    
    if (row.type === "header") {
      if (comparisonRows) {
        bodyHtml += `<td></td><td></td><td></td><td></td>`;
      } else {
        bodyHtml += `<td></td>`;
      }
    } else if (comparisonRows) {
      const compRow = comparisonRows[rowIdx];
      const currentVal = row.value;
      const compVal = compRow ? compRow.value : 0;
      const variance = formatCFVariance(currentVal, compVal, showThousands);
      
      bodyHtml += `<td>${formatCFNumber(compVal, showThousands)}</td>`;
      bodyHtml += `<td>${formatCFNumber(currentVal, showThousands)}</td>`;
      bodyHtml += `<td class="var-col-left">${variance.diff}</td>`;
      bodyHtml += `<td>${variance.pct}</td>`;
    } else {
      bodyHtml += `<td>${formatCFNumber(row.value, showThousands)}</td>`;
    }
    
    bodyHtml += "</tr>";
  });
  
  tbody.innerHTML = bodyHtml;
  attachCFToggleListeners();
  setTimeout(() => {
    autoSizeFirstColumn("cashFlowTable");
    addResizeHandlesToTable("cashFlowTable");
    autoScaleFontSize("cashFlowTable", "cfTableBox");
    hideTableLoading('cashFlowTable');
  }, 50);
  
  const now = new Date();
  const currentMonthKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
  const hasPartial = periodMonths.includes(currentMonthKey);
  
  if (footnote) {
    if (hasPartial) {
      footnote.classList.remove("hidden");
    } else {
      footnote.classList.add("hidden");
    }
  }
}

function attachCFToggleListeners() {
  const toggles = document.querySelectorAll(".cf-toggle");
  toggles.forEach(toggle => {
    toggle.onclick = (e) => {
      e.stopPropagation();
      const rowId = toggle.dataset.row;
      cfRowStates[rowId] = !cfRowStates[rowId];
      
      // Re-render without resetting detail level states
      const viewMode = document.querySelector('input[name="cfViewMode"]:checked')?.value || "single";
      if (viewMode === "matrix") {
        renderCashFlowMatrix(true);
      } else {
        renderCashFlowStatement(true);
      }
    };
  });
}

function renderCashFlowMatrix(skipDetailLevelReset = false) {
  const periodType = document.getElementById("cfPeriodType").value;
  const periodSelect = document.getElementById("cfPeriodSelect");
  const yearStart = document.getElementById("cfMatrixYearStart")?.value;
  const yearEnd = document.getElementById("cfMatrixYearEnd")?.value;
  const showThousands = document.getElementById("cfShowThousands")?.checked || false;
  const showSubtotal = document.getElementById("cfShowSubtotal")?.checked || false;
  const groups = cfAccountGroups?.cash_flow?.groups;
  const thead = document.getElementById("cfTableHead");
  const tbody = document.getElementById("cfTableBody");
  const detailLevel = document.querySelector('input[name="cfDetailLevel"]:checked')?.value || "summary";
  
  if (!thead || !tbody || !groups) {
    console.error("Cash flow matrix: Missing required elements or groups");
    return;
  }
  
  if (!skipDetailLevelReset) {
    applyCFDetailLevel(detailLevel);
  }
  
  const periods = [];
  const allMonths = getCFAvailableMonths();
  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  
  const now = new Date();
  const currentMonthKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
  const excludeCurrent = document.getElementById("cfExcludeCurrent")?.checked || false;
  
  if (periodType === "year") {
    const startYr = parseInt(yearStart);
    const endYr = parseInt(yearEnd);
    for (let y = startYr; y <= endYr; y++) {
      let yearMonths = allMonths.filter(m => m.startsWith(y + "-"));
      if (excludeCurrent) {
        yearMonths = yearMonths.filter(m => m !== currentMonthKey);
      }
      if (yearMonths.length > 0) {
        periods.push({ label: String(y), months: yearMonths });
      }
    }
  } else if (periodType === "quarter") {
    const selYear = periodSelect.value || String(now.getFullYear());
    for (let q = 1; q <= 4; q++) {
      const startMonth = (q - 1) * 3 + 1;
      let quarterMonths = [];
      for (let m = startMonth; m < startMonth + 3; m++) {
        const key = `${selYear}-${String(m).padStart(2, "0")}`;
        if (allMonths.includes(key)) {
          if (excludeCurrent && key === currentMonthKey) continue;
          quarterMonths.push(key);
        }
      }
      if (quarterMonths.length > 0) {
        periods.push({ label: `Q${q}`, months: quarterMonths });
      }
    }
  } else if (periodType === "month") {
    const selYear = periodSelect.value || String(now.getFullYear());
    for (let m = 1; m <= 12; m++) {
      const key = `${selYear}-${String(m).padStart(2, "0")}`;
      if (excludeCurrent && key === currentMonthKey) continue;
      if (allMonths.includes(key)) {
        periods.push({ label: monthNames[m - 1], months: [key] });
      }
    }
  }
  
  if (periods.length === 0) {
    tbody.innerHTML = '<tr><td>No data available</td></tr>';
    return;
  }
  
  const allRowsData = periods.map(p => buildCashFlowRows(p.months, groups));
  
  const colCount = periods.length + 1 + (showSubtotal ? 1 : 0);
  
  let headerHtml = "<tr><th>Account</th>";
  periods.forEach(p => {
    headerHtml += `<th>${p.label}</th>`;
  });
  if (showSubtotal) {
    headerHtml += '<th class="is-subtotal-col">Subtotal</th>';
  }
  headerHtml += "</tr>";
  thead.innerHTML = headerHtml;
  
  let bodyHtml = "";
  const rows = allRowsData[0];
  
  rows.forEach((row, rowIdx) => {
    if (row.type === "spacer") {
      bodyHtml += `<tr class="is-spacer-row"><td colspan="${colCount}"></td></tr>`;
      return;
    }
    
    const visible = isCFRowVisible(groups, rowIdx);
    const hiddenClass = visible ? "" : "is-row-hidden";
    
    const typeClass = row.type === "header" ? "is-header" : 
                      row.type === "subtotal" ? "is-subtotal" : "is-detail";
    
    const indentClass = row.level > 0 ? `is-indent-${Math.min(row.level, 3)}` : "";
    
    let highlightClass = "";
    if (row.highlight === "operating") highlightClass = "cf-operating";
    else if (row.highlight === "investing") highlightClass = "cf-investing";
    else if (row.highlight === "financing") highlightClass = "cf-financing";
    else if (row.highlight === "netChange") highlightClass = "is-major-total";
    else if (row.highlight === "total") highlightClass = "is-major-total";
    
    let expandedClass = "";
    if (row.expandable && cfRowStates[row.id] === true) {
      expandedClass = "is-expanded-subtotal";
    }
    
    let toggleHtml = "";
    if (row.expandable) {
      const expanded = cfRowStates[row.id] === true;
      toggleHtml = `<span class="cf-toggle" data-row="${row.id}">${expanded ? "▼" : "▶"}</span>`;
    } else if (row.parent && detailLevel !== "detailed") {
      toggleHtml = `<span class="cf-toggle-placeholder"></span>`;
    }
    
    bodyHtml += `<tr class="${typeClass} ${indentClass} ${hiddenClass} ${highlightClass} ${expandedClass}" data-row-id="${row.id}">`;
    bodyHtml += `<td>${toggleHtml}${row.label}</td>`;
    
    let rowSubtotal = 0;
    allRowsData.forEach(periodRows => {
      const periodRow = periodRows[rowIdx];
      if (row.type === "header") {
        bodyHtml += `<td></td>`;
      } else {
        bodyHtml += `<td>${formatCFNumber(periodRow?.value, showThousands)}</td>`;
        rowSubtotal += periodRow?.value || 0;
      }
    });
    
    if (showSubtotal) {
      if (row.type === "header") {
        bodyHtml += '<td class="is-subtotal-col"></td>';
      } else {
        bodyHtml += `<td class="is-subtotal-col"><strong>${formatCFNumber(rowSubtotal, showThousands)}</strong></td>`;
      }
    }
    
    bodyHtml += "</tr>";
  });
  
  tbody.innerHTML = bodyHtml;
  attachCFToggleListeners();
  setTimeout(() => {
    addResizeHandlesToTable("cashFlowTable");
    autoScaleFontSize("cashFlowTable", "cfTableBox");
    hideTableLoading('cashFlowTable');
  }, 50);
}

function saveCashFlowConfig() {
  const config = {
    viewMode: document.getElementById("cfViewMode")?.value,
    periodType: document.getElementById("cfPeriodType")?.value,
    periodValue: document.getElementById("cfPeriodSelect")?.value,
    compare: document.querySelector('input[name="cfCompareRadio"]:checked')?.value,
    detailLevel: document.querySelector('input[name="cfDetailLevel"]:checked')?.value,
    showThousands: document.getElementById("cfShowThousands")?.checked,
    showSubtotal: document.getElementById("cfShowSubtotal")?.checked,
    excludeCurrent: document.getElementById("cfExcludeCurrent")?.checked,
    excludeSchwab: document.getElementById("cfExcludeSchwab")?.checked,
    matrixYearStart: document.getElementById("cfMatrixYearStart")?.value,
    matrixYearEnd: document.getElementById("cfMatrixYearEnd")?.value
  };
  saveUserPreferences({ cashFlow: config });
}

function loadCashFlowConfig() {
  const prefs = getUserPreferences();
  const cfg = prefs.cashFlow || {};
  
  if (cfg.viewMode) {
    const el = document.getElementById("cfViewMode");
    if (el) el.value = cfg.viewMode;
  }
  if (cfg.periodType) {
    const el = document.getElementById("cfPeriodType");
    if (el) el.value = cfg.periodType;
  }
  if (cfg.periodValue) {
    const el = document.getElementById("cfPeriodSelect");
    if (el && el.querySelector(`option[value="${cfg.periodValue}"]`)) el.value = cfg.periodValue;
  }
  if (cfg.compare) {
    const radio = document.querySelector(`input[name="cfCompareRadio"][value="${cfg.compare}"]`);
    if (radio) radio.checked = true;
  }
  if (cfg.detailLevel) {
    const radio = document.querySelector(`input[name="cfDetailLevel"][value="${cfg.detailLevel}"]`);
    if (radio) radio.checked = true;
  }
  if (cfg.showThousands !== undefined) {
    const el = document.getElementById("cfShowThousands");
    if (el) el.checked = cfg.showThousands;
  }
  if (cfg.showSubtotal !== undefined) {
    const el = document.getElementById("cfShowSubtotal");
    if (el) el.checked = cfg.showSubtotal;
  }
  const excludeEl = document.getElementById("cfExcludeCurrent");
  if (excludeEl) excludeEl.checked = cfg.excludeCurrent !== false;
  
  if (cfg.excludeSchwab !== undefined) {
    const el = document.getElementById("cfExcludeSchwab");
    if (el) el.checked = cfg.excludeSchwab;
  }
  if (cfg.matrixYearStart) {
    const el = document.getElementById("cfMatrixYearStart");
    if (el) {
      el.value = cfg.matrixYearStart;
      const label = document.getElementById("cfMatrixYearStartLabel");
      if (label) label.textContent = cfg.matrixYearStart;
    }
  }
  if (cfg.matrixYearEnd) {
    const el = document.getElementById("cfMatrixYearEnd");
    if (el) {
      el.value = cfg.matrixYearEnd;
      const label = document.getElementById("cfMatrixYearEndLabel");
      if (label) label.textContent = cfg.matrixYearEnd;
    }
  }
  
  // Update control visibility based on loaded config
  updateCFMatrixControlsVisibility();
}

function initCFAiAnalysis() {
  const analyzeBtn = document.getElementById("cfAiAnalyzeBtn");
  const panel = document.getElementById("cfAiAnalysisPanel");
  const header = document.getElementById("cfAiAnalysisHeader");
  
  if (analyzeBtn) {
    analyzeBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      performCFAiAnalysis();
    });
  }
  
  if (header) {
    header.addEventListener("click", (e) => {
      if (e.target === analyzeBtn || analyzeBtn.contains(e.target)) return;
      panel.classList.toggle("collapsed");
    });
  }
}

async function performCFAiAnalysis() {
  const analyzeBtn = document.getElementById("cfAiAnalyzeBtn");
  const panel = document.getElementById("cfAiAnalysisPanel");
  const contentContainer = document.getElementById("cfAiAnalysisContent");
  
  analyzeBtn.disabled = true;
  analyzeBtn.textContent = 'Analyzing...';
  panel.classList.remove("collapsed");
  contentContainer.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div>Analyzing your cash flow data...</div>';
  
  try {
    const statementData = extractCashFlowData();
    const periodInfo = getCashFlowPeriodInfo();
    
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit 
      ? "/api/analyze-cash-flow"
      : "/.netlify/functions/analyze-cash-flow";
    
    const response = await fetch(apiUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ statementData, periodInfo })
    });
    
    const result = await response.json();
    
    if (result.success && result.analysis) {
      contentContainer.innerHTML = formatMarkdown(result.analysis);
      panel.classList.add('has-analysis');
    } else {
      contentContainer.innerHTML = `<div style="color: #dc2626;">Error: ${result.error || "Failed to get analysis"}</div>`;
    }
  } catch (error) {
    console.error("AI Analysis error:", error);
    contentContainer.innerHTML = `<div style="color: #dc2626;">Error: ${error.message || "Failed to connect to AI service"}</div>`;
  } finally {
    analyzeBtn.disabled = false;
    analyzeBtn.textContent = 'Run Analysis';
  }
}

function extractCashFlowData() {
  const table = document.getElementById("cashFlowTable");
  if (!table) return "";
  
  let text = "";
  const rows = table.querySelectorAll("tr");
  
  rows.forEach(row => {
    if (row.classList.contains("is-spacer-row")) return;
    if (row.classList.contains("is-row-hidden")) return;
    
    const cells = row.querySelectorAll("th, td");
    const rowData = [];
    cells.forEach(cell => {
      let cellText = cell.textContent.trim();
      rowData.push(cellText);
    });
    text += rowData.join("\t") + "\n";
  });
  
  return text;
}

function getCashFlowPeriodInfo() {
  const viewMode = document.getElementById("cfViewMode").value;
  const periodType = document.getElementById("cfPeriodType").value;
  const periodSelect = document.getElementById("cfPeriodSelect");
  const compare = document.querySelector('input[name="cfCompareRadio"]:checked');
  
  let info = "";
  
  if (viewMode === "single") {
    info = `${periodType.toUpperCase()}: ${periodSelect.options[periodSelect.selectedIndex]?.text || ""}`;
  } else {
    if (periodType === "year") {
      const startYear = document.getElementById("cfMatrixYearStart").value;
      const endYear = document.getElementById("cfMatrixYearEnd").value;
      info = `Annual Matrix: ${startYear} - ${endYear}`;
    } else {
      info = `${periodType.toUpperCase()} Matrix: ${periodSelect.options[periodSelect.selectedIndex]?.text || ""}`;
    }
  }
  
  if (compare && compare.value !== "none") {
    info += ` (compared to ${compare.value.replace("_", " ")})`;
  }
  
  return info;
}

/* ------------------------------------------------------------
   PLACEHOLDER CONTENT
------------------------------------------------------------ */
const projectsEl = document.getElementById("projectsContent");
if (projectsEl) projectsEl.innerText = "Project data loads here.";

const operationsEl = document.getElementById("operationsContent");
if (operationsEl) operationsEl.innerText = "Operations metrics load here.";

const reportsEl = document.getElementById("reportsContent");
if (reportsEl) reportsEl.innerText = "Reports will appear here.";

/* ============================================================
   CASH BALANCES MODULE
============================================================ */
let cashReportsInitialized = false;
let cashData = { accounts: [], transactions: [] };
let cashChartInstance = null;
let cashSelectedAccounts = [];
let cashDailyBalances = {};
let cashTransactionsNeedRefresh = true;

// GL mode variables for TTM/5Y/All views
let cashGLMode = false; // true when showing GL data (TTM, 5Y, All)
let cashGLRange = null; // 'ttm', '5y', or 'all'
let cashGLData = null; // Cached GL data from financials_gl.json

// Cash/Investment GL accounts (excluding Schwab 1004)
const CASH_GL_ACCOUNTS = ['1001', '1003', '1005', '1006', '1007', '1040', '1090'];
const SCHWAB_ACCOUNT = '1004'; // Excluded from GL mode

async function loadCashGLData() {
  if (cashGLData) return cashGLData;
  
  try {
    const response = await fetch('/data/financials_gl.json');
    const text = await response.text();
    // Handle BOM if present
    const cleanText = text.charCodeAt(0) === 0xFEFF ? text.slice(1) : text;
    cashGLData = JSON.parse(cleanText);
    return cashGLData;
  } catch (error) {
    console.error('Error loading GL data:', error);
    return null;
  }
}

function getCashGLMonthlyData(range) {
  if (!cashGLData || !cashGLData.gl_history_all) return { labels: [], datasets: [] };
  
  const glHistory = cashGLData.gl_history_all;
  const accounts = cashGLData.accounts || [];
  
  // Get all month keys from the first entry
  const sampleEntry = glHistory[0] || {};
  const allMonthKeys = Object.keys(sampleEntry)
    .filter(k => /^\d{4}-\d{2}$/.test(k))
    .sort();
  
  if (allMonthKeys.length === 0) return { labels: [], datasets: [] };
  
  // Map account numbers to descriptions
  const accountDescriptions = {};
  accounts.forEach(acct => {
    accountDescriptions[acct.account_no] = acct.description;
  });
  
  // Calculate CUMULATIVE balances for each account from beginning (2015-01)
  // gl_history_all contains monthly ACTIVITY, so we sum from start to get cumulative balance
  const cumulativeByAccount = {};
  
  CASH_GL_ACCOUNTS.forEach(acctNo => {
    const acctEntry = glHistory.find(e => String(e.Account_Num) === acctNo || String(e.Account) === acctNo);
    if (acctEntry) {
      const desc = accountDescriptions[acctNo] || `Account ${acctNo}`;
      let runningTotal = 0;
      const cumulativeValues = [];
      
      // Sum activity from beginning to get cumulative balance at each month
      allMonthKeys.forEach(month => {
        const activity = acctEntry[month];
        const activityVal = activity === '' || activity === null || activity === undefined ? 0 : parseFloat(activity) || 0;
        runningTotal += activityVal;
        cumulativeValues.push({ month, balance: runningTotal });
      });
      
      cumulativeByAccount[desc] = cumulativeValues;
    }
  });
  
  // Filter months based on range for display
  // IMPORTANT: Only show through the LAST COMPLETE month (month before current)
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth() + 1;
  
  // Last complete month is the previous month
  let lastCompleteMonth, lastCompleteYear;
  if (currentMonth === 1) {
    lastCompleteMonth = 12;
    lastCompleteYear = currentYear - 1;
  } else {
    lastCompleteMonth = currentMonth - 1;
    lastCompleteYear = currentYear;
  }
  
  let startDate;
  if (range === 'ttm') {
    // Last 12 complete months (12 months ending at last complete month)
    startDate = new Date(lastCompleteYear, lastCompleteMonth - 12, 1);
  } else if (range === '5y') {
    // Last 5 years from last complete month
    startDate = new Date(lastCompleteYear - 5, lastCompleteMonth - 1, 1);
  } else {
    // All years
    startDate = new Date(2015, 0, 1);
  }
  
  const startKey = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}`;
  const endKey = `${lastCompleteYear}-${String(lastCompleteMonth).padStart(2, '0')}`;
  
  // Filter to only include months within range AND that exist in the data
  const filteredMonths = allMonthKeys.filter(m => m >= startKey && m <= endKey);
  
  // Extract cumulative values for filtered months
  const cashAccountData = {};
  Object.keys(cumulativeByAccount).forEach(acctDesc => {
    const allCumulative = cumulativeByAccount[acctDesc];
    const filteredValues = filteredMonths.map(month => {
      const entry = allCumulative.find(e => e.month === month);
      return entry ? entry.balance : 0;
    });
    cashAccountData[acctDesc] = filteredValues;
  });
  
  // Calculate totals for each month (sum of all account cumulative balances)
  const totals = filteredMonths.map((_, idx) => {
    return Object.values(cashAccountData).reduce((sum, values) => sum + (values[idx] || 0), 0);
  });
  
  // Format labels as "MMM YYYY"
  const labels = filteredMonths.map(m => {
    const [year, month] = m.split('-');
    const date = new Date(parseInt(year), parseInt(month) - 1, 1);
    return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
  });
  
  return {
    labels,
    months: filteredMonths,
    accountData: cashAccountData,
    totals,
    accountDescriptions
  };
}

async function initCashReports() {
  const headerEl = document.getElementById("cashCurrentHeader");
  const dailyTableEl = document.getElementById("dailyBalanceTableContainer");
  
  if (headerEl) headerEl.innerHTML = '<div class="loading-spinner">Loading...</div>';
  if (dailyTableEl) dailyTableEl.innerHTML = '<div class="loading-spinner">Calculating daily balances...</div>';
  
  try {
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit ? '/api/cash-data' : '/.netlify/functions/cash-data';
    
    const response = await fetch(apiUrl);
    const data = await response.json();
    
    if (!data.success) {
      if (headerEl) headerEl.innerHTML = `<div class="error-message">Error: ${data.error}</div>`;
      return;
    }
    
    cashData = data;
    
    // Initialize selected accounts - use FTG_BUILDERS_LABEL for combined accounts
    const ftgAccounts = getFTGBuildersAccounts(data.accounts);
    const otherAccounts = getNonFTGBuildersAccounts(data.accounts);
    cashSelectedAccounts = [];
    if (ftgAccounts.length > 0) {
      cashSelectedAccounts.push(FTG_BUILDERS_LABEL);
    }
    cashSelectedAccounts.push(...otherAccounts.map(a => a.name));
    
    // Build account checkboxes
    renderCashAccountCheckboxes(data.accounts);
    
    // Calculate all daily balances
    cashDailyBalances = calculateDailyBalances(data.accounts, data.transactions);
    
    // Setup event listeners
    setupCashEventListeners();
    
    // Initial render
    updateCashDisplay();
    updateCashDataAsOf(data.accounts);
    cashReportsInitialized = true;
    
  } catch (error) {
    console.error("Cash Balances error:", error);
    if (headerEl) headerEl.innerHTML = `<div class="error-message">Failed to load: ${error.message}</div>`;
  }
}

// FTG Builders combined accounts (accounts ending in 1883, 2469, 7554)
const FTG_BUILDERS_ACCOUNT_SUFFIXES = ['1883', '2469', '7554'];
const FTG_BUILDERS_LABEL = 'FTG Builders accounts';

function isFTGBuildersAccount(accountName) {
  return FTG_BUILDERS_ACCOUNT_SUFFIXES.some(suffix => accountName.includes(suffix));
}

function getFTGBuildersAccounts(accounts) {
  return accounts.filter(a => isFTGBuildersAccount(a.name));
}

function getNonFTGBuildersAccounts(accounts) {
  return accounts.filter(a => !isFTGBuildersAccount(a.name));
}

function renderCashAccountCheckboxes(accounts) {
  const container = document.getElementById("cashAccountCheckboxes");
  if (!container) return;
  
  const ftgAccounts = getFTGBuildersAccounts(accounts);
  const otherAccounts = getNonFTGBuildersAccounts(accounts);
  
  // Sort other accounts by balance
  const sortedOtherAccounts = [...otherAccounts].sort((a, b) => b.balance - a.balance);
  
  let html = '';
  
  // Add FTG Builders combined option first if there are FTG accounts
  if (ftgAccounts.length > 0) {
    const ftgTotalBalance = ftgAccounts.reduce((sum, a) => sum + a.balance, 0);
    html += `
      <label>
        <input type="checkbox" class="cash-account-cb" value="${FTG_BUILDERS_LABEL}" data-combined="true" checked>
        ${FTG_BUILDERS_LABEL}
      </label>
    `;
  }
  
  // Add other accounts
  sortedOtherAccounts.forEach(acct => {
    html += `
      <label>
        <input type="checkbox" class="cash-account-cb" value="${acct.name}" checked>
        ${acct.name}
      </label>
    `;
  });
  
  container.innerHTML = html;
}

function setupCashEventListeners() {
  // Select All / None buttons
  document.getElementById("cashSelectAll")?.addEventListener("click", () => {
    document.querySelectorAll(".cash-account-cb").forEach(cb => cb.checked = true);
    // Build selected accounts list with FTG_BUILDERS_LABEL for combined accounts
    const ftgAccounts = getFTGBuildersAccounts(cashData.accounts);
    const otherAccounts = getNonFTGBuildersAccounts(cashData.accounts);
    cashSelectedAccounts = [];
    if (ftgAccounts.length > 0) {
      cashSelectedAccounts.push(FTG_BUILDERS_LABEL);
    }
    cashSelectedAccounts.push(...otherAccounts.map(a => a.name));
    updateCashDisplay();
  });
  
  document.getElementById("cashSelectNone")?.addEventListener("click", () => {
    document.querySelectorAll(".cash-account-cb").forEach(cb => cb.checked = false);
    cashSelectedAccounts = [];
    updateCashDisplay();
  });
  
  // Individual checkboxes
  document.getElementById("cashAccountCheckboxes")?.addEventListener("change", (e) => {
    if (e.target.classList.contains("cash-account-cb")) {
      cashSelectedAccounts = Array.from(document.querySelectorAll(".cash-account-cb:checked")).map(cb => cb.value);
      updateCashDisplay();
    }
  });
  
  // Date range dropdown
  document.getElementById("cashDaysRange")?.addEventListener("change", (e) => {
    const customRangeDiv = document.getElementById("cashCustomDateRange");
    if (e.target.value === "custom") {
      customRangeDiv.style.display = "block";
      // Set default dates if not set
      const startInput = document.getElementById("cashStartDate");
      const endInput = document.getElementById("cashEndDate");
      const today = new Date();
      const thirtyDaysAgo = new Date(today);
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      
      if (!endInput.value) {
        endInput.value = today.toISOString().split('T')[0];
      }
      if (!startInput.value) {
        startInput.value = thirtyDaysAgo.toISOString().split('T')[0];
      }
      
      // Set min date based on oldest transaction
      if (cashData.transactions && cashData.transactions.length > 0) {
        const dates = cashData.transactions.map(t => new Date(t.date)).filter(d => !isNaN(d.getTime()));
        if (dates.length > 0) {
          const oldestDate = new Date(Math.min(...dates));
          startInput.min = oldestDate.toISOString().split('T')[0];
          endInput.min = oldestDate.toISOString().split('T')[0];
        }
      }
      endInput.max = today.toISOString().split('T')[0];
      startInput.max = today.toISOString().split('T')[0];
    } else {
      customRangeDiv.style.display = "none";
    }
    updateCashDisplay();
  });
  
  // Custom date inputs with validation
  document.getElementById("cashStartDate")?.addEventListener("change", (e) => {
    const oldestDate = getOldestTransactionDate();
    const today = new Date().toISOString().split('T')[0];
    
    if (oldestDate && e.target.value < oldestDate) {
      alert(`Cannot select a date before ${formatDateForDisplay(oldestDate)} (oldest transaction date)`);
      e.target.value = oldestDate;
    }
    if (e.target.value > today) {
      e.target.value = today;
    }
    // Ensure start date is not after end date
    const endDate = document.getElementById("cashEndDate")?.value;
    if (endDate && e.target.value > endDate) {
      e.target.value = endDate;
    }
    updateCashDisplay();
  });
  
  document.getElementById("cashEndDate")?.addEventListener("change", (e) => {
    const oldestDate = getOldestTransactionDate();
    const today = new Date().toISOString().split('T')[0];
    
    if (oldestDate && e.target.value < oldestDate) {
      alert(`Cannot select a date before ${formatDateForDisplay(oldestDate)} (oldest transaction date)`);
      e.target.value = oldestDate;
    }
    if (e.target.value > today) {
      e.target.value = today;
    }
    // Ensure end date is not before start date
    const startDate = document.getElementById("cashStartDate")?.value;
    if (startDate && e.target.value < startDate) {
      e.target.value = startDate;
    }
    updateCashDisplay();
  });
  
  // Stack bars / Show total / Data labels
  document.getElementById("cashStackBars")?.addEventListener("change", updateCashDisplay);
  document.getElementById("cashShowTotal")?.addEventListener("change", updateCashDisplay);
  document.getElementById("cashDataLabels")?.addEventListener("change", updateCashDisplay);
  
  // Range buttons below chart (new UI)
  document.querySelectorAll(".cash-range-btn").forEach(btn => {
    btn.addEventListener("click", async () => {
      const range = btn.dataset.range;
      const mode = btn.dataset.mode;
      const customRangeInline = document.getElementById("cashCustomRangeInline");
      
      // Update active button
      document.querySelectorAll(".cash-range-btn").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      
      // Check if switching to GL mode (TTM, 5Y, All)
      if (mode === "gl") {
        cashGLMode = true;
        cashGLRange = range;
        customRangeInline.style.display = "none";
        
        // Load GL data if not loaded
        if (!cashGLData) {
          const container = document.getElementById("cashCurrentHeader");
          if (container) container.innerHTML = '<div class="loading-spinner">Loading GL data...</div>';
          await loadCashGLData();
        }
        
        // Update chart title
        const chartTitle = document.querySelector('.cash-chart-section .chart-header h3');
        if (chartTitle) {
          const rangeLabel = range === 'ttm' ? 'TTM' : range === '5y' ? '5 Year' : 'All Years';
          chartTitle.textContent = `Monthly Cash Balances (${rangeLabel})`;
        }
        
        // Update tab label
        const balancesTab = document.querySelector('.cash-tab[data-tab="balances"]');
        if (balancesTab) balancesTab.textContent = 'Monthly Balances';
        
        updateCashDisplay();
      } else {
        // Bank mode (7D, 30D, 90D, Custom)
        cashGLMode = false;
        cashGLRange = null;
        
        // Restore chart title
        const chartTitle = document.querySelector('.cash-chart-section .chart-header h3');
        if (chartTitle) chartTitle.textContent = 'Daily Cash Balances';
        
        // Restore tab label
        const balancesTab = document.querySelector('.cash-tab[data-tab="balances"]');
        if (balancesTab) balancesTab.textContent = 'Daily Balances';
        
        if (range === "custom") {
          // Show inline custom date inputs
          customRangeInline.style.display = "flex";
          
          // Set default dates if not set
          const startInput = document.getElementById("cashCustomStartInline");
          const endInput = document.getElementById("cashCustomEndInline");
          const today = new Date();
          const thirtyDaysAgo = new Date(today);
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          
          if (!endInput.value) {
            endInput.value = today.toISOString().split('T')[0];
          }
          if (!startInput.value) {
            startInput.value = thirtyDaysAgo.toISOString().split('T')[0];
          }
        } else {
          // Hide custom inputs and update dropdown to match
          customRangeInline.style.display = "none";
          
          // Sync with the dropdown in config panel
          const dropdown = document.getElementById("cashDaysRange");
          if (dropdown) {
            dropdown.value = range;
            // Also hide the config panel custom range if visible
            const configCustomRange = document.getElementById("cashCustomDateRange");
            if (configCustomRange) configCustomRange.style.display = "none";
          }
          
          updateCashDisplay();
        }
      }
    });
  });
  
  // Apply custom range button (inline)
  document.getElementById("cashApplyCustomInline")?.addEventListener("click", () => {
    const startDate = document.getElementById("cashCustomStartInline")?.value;
    const endDate = document.getElementById("cashCustomEndInline")?.value;
    
    if (!startDate || !endDate) {
      alert("Please select both start and end dates");
      return;
    }
    
    if (startDate > endDate) {
      alert("Start date cannot be after end date");
      return;
    }
    
    // Sync with config panel dates and set to custom
    const dropdown = document.getElementById("cashDaysRange");
    if (dropdown) dropdown.value = "custom";
    
    const configStart = document.getElementById("cashStartDate");
    const configEnd = document.getElementById("cashEndDate");
    if (configStart) configStart.value = startDate;
    if (configEnd) configEnd.value = endDate;
    
    updateCashDisplay();
  });
  
  // Tab switching
  document.querySelectorAll(".cash-tab").forEach(tab => {
    tab.addEventListener("click", () => {
      const tabName = tab.dataset.tab;
      
      // Update tab buttons
      document.querySelectorAll(".cash-tab").forEach(t => t.classList.remove("active"));
      tab.classList.add("active");
      
      // Update tab content
      document.querySelectorAll(".cash-tab-content").forEach(c => c.classList.remove("active"));
      const content = document.getElementById(tabName === "balances" ? "cashTabBalances" : "cashTabTransactions");
      if (content) content.classList.add("active");
      
      // Render transaction table if switching to transactions tab
      if (tabName === "transactions") {
        renderCashTransactionTable();
        cashTransactionsNeedRefresh = false;
      }
    });
  });
}

let cashTxnByDateAccount = {};
let cashCurrentBalances = {};
let cashAccountNames = [];
let cashBalanceCache = {};
let cashOldestDate = null;

function initCashCalculations(accounts, transactions) {
  cashAccountNames = accounts.map(a => a.name);
  cashCurrentBalances = {};
  accounts.forEach(a => { cashCurrentBalances[a.name] = a.balance; });
  
  cashTxnByDateAccount = {};
  cashOldestDate = new Date();
  
  transactions.forEach(txn => {
    let dateKey = '';
    try {
      const d = new Date(txn.date);
      if (!isNaN(d.getTime())) {
        dateKey = d.toISOString().split('T')[0];
        if (d < cashOldestDate) cashOldestDate = d;
      }
    } catch (e) {}
    
    if (!dateKey) return;
    
    if (!cashTxnByDateAccount[dateKey]) cashTxnByDateAccount[dateKey] = {};
    if (!cashTxnByDateAccount[dateKey][txn.account]) cashTxnByDateAccount[dateKey][txn.account] = 0;
    cashTxnByDateAccount[dateKey][txn.account] += txn.amount;
  });
  
  cashBalanceCache = {};
  const today = new Date();
  const todayStr = today.toISOString().split('T')[0];
  cashBalanceCache[todayStr] = { ...cashCurrentBalances };
}

function getBalanceForDate(dateKey) {
  if (cashBalanceCache[dateKey]) {
    return cashBalanceCache[dateKey];
  }
  
  const today = new Date();
  const todayStr = today.toISOString().split('T')[0];
  const targetDate = new Date(dateKey + 'T12:00:00');
  
  let nearestCachedDate = null;
  let nearestCachedBalances = null;
  
  const cachedDates = Object.keys(cashBalanceCache).sort().reverse();
  for (const cached of cachedDates) {
    const cachedDateObj = new Date(cached + 'T12:00:00');
    if (cachedDateObj >= targetDate) {
      nearestCachedDate = cached;
      nearestCachedBalances = { ...cashBalanceCache[cached] };
      break;
    }
  }
  
  if (!nearestCachedDate) {
    nearestCachedDate = todayStr;
    nearestCachedBalances = { ...cashCurrentBalances };
  }
  
  const runningBalances = nearestCachedBalances;
  let current = new Date(nearestCachedDate + 'T12:00:00');
  
  while (current.toISOString().split('T')[0] > dateKey) {
    current.setDate(current.getDate() - 1);
    const currentKey = current.toISOString().split('T')[0];
    
    const txnsOnDate = cashTxnByDateAccount[currentKey] || {};
    cashAccountNames.forEach(acctName => {
      const txnAmount = txnsOnDate[acctName] || 0;
      runningBalances[acctName] = (runningBalances[acctName] || 0) - txnAmount;
    });
    
    cashBalanceCache[currentKey] = { ...runningBalances };
  }
  
  return cashBalanceCache[dateKey] || runningBalances;
}

function calculateDailyBalances(accounts, transactions) {
  initCashCalculations(accounts, transactions);
  return cashBalanceCache;
}

function updateCashDisplay() {
  renderCashCurrentHeader();
  renderCashChart();
  renderCashDailyTable();
  // Mark transactions as needing refresh
  cashTransactionsNeedRefresh = true;
  // If transactions tab is active, refresh immediately
  const transactionsTab = document.querySelector('.cash-tab[data-tab="transactions"]');
  if (transactionsTab && transactionsTab.classList.contains('active')) {
    renderCashTransactionTable();
    cashTransactionsNeedRefresh = false;
  }
}

function renderCashCurrentHeader() {
  const container = document.getElementById("cashCurrentHeader");
  if (!container) return;
  
  // GL mode header
  if (cashGLMode && cashGLData) {
    const glData = getCashGLMonthlyData(cashGLRange);
    if (glData.totals && glData.totals.length > 0) {
      const latestTotal = glData.totals[glData.totals.length - 1];
      const latestMonth = glData.labels[glData.labels.length - 1];
      const rangeLabel = cashGLRange === 'ttm' ? 'TTM' : cashGLRange === '5y' ? '5 Year' : 'All Years';
      
      container.innerHTML = `
        <div class="cash-header-content gl-mode">
          <div class="cash-header-total-section">
            <div class="cash-header-label">Cash & Investments (${rangeLabel} - GL Data, excl. Schwab)</div>
            <div class="cash-header-total">${formatCurrency(latestTotal)}</div>
            <div class="cash-header-sublabel">As of ${latestMonth}</div>
          </div>
        </div>
      `;
    }
    return;
  }
  
  // Build all available accounts list - FTG combined + individual accounts
  const ftgAccounts = getFTGBuildersAccounts(cashData.accounts);
  const otherAccounts = getNonFTGBuildersAccounts(cashData.accounts).sort((a, b) => b.balance - a.balance);
  
  // Build all display entries (for checkboxes)
  const allEntries = [];
  
  if (ftgAccounts.length > 0) {
    const ftgTotalBalance = ftgAccounts.reduce((sum, a) => sum + a.balance, 0);
    allEntries.push({
      name: FTG_BUILDERS_LABEL,
      balance: ftgTotalBalance,
      isSelected: cashSelectedAccounts.includes(FTG_BUILDERS_LABEL)
    });
  }
  
  otherAccounts.forEach(a => {
    allEntries.push({
      name: a.name,
      balance: a.balance,
      isSelected: cashSelectedAccounts.includes(a.name)
    });
  });
  
  if (allEntries.length === 0) {
    container.innerHTML = '<div style="padding:20px;text-align:center;opacity:0.6;">No accounts available</div>';
    return;
  }
  
  // Calculate total of selected accounts only
  const selectedEntries = allEntries.filter(a => a.isSelected);
  const total = selectedEntries.reduce((sum, a) => sum + a.balance, 0);
  
  // Build accounts list with checkboxes
  let accountsListHtml = '<div class="cash-header-accounts-grid with-checkboxes">';
  allEntries.forEach(a => {
    let shortName = a.name;
    const acctMatch = a.name.match(/\((\d+)\)$/);
    if (acctMatch) {
      const acctNum = acctMatch[1];
      const namePart = a.name.replace(/\s*\(\d+\)$/, '');
      shortName = namePart.length > 20 ? namePart.substring(0, 20) + '..' : namePart;
      shortName += ' (' + acctNum + ')';
    }
    
    let balanceDisplay = formatCurrency(a.balance);
    if (Math.abs(a.balance) >= 1000000) {
      balanceDisplay = '$' + (a.balance / 1000000).toFixed(2) + 'M';
    } else if (Math.abs(a.balance) >= 1000) {
      balanceDisplay = '$' + (a.balance / 1000).toFixed(1) + 'K';
    }
    
    const checkedAttr = a.isSelected ? 'checked' : '';
    const dimClass = a.isSelected ? '' : 'dimmed';
    
    accountsListHtml += `
      <div class="cash-header-account-item ${dimClass}">
        <label class="cash-acct-checkbox-label">
          <input type="checkbox" class="cash-acct-filter-checkbox" data-account="${a.name}" ${checkedAttr}>
          <span class="cash-acct-name" title="${a.name}">${shortName}</span>
        </label>
        <span class="cash-acct-value">${balanceDisplay}</span>
      </div>
    `;
  });
  accountsListHtml += '</div>';
  
  const selectedCount = selectedEntries.length;
  const totalCount = allEntries.length;
  
  container.innerHTML = `
    <div class="cash-header-left">
      <div class="cash-header-title">Current Total (${selectedCount}/${totalCount} accounts)</div>
      <div class="cash-header-total">${formatCurrency(total)}</div>
    </div>
    <div class="cash-header-right">
      ${accountsListHtml}
    </div>
  `;
  
  // Add checkbox event listeners
  container.querySelectorAll('.cash-acct-filter-checkbox').forEach(cb => {
    cb.addEventListener('change', (e) => {
      const accountName = e.target.dataset.account;
      if (e.target.checked) {
        if (!cashSelectedAccounts.includes(accountName)) {
          cashSelectedAccounts.push(accountName);
        }
      } else {
        cashSelectedAccounts = cashSelectedAccounts.filter(n => n !== accountName);
      }
      updateCashDisplay();
    });
  });
}

function getOldestTransactionDate() {
  if (!cashData.transactions || cashData.transactions.length === 0) return null;
  const dates = cashData.transactions
    .map(t => new Date(t.date))
    .filter(d => !isNaN(d.getTime()));
  if (dates.length === 0) return null;
  const oldestDate = new Date(Math.min(...dates));
  return oldestDate.toISOString().split('T')[0];
}

function getDailyDepositsAndPayments(dates, chartAccountsConfig) {
  const result = { deposits: {}, payments: {} };
  dates.forEach(d => {
    result.deposits[d] = 0;
    result.payments[d] = 0;
  });
  
  if (!cashData.transactions || cashData.transactions.length === 0) return result;
  
  // Build set of selected account names from chartAccountsConfig
  const selectedAccountNames = new Set();
  chartAccountsConfig.forEach(cfg => {
    cfg.accounts.forEach(acct => {
      selectedAccountNames.add(acct.name);
    });
  });
  
  if (selectedAccountNames.size === 0) return result;
  
  const excludePatterns = ['transfer', 'deposit system'];
  
  cashData.transactions.forEach(txn => {
    if (!txn.date || !txn.account) return;
    
    // Check if this transaction's account is in the selected set
    if (!selectedAccountNames.has(txn.account)) return;
    
    const txnDate = new Date(txn.date);
    if (isNaN(txnDate.getTime())) return;
    const dateKey = txnDate.toISOString().split('T')[0];
    
    if (!dates.includes(dateKey)) return;
    
    const desc = (txn.description || '').toLowerCase();
    const shouldExclude = excludePatterns.some(pattern => desc.includes(pattern));
    if (shouldExclude) return;
    
    const amount = parseFloat(txn.amount) || 0;
    if (amount === 0) return;
    
    if (amount > 0) {
      result.deposits[dateKey] += amount;
    } else {
      result.payments[dateKey] += Math.abs(amount);
    }
  });
  
  return result;
}

function formatDateForDisplay(dateStr) {
  const date = new Date(dateStr + 'T12:00:00');
  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
}

function getCashDateRange() {
  // First check the active button below the chart
  const activeBtn = document.querySelector(".cash-range-btn.active");
  let rangeValue = activeBtn?.dataset.range || document.getElementById("cashDaysRange")?.value || "90";
  
  const today = new Date();
  let startDate, endDate;
  
  if (rangeValue === "custom") {
    // Check inline custom inputs first, then config panel inputs
    let startInput = document.getElementById("cashCustomStartInline")?.value;
    let endInput = document.getElementById("cashCustomEndInline")?.value;
    
    // Fallback to config panel inputs
    if (!startInput || !endInput) {
      startInput = document.getElementById("cashStartDate")?.value;
      endInput = document.getElementById("cashEndDate")?.value;
    }
    
    if (startInput && endInput) {
      startDate = new Date(startInput + 'T12:00:00');
      endDate = new Date(endInput + 'T12:00:00');
    } else {
      // Fallback to 30 days if custom dates not set
      endDate = today;
      startDate = new Date(today);
      startDate.setDate(startDate.getDate() - 30);
    }
  } else {
    const daysRange = parseInt(rangeValue);
    endDate = today;
    startDate = new Date(today);
    startDate.setDate(startDate.getDate() - (daysRange - 1));
  }
  
  // Generate array of date strings
  const dates = [];
  const current = new Date(startDate);
  while (current <= endDate) {
    dates.push(current.toISOString().split('T')[0]);
    current.setDate(current.getDate() + 1);
  }
  
  return dates;
}

function renderCashChart() {
  const canvas = document.getElementById("cashChart");
  if (!canvas) return;
  
  // Check if in GL mode (TTM, 5Y, All)
  if (cashGLMode && cashGLData) {
    renderCashChartGL();
    return;
  }
  
  const isMobileView = window.innerWidth <= 768;
  const stackBars = document.getElementById("cashStackBars")?.checked !== false;
  // On mobile, default to no data labels unless explicitly enabled
  const dataLabelsCheckbox = document.getElementById("cashDataLabels");
  const showDataLabels = isMobileView ? false : (dataLabelsCheckbox?.checked === true);
  
  // Get dates to display using the new helper function
  const dates = getCashDateRange();
  
  // Check if FTG Builders is selected
  const ftgBuildersSelected = cashSelectedAccounts.includes(FTG_BUILDERS_LABEL);
  const ftgAccounts = getFTGBuildersAccounts(cashData.accounts);
  
  // Get individual selected accounts (non-FTG)
  const individualSelectedAccounts = cashData.accounts
    .filter(a => cashSelectedAccounts.includes(a.name) && !isFTGBuildersAccount(a.name))
    .sort((a, b) => b.balance - a.balance);
  
  // Build chart accounts list - FTG combined + individual accounts
  const chartAccountsConfig = [];
  
  if (ftgBuildersSelected && ftgAccounts.length > 0) {
    // Add FTG Builders as combined entry
    const ftgTotalBalance = ftgAccounts.reduce((sum, a) => sum + a.balance, 0);
    chartAccountsConfig.push({
      label: FTG_BUILDERS_LABEL,
      accounts: ftgAccounts,
      balance: ftgTotalBalance,
      isCombined: true
    });
  }
  
  // Add individual accounts
  individualSelectedAccounts.forEach(acct => {
    chartAccountsConfig.push({
      label: acct.name,
      accounts: [acct],
      balance: acct.balance,
      isCombined: false
    });
  });
  
  if (chartAccountsConfig.length === 0) {
    if (cashChartInstance) cashChartInstance.destroy();
    return;
  }
  
  // Colors for accounts
  const colors = ['#3b82f6', '#10b981', '#f59e0b', '#dc2626', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16'];
  
  // Get theme colors
  const isDarkMode = document.documentElement.getAttribute("data-theme") === "dark" || document.body.classList.contains("dark-mode");
  
  // Pre-calculate totals per date for data labels
  const dateTotals = dates.map(dateKey => {
    const balances = getBalanceForDate(dateKey);
    return chartAccountsConfig.reduce((sum, cfg) => {
      return sum + cfg.accounts.reduce((s, a) => s + (balances[a.name] || 0), 0);
    }, 0);
  });
  
  // Build datasets - last dataset in stack shows the total label
  const datasets = chartAccountsConfig.map((cfg, idx) => {
    const data = dates.map(dateKey => {
      const balances = getBalanceForDate(dateKey);
      // Sum balances for all accounts in this config (for combined FTG accounts)
      return cfg.accounts.reduce((sum, a) => sum + (balances[a.name] || 0), 0);
    });
    
    // Only the last (top) dataset shows data labels when stacked
    const isTopDataset = idx === chartAccountsConfig.length - 1;
    
    return {
      label: cfg.label,
      data: data,
      type: 'line',
      yAxisID: 'y',
      backgroundColor: colors[idx % colors.length] + '80',
      borderColor: colors[idx % colors.length],
      borderWidth: 2,
      fill: stackBars ? 'stack' : false,
      tension: 0.3,
      pointRadius: 0,
      pointHoverRadius: 4,
      order: 1,
      datalabels: (showDataLabels && stackBars && isTopDataset) ? {
        display: true,
        align: 'end',
        anchor: 'end',
        offset: 2,
        color: isDarkMode ? '#ffffff' : '#1e3a5f',
        font: { weight: 'bold', size: 10 },
        formatter: (value, context) => {
          // Show the total for this date, not just this segment
          const total = dateTotals[context.dataIndex];
          if (total === null || total === undefined) return '';
          const millions = total / 1000000;
          return '$' + millions.toFixed(1) + 'M';
        }
      } : { display: false }
    };
  });
  
  // Labels
  const labels = dates.map(d => {
    const date = new Date(d + 'T12:00:00');
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  });
  
  if (cashChartInstance) cashChartInstance.destroy();
  
  // Calculate min/max for Y-axis (balance lines only, not bar datasets)
  let allBalanceValues = [];
  datasets.forEach(ds => {
    if (ds.yAxisID === 'y') {
      allBalanceValues = allBalanceValues.concat(ds.data.filter(v => v !== null && v !== undefined));
    }
  });
  
  // For stacked lines, use the totals per date
  if (stackBars && chartAccountsConfig.length > 1) {
    allBalanceValues = dates.map(dateKey => {
      const balances = getBalanceForDate(dateKey);
      return chartAccountsConfig.reduce((sum, cfg) => {
        return sum + cfg.accounts.reduce((s, a) => s + (balances[a.name] || 0), 0);
      }, 0);
    });
  }
  
  const dataMin = allBalanceValues.length > 0 ? Math.min(...allBalanceValues) : 0;
  const dataMax = allBalanceValues.length > 0 ? Math.max(...allBalanceValues) : 10000000;
  
  // Round down to nearest million for min, round up for max
  const yMin = Math.floor(dataMin / 1000000) * 1000000;
  const yMax = Math.ceil(dataMax / 1000000) * 1000000;
  
  // Check if mobile for legend adjustments
  const isMobile = window.innerWidth <= 768;
  const themeColors = getChartThemeColors();
  
  cashChartInstance = new Chart(canvas, {
    type: 'line',
    data: { labels, datasets },
    plugins: showDataLabels ? [ChartDataLabels] : [],
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: {
        duration: 800,
        easing: 'easeOutQuart',
        delay: (context) => {
          let delay = 0;
          if (context.type === 'data' && context.mode === 'default') {
            delay = context.dataIndex * 30 + context.datasetIndex * 60;
          }
          return delay;
        }
      },
      transitions: {
        active: { animation: { duration: 200 } }
      },
      layout: {
        padding: { top: showDataLabels ? 25 : 0, bottom: isMobile ? 10 : 0 }
      },
      plugins: {
        legend: { 
          display: true, 
          position: 'bottom',
          labels: {
            color: themeColors.legendColor,
            boxWidth: isMobile ? 10 : 12,
            boxHeight: isMobile ? 10 : 12,
            padding: isMobile ? 6 : 10,
            font: { size: isMobile ? 9 : 11 },
            generateLabels: (chart) => {
              const original = Chart.defaults.plugins.legend.labels.generateLabels(chart);
              if (isMobile) {
                return original.map(label => {
                  // Shorten account names on mobile: keep first part and last 4 digits
                  let text = label.text;
                  const match = text.match(/\((\d+)\)$/);
                  if (match && text.length > 20) {
                    const acctNum = match[1];
                    const prefix = text.substring(0, 12).trim();
                    text = prefix + '..(' + acctNum + ')';
                  }
                  return { ...label, text };
                });
              }
              return original;
            }
          }
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatCurrency(ctx.raw)}`
          }
        },
        datalabels: { display: false }
      },
      scales: {
        x: { 
          stacked: stackBars,
          grid: { color: themeColors.gridColor },
          ticks: {
            color: themeColors.textColor,
            font: { size: isMobile ? 9 : 11 },
            maxRotation: isMobile ? 45 : 0,
            minRotation: isMobile ? 45 : 0
          }
        },
        y: {
          stacked: stackBars,
          position: 'left',
          min: yMin,
          max: yMax,
          grid: { color: themeColors.gridColor },
          ticks: {
            color: themeColors.textColor,
            font: { size: isMobile ? 10 : 12 },
            callback: v => {
              if (Math.abs(v) >= 1000000) return '$' + (v/1000000).toFixed(1) + 'M';
              if (Math.abs(v) >= 1000) return '$' + (v/1000).toFixed(0) + 'K';
              return '$' + v;
            }
          }
        }
      }
    }
  });
  
  // Update stats tiles
  updateCashStatsTiles(dates, chartAccountsConfig);
}

function updateCashStatsTiles(dates, accountsConfig) {
  const totals = dates.map(dateKey => {
    const balances = getBalanceForDate(dateKey);
    return {
      date: dateKey,
      total: accountsConfig.reduce((sum, cfg) => {
        return sum + cfg.accounts.reduce((s, a) => s + (balances[a.name] || 0), 0);
      }, 0)
    };
  });
  
  if (totals.length === 0) return;
  
  const avg = totals.reduce((sum, t) => sum + t.total, 0) / totals.length;
  const max = totals.reduce((m, t) => t.total > m.total ? t : m, totals[0]);
  const min = totals.reduce((m, t) => t.total < m.total ? t : m, totals[0]);
  
  const firstTotal = totals[0].total;
  const lastTotal = totals[totals.length - 1].total;
  const growth = firstTotal !== 0 ? ((lastTotal - firstTotal) / Math.abs(firstTotal)) * 100 : 0;
  
  const formatDate = (d) => new Date(d + 'T12:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  
  // Animate the stat values
  animateCurrency(document.getElementById("cashAvgValue"), avg, 600);
  animateCurrency(document.getElementById("cashMaxValue"), max.total, 600);
  document.getElementById("cashMaxDate").textContent = formatDate(max.date);
  animateCurrency(document.getElementById("cashMinValue"), min.total, 600);
  document.getElementById("cashMinDate").textContent = formatDate(min.date);
  const growthEl = document.getElementById("cashGrowthValue");
  if (growthEl) {
    if (growth < 0) {
      growthEl.className = "tile-value negative";
      growthEl.style.color = "#dc2626";
    } else {
      growthEl.className = "tile-value positive";
      growthEl.style.color = "#10b981";
    }
  }
  animatePercent(growthEl, growth, 600);
}

// GL Mode Chart Rendering (for TTM, 5Y, All)
function renderCashChartGL() {
  const canvas = document.getElementById("cashChart");
  if (!canvas) return;
  
  const glData = getCashGLMonthlyData(cashGLRange);
  if (!glData.labels || glData.labels.length === 0) {
    if (cashChartInstance) cashChartInstance.destroy();
    return;
  }
  
  const isMobileView = window.innerWidth <= 768;
  const stackBars = document.getElementById("cashStackBars")?.checked !== false;
  const dataLabelsCheckbox = document.getElementById("cashDataLabels");
  const showDataLabels = isMobileView ? false : (dataLabelsCheckbox?.checked === true);
  
  const isDarkMode = document.documentElement.getAttribute("data-theme") === "dark" || document.body.classList.contains("dark-mode");
  const themeColors = getChartThemeColors();
  
  // Colors for accounts
  const colors = ['#3b82f6', '#10b981', '#f59e0b', '#dc2626', '#8b5cf6', '#ec4899', '#06b6d4'];
  
  // Build datasets from GL account data
  const accountNames = Object.keys(glData.accountData);
  const datasets = accountNames.map((acctName, idx) => {
    const isTopDataset = idx === accountNames.length - 1;
    
    return {
      label: acctName,
      data: glData.accountData[acctName],
      backgroundColor: colors[idx % colors.length] + '80',
      borderColor: colors[idx % colors.length],
      borderWidth: 2,
      fill: stackBars ? 'stack' : false,
      tension: 0.3,
      pointRadius: 0,
      pointHoverRadius: 4,
      datalabels: (showDataLabels && stackBars && isTopDataset) ? {
        display: true,
        align: 'end',
        anchor: 'end',
        offset: 2,
        color: isDarkMode ? '#ffffff' : '#1e3a5f',
        font: { weight: 'bold', size: 10 },
        formatter: (value, context) => {
          const total = glData.totals[context.dataIndex];
          if (total === null || total === undefined) return '';
          const millions = total / 1000000;
          return '$' + millions.toFixed(1) + 'M';
        }
      } : { display: false }
    };
  });
  
  if (cashChartInstance) cashChartInstance.destroy();
  
  // Calculate Y-axis range with buffer for visibility
  const dataMin = Math.min(...glData.totals.filter(v => v !== 0));
  const dataMax = Math.max(...glData.totals);
  // Floor the min to nearest million, leaving some room below
  const yMin = Math.max(0, Math.floor((dataMin * 0.8) / 1000000) * 1000000);
  // Add 2-3 million buffer above max to prevent cutoff at top
  const yMaxRounded = Math.ceil(dataMax / 1000000) * 1000000;
  const yMax = yMaxRounded + 2000000;
  
  const isMobile = window.innerWidth <= 768;
  
  cashChartInstance = new Chart(canvas, {
    type: 'line',
    data: { labels: glData.labels, datasets },
    plugins: showDataLabels ? [ChartDataLabels] : [],
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: { duration: 800, easing: 'easeOutQuart' },
      layout: { padding: { top: showDataLabels ? 25 : 0 } },
      plugins: {
        legend: { 
          display: accountNames.length > 1, 
          position: 'bottom',
          labels: {
            color: themeColors.legendColor,
            boxWidth: isMobile ? 10 : 12,
            boxHeight: isMobile ? 10 : 12,
            padding: isMobile ? 6 : 10,
            font: { size: isMobile ? 9 : 11 }
          }
        },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatCurrency(ctx.raw)}`
          }
        },
        datalabels: { display: false }
      },
      scales: {
        x: { 
          stacked: stackBars,
          grid: { color: themeColors.gridColor },
          ticks: {
            color: themeColors.textColor,
            font: { size: isMobile ? 9 : 11 },
            maxRotation: 45,
            minRotation: 45,
            autoSkip: true,
            maxTicksLimit: isMobile ? 12 : 24
          }
        },
        y: {
          stacked: stackBars,
          min: yMin,
          max: yMax,
          grid: { color: themeColors.gridColor },
          ticks: {
            color: themeColors.textColor,
            font: { size: isMobile ? 10 : 12 },
            callback: v => {
              if (Math.abs(v) >= 1000000) return '$' + (v/1000000).toFixed(1) + 'M';
              if (Math.abs(v) >= 1000) return '$' + (v/1000).toFixed(0) + 'K';
              return '$' + v;
            }
          }
        }
      }
    }
  });
  
  // Update stats tiles for GL mode
  updateCashStatsTilesGL(glData);
}

function updateCashStatsTilesGL(glData) {
  if (!glData.totals || glData.totals.length === 0) return;
  
  const totals = glData.totals.map((total, idx) => ({
    date: glData.labels[idx],
    total
  }));
  
  const avg = totals.reduce((sum, t) => sum + t.total, 0) / totals.length;
  const max = totals.reduce((m, t) => t.total > m.total ? t : m, totals[0]);
  const min = totals.reduce((m, t) => t.total < m.total ? t : m, totals[0]);
  
  const firstTotal = totals[0].total;
  const lastTotal = totals[totals.length - 1].total;
  const growth = firstTotal !== 0 ? ((lastTotal - firstTotal) / Math.abs(firstTotal)) * 100 : 0;
  
  animateCurrency(document.getElementById("cashAvgValue"), avg, 600);
  animateCurrency(document.getElementById("cashMaxValue"), max.total, 600);
  document.getElementById("cashMaxDate").textContent = max.date;
  animateCurrency(document.getElementById("cashMinValue"), min.total, 600);
  document.getElementById("cashMinDate").textContent = min.date;
  
  const growthEl = document.getElementById("cashGrowthValue");
  if (growthEl) {
    // Show N/A for "All" range since starting balance is essentially zero (infinite growth)
    if (cashGLRange === 'all') {
      growthEl.className = "tile-value";
      growthEl.style.color = "";
      growthEl.textContent = "N/A";
    } else {
      growthEl.className = growth < 0 ? "tile-value negative" : "tile-value positive";
      growthEl.style.color = growth < 0 ? "#dc2626" : "#10b981";
      animatePercent(growthEl, growth, 600);
    }
  }
}

function renderCashDailyTable() {
  // Check if in GL mode
  if (cashGLMode && cashGLData) {
    renderCashDailyTableGL();
    return;
  }
  const container = document.getElementById("dailyBalanceTableContainer");
  if (!container) return;
  
  // Build display columns - FTG combined + individual accounts
  const ftgBuildersSelected = cashSelectedAccounts.includes(FTG_BUILDERS_LABEL);
  const ftgAccounts = getFTGBuildersAccounts(cashData.accounts);
  const individualSelectedAccounts = cashData.accounts
    .filter(a => cashSelectedAccounts.includes(a.name) && !isFTGBuildersAccount(a.name))
    .sort((a, b) => b.balance - a.balance);
  
  // Build column config
  const columnConfig = [];
  
  if (ftgBuildersSelected && ftgAccounts.length > 0) {
    columnConfig.push({
      label: FTG_BUILDERS_LABEL,
      accounts: ftgAccounts
    });
  }
  
  individualSelectedAccounts.forEach(a => {
    columnConfig.push({
      label: a.name,
      accounts: [a]
    });
  });
  
  if (columnConfig.length === 0) {
    container.innerHTML = '<div class="error-message">Select accounts to view data</div>';
    return;
  }
  
  // Get dates in reverse order (newest first) for table display
  const dates = getCashDateRange().reverse();
  const today = new Date();
  
  const todayStr = today.toISOString().split('T')[0];
  
  let html = `
    <div class="daily-balance-table-wrapper">
      <table class="daily-balance-table expanded">
        <thead>
          <tr>
            <th class="date-col">Date</th>
            ${columnConfig.map(cfg => `<th class="balance-col account-col">${cfg.label}</th>`).join('')}
            <th class="total-col">Total</th>
          </tr>
        </thead>
        <tbody>
  `;
  
  dates.forEach((dateKey, idx) => {
    const balances = getBalanceForDate(dateKey);
    let rowTotal = 0;
    
    const dateObj = new Date(dateKey + 'T12:00:00');
    const displayDate = dateObj.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
    
    const isToday = dateKey === todayStr;
    const rowClass = isToday ? 'today-row' : '';
    
    html += `<tr class="${rowClass}">`;
    html += `<td class="date-col">${isToday ? 'Today' : displayDate}</td>`;
    
    columnConfig.forEach(cfg => {
      // Sum balances for all accounts in this column
      const bal = cfg.accounts.reduce((sum, a) => sum + (balances[a.name] || 0), 0);
      rowTotal += bal;
      const balClass = bal < 0 ? 'negative' : '';
      html += `<td class="balance-col account-col ${balClass}">${formatCurrency(bal)}</td>`;
    });
    
    const totalClass = rowTotal < 0 ? 'negative' : '';
    html += `<td class="total-col ${totalClass}">${formatCurrency(rowTotal)}</td>`;
    html += `</tr>`;
  });
  
  html += `</tbody></table></div>`;
  container.innerHTML = html;
}

// GL Mode Table Rendering (for TTM, 5Y, All)
function renderCashDailyTableGL() {
  const container = document.getElementById("dailyBalanceTableContainer");
  if (!container) return;
  
  const glData = getCashGLMonthlyData(cashGLRange);
  if (!glData.labels || glData.labels.length === 0) {
    container.innerHTML = '<div class="error-message">No GL data available</div>';
    return;
  }
  
  const accountNames = Object.keys(glData.accountData);
  
  let html = `
    <div class="daily-balance-table-wrapper">
      <table class="daily-balance-table expanded">
        <thead>
          <tr>
            <th class="date-col">Month</th>
            ${accountNames.map(name => `<th class="balance-col account-col">${name}</th>`).join('')}
            <th class="total-col">Total</th>
          </tr>
        </thead>
        <tbody>
  `;
  
  // Reverse order for display (newest first)
  const reversedLabels = [...glData.labels].reverse();
  const reversedMonths = [...glData.months].reverse();
  const reversedTotals = [...glData.totals].reverse();
  
  reversedLabels.forEach((label, idx) => {
    const reverseIdx = glData.labels.length - 1 - idx;
    
    html += `<tr>`;
    html += `<td class="date-col">${label}</td>`;
    
    accountNames.forEach(acctName => {
      const val = glData.accountData[acctName][reverseIdx] || 0;
      const balClass = val < 0 ? 'negative' : '';
      html += `<td class="balance-col account-col ${balClass}">${formatCurrency(val)}</td>`;
    });
    
    const total = reversedTotals[idx];
    const totalClass = total < 0 ? 'negative' : '';
    html += `<td class="total-col ${totalClass}">${formatCurrency(total)}</td>`;
    html += `</tr>`;
  });
  
  html += `</tbody></table></div>`;
  container.innerHTML = html;
}

function renderCashTransactionTable() {
  const container = document.getElementById("transactionTableContainer");
  if (!container) return;
  
  // Get date range from the helper function
  const dateRange = getCashDateRange();
  const startDateStr = dateRange[0];
  const endDateStr = dateRange[dateRange.length - 1];
  
  const filteredTxns = cashData.transactions.filter(txn => {
    // Check if account is selected
    // FTG Builders accounts: if FTG_BUILDERS_LABEL is selected, include all FTG accounts
    const ftgBuildersSelected = cashSelectedAccounts.includes(FTG_BUILDERS_LABEL);
    const isFTG = isFTGBuildersAccount(txn.account);
    const isDirectlySelected = cashSelectedAccounts.includes(txn.account);
    
    if (!isDirectlySelected && !(ftgBuildersSelected && isFTG)) return false;
    
    // Check if within date range
    try {
      const txnDate = new Date(txn.date);
      const txnDateStr = txnDate.toISOString().split('T')[0];
      return txnDateStr >= startDateStr && txnDateStr <= endDateStr;
    } catch (e) {
      return false;
    }
  });
  
  // Sort by date descending (newest first)
  filteredTxns.sort((a, b) => {
    const dateA = new Date(a.date);
    const dateB = new Date(b.date);
    return dateB - dateA;
  });
  
  if (filteredTxns.length === 0) {
    container.innerHTML = '<div class="error-message" style="padding:20px;text-align:center;color:#6b7280;">No transactions found for selected accounts in this date range</div>';
    return;
  }
  
  let html = `
    <table class="transaction-table resizable-table">
      <thead>
        <tr>
          <th>Date<span class="resize-handle"></span></th>
          <th>Account<span class="resize-handle"></span></th>
          <th>Description<span class="resize-handle"></span></th>
          <th style="text-align:right;">Amount</th>
        </tr>
      </thead>
      <tbody>
  `;
  
  filteredTxns.forEach(txn => {
    const dateObj = new Date(txn.date);
    const displayDate = dateObj.toLocaleDateString('en-US', { 
      weekday: 'short', 
      month: 'short', 
      day: 'numeric' 
    });
    
    const amountClass = txn.amount >= 0 ? 'positive' : 'negative';
    const amountDisplay = formatCurrency(txn.amount);
    
    // Shorten account name for display
    let shortAccount = txn.account;
    const acctMatch = txn.account.match(/\((\d+)\)$/);
    if (acctMatch && txn.account.length > 25) {
      shortAccount = txn.account.substring(0, 18) + '..(' + acctMatch[1] + ')';
    }
    
    // Use description, fallback to payee if empty
    const descDisplay = txn.description || txn.payee || '-';
    
    html += `
      <tr>
        <td class="txn-date">${displayDate}</td>
        <td class="txn-account" title="${txn.account}">${shortAccount}</td>
        <td class="txn-description">${descDisplay}</td>
        <td class="txn-amount ${amountClass}">${amountDisplay}</td>
      </tr>
    `;
  });
  
  html += `</tbody></table>`;
  html += `<div style="padding:10px;text-align:center;color:#6b7280;font-size:12px;">${filteredTxns.length} transaction${filteredTxns.length !== 1 ? 's' : ''}</div>`;
  
  container.innerHTML = html;
  
  // Enable column resizing
  const table = container.querySelector('.resizable-table');
  if (table) {
    initTableColumnResize(table);
  }
}

function updateCashDataAsOf(accounts) {
  const el = document.getElementById("cashDataAsOf");
  if (el && accounts && accounts.length > 0) {
    const lastUpdate = accounts[0].lastUpdate;
    if (lastUpdate) {
      const date = new Date(lastUpdate);
      el.textContent = date.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit'
      });
    } else {
      const now = new Date();
      el.textContent = now.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      });
    }
  }
}

function initTransactionFilter() {
  const filterInput = document.getElementById("transactionFilterInput");
  const clearBtn = document.getElementById("transactionFilterClear");
  
  if (filterInput) {
    filterInput.addEventListener("input", function() {
      filterTransactionTable(this.value);
    });
  }
  
  if (clearBtn) {
    clearBtn.addEventListener("click", function() {
      if (filterInput) {
        filterInput.value = "";
        filterTransactionTable("");
      }
    });
  }
}

function filterTransactionTable(searchTerm) {
  const container = document.getElementById("transactionTableContainer");
  if (!container) return;
  
  const table = container.querySelector(".transaction-table");
  if (!table) return;
  
  const rows = table.querySelectorAll("tbody tr");
  const term = searchTerm.toLowerCase().trim();
  let visibleCount = 0;
  
  rows.forEach(row => {
    if (!term) {
      row.style.display = "";
      visibleCount++;
      return;
    }
    
    const text = row.textContent.toLowerCase();
    if (text.includes(term)) {
      row.style.display = "";
      visibleCount++;
    } else {
      row.style.display = "none";
    }
  });
  
  const countEl = container.querySelector("div[style*='text-align:center']");
  if (countEl && term) {
    countEl.textContent = `${visibleCount} matching transaction${visibleCount !== 1 ? 's' : ''} (filtered)`;
  }
}

document.addEventListener("DOMContentLoaded", function() {
  initTransactionFilter();
  initCashExportButtons();
});

function initCashExportButtons() {
  document.getElementById("exportDailyBalancesBtn")?.addEventListener("click", exportDailyBalancesToExcel);
  document.getElementById("exportTransactionsBtn")?.addEventListener("click", exportTransactionsToExcel);
}

async function exportDailyBalancesToExcel() {
  try {
    await LazyLoader.load('exceljs');
  } catch (err) {
    alert("Failed to load Excel library. Please check your internet connection.");
    return;
  }
  
  const container = document.getElementById("dailyBalanceTableContainer");
  if (!container) {
    alert("Daily balances container not found.");
    return;
  }
  
  const table = container.querySelector(".daily-balance-table");
  if (!table) {
    alert("No data to export. Please wait for data to load.");
    return;
  }
  
  const tbody = table.querySelector("tbody");
  if (!tbody || tbody.querySelectorAll("tr").length === 0) {
    alert("No balance data available to export.");
    return;
  }
  
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet("Daily Balances");
  
  // Get headers
  const headers = [];
  table.querySelectorAll("thead th").forEach(th => {
    headers.push(th.textContent.trim());
  });
  
  // Add header row with styling
  const headerRow = worksheet.addRow(headers);
  headerRow.eachCell(cell => {
    cell.font = { bold: true, color: { argb: "FFFFFFFF" } };
    cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FF3B82F6" } };
    cell.alignment = { horizontal: "center", vertical: "middle" };
    cell.border = {
      top: { style: "thin" },
      bottom: { style: "thin" },
      left: { style: "thin" },
      right: { style: "thin" }
    };
  });
  
  // Add data rows
  table.querySelectorAll("tbody tr").forEach(tr => {
    const rowData = [];
    tr.querySelectorAll("td").forEach((td, idx) => {
      let value = td.textContent.trim();
      if (idx > 0) {
        // Parse currency values
        const numMatch = value.replace(/[$,()]/g, '').trim();
        const num = parseFloat(numMatch);
        if (!isNaN(num)) {
          value = value.includes('(') ? -Math.abs(num) : num;
        }
      }
      rowData.push(value);
    });
    const dataRow = worksheet.addRow(rowData);
    
    // Style data cells
    dataRow.eachCell((cell, colNumber) => {
      cell.border = {
        top: { style: "thin", color: { argb: "FFE5E7EB" } },
        bottom: { style: "thin", color: { argb: "FFE5E7EB" } },
        left: { style: "thin", color: { argb: "FFE5E7EB" } },
        right: { style: "thin", color: { argb: "FFE5E7EB" } }
      };
      if (colNumber > 1 && typeof cell.value === "number") {
        cell.numFmt = '"$"#,##0.00_);[Red]("$"#,##0.00)';
        if (cell.value < 0) {
          cell.font = { color: { argb: "FFDC2626" } };
        }
      }
    });
  });
  
  // Auto-fit columns
  worksheet.columns.forEach((column, idx) => {
    column.width = idx === 0 ? 15 : 18;
  });
  
  // Generate and download
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  const dateRange = document.getElementById("cashDaysRange")?.value || "30";
  a.download = `Daily_Cash_Balances_${dateRange}_days_${new Date().toISOString().split('T')[0]}.xlsx`;
  a.click();
  URL.revokeObjectURL(url);
}

/* --------------------------------------------------------
   RESIZABLE TABLE COLUMNS
-------------------------------------------------------- */
function saveColumnWidths(tableId) {
  const table = document.getElementById(tableId);
  if (!table) return;
  
  const headers = table.querySelectorAll('thead th');
  const widths = [];
  headers.forEach(th => {
    widths.push(th.offsetWidth);
  });
  
  localStorage.setItem(`ftg_colWidths_${tableId}`, JSON.stringify(widths));
}

function loadColumnWidths(tableId) {
  const saved = localStorage.getItem(`ftg_colWidths_${tableId}`);
  if (!saved) return null;
  
  try {
    return JSON.parse(saved);
  } catch (e) {
    return null;
  }
}

function autoSizeColumns(tableId) {
  const table = document.getElementById(tableId);
  if (!table) return;
  
  const headers = table.querySelectorAll('thead th');
  const tbody = table.querySelector('tbody');
  if (!tbody) return;
  
  // Use requestAnimationFrame to avoid blocking
  requestAnimationFrame(() => {
    const tempSpan = document.createElement('span');
    tempSpan.style.cssText = 'position:absolute;visibility:hidden;white-space:nowrap;font:inherit;padding:0;';
    document.body.appendChild(tempSpan);
    
    // Cache computed styles to reduce reflows
    const headerFont = headers.length > 0 ? window.getComputedStyle(headers[0]).font : '13px Inter, sans-serif';
    
    headers.forEach((th, idx) => {
      let maxWidth = 0;
      
      // Measure header text
      const headerText = th.textContent.replace(/[\u2195\u2194]/g, '').trim();
      tempSpan.style.font = headerFont;
      tempSpan.style.fontWeight = 'bold';
      tempSpan.textContent = headerText;
      maxWidth = Math.max(maxWidth, tempSpan.offsetWidth + 40);
      
      // Sample only first 10 rows for performance
      const cells = tbody.querySelectorAll(`tr:not(.is-row-hidden) td:nth-child(${idx + 1})`);
      const sampleSize = Math.min(cells.length, 10);
      for (let i = 0; i < sampleSize; i++) {
        const cell = cells[i];
        const text = cell.textContent.trim();
        const indent = cell.style.paddingLeft ? parseInt(cell.style.paddingLeft) : 0;
        tempSpan.textContent = text;
        const cellWidth = tempSpan.offsetWidth + indent + 24;
        maxWidth = Math.max(maxWidth, cellWidth);
      }
      
      // Apply constraints
      const minWidth = idx === 0 ? 120 : 60;
      const maxAllowed = idx === 0 ? 350 : 200;
      const finalWidth = Math.min(Math.max(maxWidth, minWidth), maxAllowed);
      
      th.style.width = finalWidth + 'px';
      th.style.minWidth = finalWidth + 'px';
      th.style.maxWidth = finalWidth + 'px';
    });
    
    document.body.removeChild(tempSpan);
  });
}

function initTableColumnResize(table) {
  if (!table) return;
  
  const tableId = table.id;
  const headers = table.querySelectorAll('th');
  
  headers.forEach((th, idx) => {
    const handle = th.querySelector('.resize-handle');
    if (!handle) return;
    
    let startX, startWidth, column, colIndex;
    
    handle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      startX = e.pageX;
      column = th;
      colIndex = idx;
      startWidth = column.offsetWidth;
      
      handle.classList.add('resizing');
      table.classList.add('resizing');
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
    
    function onMouseMove(e) {
      if (!column) return;
      const diff = e.pageX - startX;
      const newWidth = Math.max(50, startWidth + diff);
      column.style.width = newWidth + 'px';
      column.style.minWidth = newWidth + 'px';
      column.style.maxWidth = newWidth + 'px';
    }
    
    function onMouseUp() {
      handle.classList.remove('resizing');
      table.classList.remove('resizing');
      column = null;
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      
      // Save column widths to localStorage
      saveColumnWidths(tableId);
    }
  });
}

function addResizeHandlesToTable(tableId) {
  const table = document.getElementById(tableId);
  if (!table) return;
  
  const headers = table.querySelectorAll('thead th');
  
  // Try to load saved widths first
  const savedWidths = loadColumnWidths(tableId);
  
  if (savedWidths && savedWidths.length === headers.length) {
    // Apply saved widths
    headers.forEach((th, idx) => {
      th.style.width = savedWidths[idx] + 'px';
      th.style.minWidth = savedWidths[idx] + 'px';
      th.style.maxWidth = savedWidths[idx] + 'px';
    });
  } else {
    // Auto-size columns based on content
    autoSizeColumns(tableId);
  }
  
  // Add resize handles
  headers.forEach((th, idx) => {
    // Don't add to last column
    if (idx < headers.length - 1) {
      // Only add if not already present
      if (!th.querySelector('.resize-handle')) {
        const handle = document.createElement('span');
        handle.className = 'resize-handle';
        handle.title = 'Drag to resize column';
        th.style.position = 'relative';
        th.appendChild(handle);
      }
    }
  });
  
  initTableColumnResize(table);
}

async function exportTransactionsToExcel() {
  try {
    await LazyLoader.load('exceljs');
  } catch (err) {
    alert("Failed to load Excel library. Please check your internet connection.");
    return;
  }
  
  const container = document.getElementById("transactionTableContainer");
  if (!container) {
    alert("Transactions container not found.");
    return;
  }
  
  const table = container.querySelector(".transaction-table");
  if (!table) {
    alert("No transactions to export. Please select accounts and a date range.");
    return;
  }
  
  const tbody = table.querySelector("tbody");
  const visibleRows = tbody ? Array.from(tbody.querySelectorAll("tr")).filter(tr => tr.style.display !== "none") : [];
  if (visibleRows.length === 0) {
    alert("No transactions match your current filter.");
    return;
  }
  
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet("Transactions");
  
  // Get headers
  const headers = [];
  table.querySelectorAll("thead th").forEach(th => {
    headers.push(th.textContent.trim());
  });
  
  // Add header row with styling
  const headerRow = worksheet.addRow(headers);
  headerRow.eachCell(cell => {
    cell.font = { bold: true, color: { argb: "FFFFFFFF" } };
    cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FF10B981" } };
    cell.alignment = { horizontal: "center", vertical: "middle" };
    cell.border = {
      top: { style: "thin" },
      bottom: { style: "thin" },
      left: { style: "thin" },
      right: { style: "thin" }
    };
  });
  
  // Add data rows (only visible ones if filtered)
  table.querySelectorAll("tbody tr").forEach(tr => {
    if (tr.style.display === "none") return; // Skip hidden rows
    
    const rowData = [];
    tr.querySelectorAll("td").forEach((td, idx) => {
      let value = td.textContent.trim();
      // Amount column (last column)
      if (idx === 3) {
        const numMatch = value.replace(/[$,()]/g, '').trim();
        const num = parseFloat(numMatch);
        if (!isNaN(num)) {
          value = value.includes('(') || td.classList.contains('negative') ? -Math.abs(num) : num;
        }
      }
      rowData.push(value);
    });
    const dataRow = worksheet.addRow(rowData);
    
    // Style data cells
    dataRow.eachCell((cell, colNumber) => {
      cell.border = {
        top: { style: "thin", color: { argb: "FFE5E7EB" } },
        bottom: { style: "thin", color: { argb: "FFE5E7EB" } },
        left: { style: "thin", color: { argb: "FFE5E7EB" } },
        right: { style: "thin", color: { argb: "FFE5E7EB" } }
      };
      // Format amount column
      if (colNumber === 4 && typeof cell.value === "number") {
        cell.numFmt = '"$"#,##0.00_);[Red]("$"#,##0.00)';
        if (cell.value < 0) {
          cell.font = { color: { argb: "FFDC2626" } };
        } else {
          cell.font = { color: { argb: "FF10B981" } };
        }
      }
    });
  });
  
  // Auto-fit columns
  worksheet.columns = [
    { width: 15 },  // Date
    { width: 30 },  // Account
    { width: 45 },  // Description
    { width: 15 }   // Amount
  ];
  
  // Generate and download
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `Cash_Transactions_${new Date().toISOString().split('T')[0]}.xlsx`;
  a.click();
  URL.revokeObjectURL(url);
}

// ========================================
// JOB BUDGETS MODULE
// ========================================

let jobBudgetsData = [];
let jobsDataAsOf = null;
let jobBudgetsFiltered = [];
let jobBudgetsCurrentPage = 1;
let jobBudgetsPageSize = 25;
let jobBudgetsSortColumn = 'revised_contract';
let jobBudgetsSortDirection = 'desc';
let jobBudgetsInitialized = false;
let jobBudgetsColumnFilters = {};

function initJobBudgets() {
  if (jobBudgetsInitialized && jobBudgetsData.length > 0) {
    renderJobBudgetsTable();
    return;
  }
  
  loadJobBudgetsData();
  setupJobBudgetsEventListeners();
  initBudgetsColumnPicker();
  jobBudgetsInitialized = true;
}

function setupJobBudgetsEventListeners() {
  // Status checkboxes
  document.getElementById('jobStatusActive')?.addEventListener('change', filterJobBudgets);
  document.getElementById('jobStatusInactive')?.addEventListener('change', filterJobBudgets);
  document.getElementById('jobStatusClosed')?.addEventListener('change', filterJobBudgets);
  document.getElementById('jobStatusOverhead')?.addEventListener('change', filterJobBudgets);
  
  // PM filter dropdown
  document.getElementById('jbPmFilter')?.addEventListener('change', filterJobBudgets);
  
  // Client filter dropdown
  document.getElementById('jbClientFilter')?.addEventListener('change', filterJobBudgets);
  
  // Individual search inputs with debounce
  let jbSearchTimeout;
  const jbJobNoSearch = document.getElementById('jbJobNoSearch');
  const jbDescriptionSearch = document.getElementById('jbDescriptionSearch');
  const jbClientSearch = document.getElementById('jbClientSearch');
  
  jbJobNoSearch?.addEventListener('input', () => {
    clearTimeout(jbSearchTimeout);
    jbSearchTimeout = setTimeout(filterJobBudgets, 300);
  });
  jbDescriptionSearch?.addEventListener('input', () => {
    clearTimeout(jbSearchTimeout);
    jbSearchTimeout = setTimeout(filterJobBudgets, 300);
  });
  jbClientSearch?.addEventListener('input', () => {
    clearTimeout(jbSearchTimeout);
    jbSearchTimeout = setTimeout(filterJobBudgets, 300);
  });
  
  // Pagination
  document.getElementById('jobPrevPage')?.addEventListener('click', () => {
    if (jobBudgetsCurrentPage > 1) {
      jobBudgetsCurrentPage--;
      renderJobBudgetsTable();
    }
  });
  
  document.getElementById('jobNextPage')?.addEventListener('click', () => {
    const totalPages = Math.ceil(jobBudgetsFiltered.length / jobBudgetsPageSize);
    if (jobBudgetsCurrentPage < totalPages) {
      jobBudgetsCurrentPage++;
      renderJobBudgetsTable();
    }
  });
  
  document.getElementById('jobPageSize')?.addEventListener('change', (e) => {
    jobBudgetsPageSize = parseInt(e.target.value);
    jobBudgetsCurrentPage = 1;
    renderJobBudgetsTable();
  });
  
  // Sort buttons (new dedicated sort controls)
  document.querySelectorAll('#jobBudgetsTable .sort-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const col = btn.dataset.sort;
      const dir = btn.dataset.dir;
      jobBudgetsSortColumn = col;
      jobBudgetsSortDirection = dir;
      updateJobBudgetsSortIndicators();
      sortJobBudgets();
      renderJobBudgetsTable();
    });
  });
  
  // Filter buttons
  document.querySelectorAll('#jobBudgetsTable .filter-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const filterCol = btn.dataset.filter;
      const dropdown = document.querySelector(`#jobBudgetsTable .column-filter-dropdown[data-filter="${filterCol}"]`);
      if (dropdown) {
        closeAllColumnFilterDropdowns();
        dropdown.classList.toggle('open');
        if (dropdown.classList.contains('open')) {
          positionFilterDropdown(btn, dropdown);
        }
        const searchInput = dropdown.querySelector('.filter-search-input');
        if (searchInput) searchInput.focus();
      }
    });
  });
  
  // Close filter dropdowns when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.column-filter-dropdown') && !e.target.closest('.filter-btn')) {
      closeAllColumnFilterDropdowns();
    }
  });
  
  // Expandable column toggles
  document.querySelectorAll('.job-budgets-table .expand-icon').forEach(icon => {
    icon.addEventListener('click', (e) => {
      e.stopPropagation();
      const type = icon.dataset.expand;
      const detailClass = type === 'contract' ? 'contract-detail-col' : 'cost-detail-col';
      
      icon.classList.toggle('expanded');
      
      // Toggle visibility of detail columns
      document.querySelectorAll(`.job-budgets-table .${detailClass}`).forEach(el => {
        el.classList.toggle('hidden');
      });
    });
  });
  
  // Quick sort buttons
  document.querySelectorAll('#jobBudgets .quick-sort-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const sortCol = btn.dataset.sort;
      const sortDir = btn.dataset.dir;
      
      // Update active state
      document.querySelectorAll('#jobBudgets .quick-sort-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // Set sort and re-render
      jobBudgetsSortColumn = sortCol;
      jobBudgetsSortDirection = sortDir;
      jobBudgetsCurrentPage = 1;
      sortJobBudgets();
      renderJobBudgetsTable();
    });
  });
  
  // Breakdown table expand/collapse buttons
  document.querySelectorAll('.breakdown-expand-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const targetId = btn.dataset.target;
      const tableWrapper = document.getElementById(targetId);
      const textSpan = btn.querySelector('.expand-text');
      const chartBox = btn.closest('.chart-box');
      
      if (tableWrapper) {
        const isCollapsed = tableWrapper.classList.contains('collapsed');
        tableWrapper.classList.toggle('collapsed');
        btn.classList.toggle('expanded');
        
        // Toggle table-expanded class on parent chart-box for desktop expansion
        if (chartBox) {
          chartBox.classList.toggle('table-expanded', isCollapsed);
        }
        
        if (textSpan) {
          textSpan.textContent = isCollapsed ? 'Collapse' : 'Expand';
        }
      }
    });
  });
}

async function loadJobBudgetsData() {
  const loadingOverlay = document.getElementById('jobBudgetsLoadingOverlay');
  if (loadingOverlay) loadingOverlay.classList.remove('hidden');
  
  try {
    // Fetch pre-computed job metrics from the canonical metrics API
    const metricsData = await DataCache.getJobsMetrics();
    const jobs = metricsData.jobs || [];
    
    // Map metrics API response to expected format for Job Budgets page
    jobBudgetsData = jobs.map(job => ({
      job_no: job.job_no,
      job_description: job.job_description,
      customer_name: job.customer_name,
      project_manager_name: job.project_manager,
      job_status: job.job_status,
      original_contract: job.original_contract || 0,
      tot_income_adj: job.tot_income_adj || 0,
      contract: job.contract,
      revised_contract: job.contract,
      original_cost: job.original_cost || 0,
      tot_cost_adj: job.tot_cost_adj || 0,
      revised_cost: job.budget_cost,
      profit: job.profit,
      margin: job.margin,
    }));
    // Initialize column filter dropdowns
    initJobBudgetsColumnFilters();
    updateJobBudgetsSortIndicators();
    
    // Build PM tabs
    populateJbPmTabs();
    
    // Set data as of date
    const dataAsOf = document.getElementById('jobBudgetsDataAsOf');
    if (dataAsOf && metricsData.generated_at) {
      dataAsOf.textContent = new Date(metricsData.generated_at).toLocaleDateString();
    }
    
    // Apply initial filter (Active only by default)
    filterJobBudgets();
  } catch (err) {
    console.error('Error loading job budgets:', err);
    document.getElementById('jobBudgetsTableBody').innerHTML = 
      '<tr><td colspan="12" class="loading-cell">Error loading job data</td></tr>';
  } finally {
    if (loadingOverlay) loadingOverlay.classList.add('hidden');
  }
}


function getMarginColor(margin) {
  // Returns background color based on profit margin
  // High margins (30%+) = green, 0% = yellow, negative = pinkish red
  if (margin >= 30) return 'rgba(16, 185, 129, 0.4)'; // Strong green
  if (margin >= 20) return 'rgba(16, 185, 129, 0.3)'; // Medium green
  if (margin >= 10) return 'rgba(16, 185, 129, 0.2)'; // Light green
  if (margin >= 5) return 'rgba(234, 179, 8, 0.2)'; // Light yellow-green
  if (margin >= 0) return 'rgba(234, 179, 8, 0.3)'; // Yellow
  if (margin >= -10) return 'rgba(239, 68, 68, 0.2)'; // Light pinkish red
  if (margin >= -20) return 'rgba(239, 68, 68, 0.3)'; // Medium pinkish red
  return 'rgba(239, 68, 68, 0.4)'; // Strong pinkish red
}

function getJobStatusLabel(status) {
  const statusMap = {
    'A': { label: 'Active', class: 'active' },
    'I': { label: 'Inactive', class: 'inactive' },
    'C': { label: 'Closed', class: 'closed' },
    'O': { label: 'Overhead', class: 'overhead' }
  };
  return statusMap[status] || { label: status, class: '' };
}

function filterJobBudgets() {
  const showActive = document.getElementById('jobStatusActive')?.checked;
  const showInactive = document.getElementById('jobStatusInactive')?.checked;
  const showClosed = document.getElementById('jobStatusClosed')?.checked;
  const showOverhead = document.getElementById('jobStatusOverhead')?.checked;
  
  const jobNoSearch = (document.getElementById('jbJobNoSearch')?.value || '').toLowerCase().trim();
  const descriptionSearch = (document.getElementById('jbDescriptionSearch')?.value || '').toLowerCase().trim();
  const clientSearch = (document.getElementById('jbClientSearch')?.value || '').toLowerCase().trim();
  
  // Get PM from tabs instead of dropdown
  const pmFilter = getSelectedPmForPage('jb');
  
  const allowedStatuses = [];
  if (showActive) allowedStatuses.push('A');
  if (showInactive) allowedStatuses.push('I');
  if (showClosed) allowedStatuses.push('C');
  if (showOverhead) allowedStatuses.push('O');
  
  jobBudgetsFiltered = jobBudgetsData.filter(job => {
    // Status filter from config panel
    if (allowedStatuses.length > 0 && !allowedStatuses.includes(job.job_status)) return false;
    
    // PM filter from tabs
    if (pmFilter && job.project_manager_name !== pmFilter) return false;
    
    // Individual search filters
    if (jobNoSearch && !(job.job_no || '').toLowerCase().includes(jobNoSearch)) return false;
    if (descriptionSearch && !(job.job_description || '').toLowerCase().includes(descriptionSearch)) return false;
    if (clientSearch && !(job.customer_name || '').toLowerCase().includes(clientSearch)) return false;
    
    // Column filters (multi-select)
    for (const [col, allowedValues] of Object.entries(jobBudgetsColumnFilters)) {
      if (allowedValues && allowedValues.size > 0) {
        let jobVal = job[col];
        if (col === 'job_status') {
          jobVal = getJobStatusLabel(jobVal).label;
        }
        jobVal = String(jobVal || '');
        if (!allowedValues.has(jobVal)) return false;
      }
    }
    
    return true;
  });
  
  jobBudgetsCurrentPage = 1;
  sortJobBudgets();
  updateJobSummaryMetrics();
  renderJobBudgetsTable();
}

function sortJobBudgets() {
  const col = jobBudgetsSortColumn;
  const dir = jobBudgetsSortDirection === 'asc' ? 1 : -1;
  
  jobBudgetsFiltered.sort((a, b) => {
    let aVal = a[col];
    let bVal = b[col];
    
    // Handle profit_margin (calculated field)
    if (col === 'profit_margin') {
      const aHasData = a.revised_contract > 0 && a.revised_cost > 0;
      const bHasData = b.revised_contract > 0 && b.revised_cost > 0;
      
      // Always push zero/incomplete jobs to the end
      if (!aHasData && bHasData) return 1;
      if (aHasData && !bHasData) return -1;
      if (!aHasData && !bHasData) return 0;
      
      const aMargin = (a.profit / a.revised_contract) * 100;
      const bMargin = (b.profit / b.revised_contract) * 100;
      return (aMargin - bMargin) * dir;
    }
    
    // Numeric columns
    if (['original_contract', 'tot_income_adj', 'revised_contract', 'original_cost', 
         'tot_cost_adj', 'revised_cost', 'profit'].includes(col)) {
      return (aVal - bVal) * dir;
    }
    
    // String columns
    aVal = (aVal || '').toString().toLowerCase();
    bVal = (bVal || '').toString().toLowerCase();
    return aVal.localeCompare(bVal) * dir;
  });
}

async function populateJbPmTabs() {
  // Build PM tabs using async loader to ensure PMs are available
  await loadAndBuildPmTabs('jbPmTabs', 'jb', () => {
    filterJobBudgets();
  });
}

function populateJbClientFilter() {
  const clients = [...new Set(jobBudgetsData.map(j => j.customer_name).filter(Boolean))].sort();
  const clientSelect = document.getElementById('jbClientFilter');
  if (clientSelect) {
    clientSelect.innerHTML = '<option value="">All Clients</option>' + 
      clients.map(c => `<option value="${c}">${c}</option>`).join('');
  }
}

function initJobBudgetsColumnFilters() {
  const filterableColumns = ['job_no', 'job_description', 'customer_name', 'job_status'];
  
  filterableColumns.forEach(col => {
    const dropdown = document.querySelector(`#jobBudgetsTable .column-filter-dropdown[data-filter="${col}"]`);
    if (!dropdown) return;
    
    const allUniqueValues = getUniqueColumnValues(col);
    jobBudgetsColumnFilters[col] = new Set();
    
    const columnLabel = getColumnLabel(col);
    
    dropdown.innerHTML = `
      <input type="text" class="filter-search-input" placeholder="Search ${columnLabel}..." data-filter="${col}">
      <div class="filter-quick-links">
        <span class="filter-quick-link" data-action="select-all">Select All</span>
        <span class="filter-quick-link" data-action="clear-all">Clear All</span>
      </div>
      <div class="filter-options-list"></div>
      <div class="filter-actions">
        <button class="filter-ok-btn" data-filter="${col}">OK</button>
        <button class="filter-cancel-btn" data-filter="${col}">Cancel</button>
      </div>
    `;
    
    function renderFilteredOptions(searchTerm = '') {
      const optionsList = dropdown.querySelector('.filter-options-list');
      if (!optionsList) return;
      
      const searchVal = searchTerm.toLowerCase();
      const filteredValues = searchVal
        ? allUniqueValues.filter(val => String(val).toLowerCase().includes(searchVal))
        : allUniqueValues;
      
      const displayValues = filteredValues.slice(0, 200);
      const remaining = filteredValues.length - displayValues.length;
      
      optionsList.innerHTML = displayValues.map(val => `
        <label class="filter-option">
          <input type="checkbox" value="${val}" checked>
          <span class="filter-option-text">${val}</span>
        </label>
      `).join('') + (remaining > 0 ? `<div class="filter-truncated-notice">${remaining} more values not shown. Use search to narrow down.</div>` : '');
      
      optionsList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        cb.addEventListener('click', (e) => e.stopPropagation());
      });
    }
    
    renderFilteredOptions();
    
    const searchInput = dropdown.querySelector('.filter-search-input');
    searchInput?.addEventListener('input', (e) => {
      renderFilteredOptions(e.target.value);
    });
    
    searchInput?.addEventListener('click', (e) => e.stopPropagation());
    
    dropdown.querySelector('.filter-quick-link[data-action="select-all"]')?.addEventListener('click', (e) => {
      e.stopPropagation();
      dropdown.querySelectorAll('.filter-option input').forEach(cb => cb.checked = true);
    });
    
    dropdown.querySelector('.filter-quick-link[data-action="clear-all"]')?.addEventListener('click', (e) => {
      e.stopPropagation();
      dropdown.querySelectorAll('.filter-option input').forEach(cb => cb.checked = false);
    });
    
    dropdown.querySelector('.filter-ok-btn')?.addEventListener('click', (e) => {
      e.stopPropagation();
      applyColumnFilter(col);
      closeAllColumnFilterDropdowns();
    });
    
    dropdown.querySelector('.filter-cancel-btn')?.addEventListener('click', (e) => {
      e.stopPropagation();
      closeAllColumnFilterDropdowns();
    });
  });
}

function getUniqueColumnValues(col) {
  const values = new Set();
  jobBudgetsData.forEach(job => {
    let val = job[col];
    if (col === 'job_status') {
      val = getJobStatusLabel(val).label;
    }
    if (val !== null && val !== undefined && val !== '') {
      values.add(String(val));
    }
  });
  return Array.from(values).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
}

function getColumnLabel(col) {
  const labels = {
    'job_no': 'Job #',
    'job_description': 'Description',
    'customer_name': 'Client',
    'job_status': 'Status',
    'project_manager_name': 'Project Manager'
  };
  return labels[col] || col;
}

function populateFilterOptions(col, values) {
  const dropdown = document.querySelector(`#jobBudgetsTable .column-filter-dropdown[data-filter="${col}"]`);
  const optionsList = dropdown?.querySelector('.filter-options-list');
  if (!optionsList) return;
  
  optionsList.innerHTML = values.map(val => `
    <label class="filter-option">
      <input type="checkbox" value="${val}" checked>
      <span class="filter-option-text">${val}</span>
    </label>
  `).join('');
  
  optionsList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
    cb.addEventListener('change', () => applyColumnFilter(col));
    cb.addEventListener('click', (e) => e.stopPropagation());
  });
}

function applyColumnFilter(col) {
  const dropdown = document.querySelector(`#jobBudgetsTable .column-filter-dropdown[data-filter="${col}"]`);
  const checkedValues = new Set();
  dropdown?.querySelectorAll('.filter-option input:checked').forEach(cb => {
    checkedValues.add(cb.value);
  });
  
  const allCheckboxes = dropdown?.querySelectorAll('.filter-option input');
  const allChecked = allCheckboxes && [...allCheckboxes].every(cb => cb.checked);
  const noneChecked = allCheckboxes && [...allCheckboxes].every(cb => !cb.checked);
  
  if (allChecked || noneChecked) {
    delete jobBudgetsColumnFilters[col];
  } else {
    jobBudgetsColumnFilters[col] = checkedValues;
  }
  
  updateFilterButtonIndicators();
  filterJobBudgets();
}

function updateFilterButtonIndicators() {
  document.querySelectorAll('#jobBudgetsTable .filter-btn').forEach(btn => {
    const col = btn.dataset.filter;
    const hasFilter = jobBudgetsColumnFilters[col] && jobBudgetsColumnFilters[col].size > 0;
    btn.classList.toggle('has-filter', hasFilter);
  });
}

function positionFilterDropdown(btn, dropdown) {
  const btnRect = btn.getBoundingClientRect();
  const dropdownHeight = 280;
  const viewportHeight = window.innerHeight;
  const margin = 10;
  
  dropdown.style.position = 'fixed';
  dropdown.style.left = `${Math.max(margin, Math.min(btnRect.left, window.innerWidth - 240))}px`;
  
  if (btnRect.bottom + dropdownHeight > viewportHeight - margin) {
    dropdown.style.top = `${Math.max(margin, btnRect.top - dropdownHeight)}px`;
  } else {
    dropdown.style.top = `${btnRect.bottom + 4}px`;
  }
}

function closeAllColumnFilterDropdowns() {
  document.querySelectorAll('.column-filter-dropdown.open').forEach(d => {
    d.classList.remove('open');
    d.style.position = '';
    d.style.top = '';
    d.style.left = '';
  });
}

function updateJobBudgetsSortIndicators() {
  document.querySelectorAll('#jobBudgetsTable .sort-btn').forEach(btn => {
    const isActive = btn.dataset.sort === jobBudgetsSortColumn && btn.dataset.dir === jobBudgetsSortDirection;
    btn.classList.toggle('active', isActive);
  });
}

function updateJobSummaryMetrics() {
  // Use filtered data based on PM tabs and status checkboxes
  const jobs = jobBudgetsFiltered || [];
  const totalJobs = jobs.length;
  const totalContract = jobs.reduce((sum, j) => sum + j.revised_contract, 0);
  const totalCost = jobs.reduce((sum, j) => sum + j.revised_cost, 0);
  const totalProfit = jobs.reduce((sum, j) => sum + j.profit, 0);
  
  // Calculate avg margin excluding jobs with zero revised_contract OR zero revised_cost
  // Use weighted average (total profit / total contract) to match Job Overview calculation
  const jobsWithValidMargin = jobs.filter(j => 
    parseFloat(j.revised_contract) > 0 && parseFloat(j.revised_cost) > 0
  );
  let avgMargin = 0;
  if (jobsWithValidMargin.length > 0) {
    const totalContractForMargin = jobsWithValidMargin.reduce((sum, j) => sum + (parseFloat(j.revised_contract) || 0), 0);
    const totalCostForMargin = jobsWithValidMargin.reduce((sum, j) => sum + (parseFloat(j.revised_cost) || 0), 0);
    const totalProfitForMargin = totalContractForMargin - totalCostForMargin;
    avgMargin = totalContractForMargin > 0 ? (totalProfitForMargin / totalContractForMargin) * 100 : 0;
  }
  
  document.getElementById('jobTotalCount').textContent = totalJobs.toLocaleString();
  document.getElementById('jobTotalContract').textContent = formatCurrencyCompact(totalContract);
  document.getElementById('jobTotalCost').textContent = formatCurrencyCompact(totalCost);
  
  const profitEl = document.getElementById('jobTotalProfit');
  profitEl.textContent = formatCurrencyCompact(totalProfit);
  profitEl.className = 'metric-value ' + (totalProfit >= 0 ? '' : 'negative');
  
  const marginEl = document.getElementById('jobAvgMargin');
  marginEl.textContent = avgMargin.toFixed(1) + '%';
  marginEl.className = 'metric-value ' + (avgMargin >= 0 ? '' : 'negative');
  
  // Render breakdowns
  renderJobBreakdowns();
}

let pmDonutChart = null;
let customerDonutChart = null;

const chartColors = [
  '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6',
  '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1',
  '#94a3b8' // Gray for "Other"
];

function renderJobBreakdowns() {
  renderJobBreakdownByPm();
  renderJobBreakdownByCustomer();
  renderPmDonutChart();
  renderCustomerDonutChart();
}

function renderDonutLegend(labels, data, colors, containerId) {
  const container = document.getElementById(containerId);
  if (!container) return;
  
  const total = data.reduce((a, b) => a + b, 0);
  
  container.innerHTML = labels.map((label, i) => {
    const value = data[i];
    const pct = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
    return `
      <div class="donut-legend-item">
        <div class="donut-legend-color" style="background-color: ${colors[i]}"></div>
        <span class="donut-legend-label">${label}</span>
        <span class="donut-legend-value">${pct}%</span>
      </div>
    `;
  }).join('');
}

function renderPmDonutChart() {
  const canvas = document.getElementById('pmDonutChart');
  if (!canvas) return;
  
  // Aggregate by Project Manager - use filtered data
  const jobs = jobBudgetsFiltered || [];
  const pmMap = new Map();
  jobs.forEach(job => {
    const pm = job.project_manager_name || 'Unassigned';
    if (!pmMap.has(pm)) {
      pmMap.set(pm, 0);
    }
    pmMap.set(pm, pmMap.get(pm) + job.contract);
  });
  
  // Sort by contract value and get top 10
  const sorted = [...pmMap.entries()]
    .sort((a, b) => b[1] - a[1]);
  
  const top10 = sorted.slice(0, 10);
  const otherTotal = sorted.slice(10).reduce((sum, [, val]) => sum + val, 0);
  
  const labels = top10.map(([name]) => name);
  const data = top10.map(([, val]) => val);
  
  if (otherTotal > 0) {
    labels.push('Other');
    data.push(otherTotal);
  }
  
  const isDarkMode = document.documentElement.getAttribute("data-theme") === "dark" || document.body.classList.contains('dark-mode');
  const colors = chartColors.slice(0, labels.length);
  
  if (pmDonutChart) {
    pmDonutChart.destroy();
  }
  
  pmDonutChart = new Chart(canvas, {
    type: 'doughnut',
    data: {
      labels: labels,
      datasets: [{
        data: data,
        backgroundColor: colors,
        borderWidth: 2,
        borderColor: isDarkMode ? '#1e293b' : '#ffffff'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: true,
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          callbacks: {
            title: function(context) {
              return labels[context[0].dataIndex];
            },
            label: function(context) {
              const value = context.raw;
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const pct = ((value / total) * 100).toFixed(1);
              return `${formatCurrencyCompact(value)} (${pct}%)`;
            }
          }
        }
      }
    }
  });
  
  renderDonutLegend(labels, data, colors, 'pmDonutLegend');
}

function renderCustomerDonutChart() {
  const canvas = document.getElementById('customerDonutChart');
  if (!canvas) return;
  
  // Aggregate by Customer - use filtered data
  const jobs = jobBudgetsFiltered || [];
  const custMap = new Map();
  jobs.forEach(job => {
    const cust = job.customer_name || 'Unknown';
    if (!custMap.has(cust)) {
      custMap.set(cust, 0);
    }
    custMap.set(cust, custMap.get(cust) + job.contract);
  });
  
  // Sort by contract value and get top 10
  const sorted = [...custMap.entries()]
    .sort((a, b) => b[1] - a[1]);
  
  const top10 = sorted.slice(0, 10);
  const otherTotal = sorted.slice(10).reduce((sum, [, val]) => sum + val, 0);
  
  const labels = top10.map(([name]) => name);
  const data = top10.map(([, val]) => val);
  
  if (otherTotal > 0) {
    labels.push('Other');
    data.push(otherTotal);
  }
  
  const isDarkMode = document.documentElement.getAttribute("data-theme") === "dark" || document.body.classList.contains('dark-mode');
  const colors = chartColors.slice(0, labels.length);
  
  if (customerDonutChart) {
    customerDonutChart.destroy();
  }
  
  customerDonutChart = new Chart(canvas, {
    type: 'doughnut',
    data: {
      labels: labels,
      datasets: [{
        data: data,
        backgroundColor: colors,
        borderWidth: 2,
        borderColor: isDarkMode ? '#1e293b' : '#ffffff'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: true,
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          callbacks: {
            title: function(context) {
              return labels[context[0].dataIndex];
            },
            label: function(context) {
              const value = context.raw;
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const pct = ((value / total) * 100).toFixed(1);
              return `${formatCurrencyCompact(value)} (${pct}%)`;
            }
          }
        }
      }
    }
  });
  
  renderDonutLegend(labels, data, colors, 'customerDonutLegend');
}

function renderJobBreakdownByPm() {
  const tbody = document.getElementById('jobPmBreakdownBody');
  if (!tbody) return;
  
  // Aggregate by Project Manager - use filtered data
  const jobs = jobBudgetsFiltered || [];
  const pmMap = new Map();
  jobs.forEach(job => {
    const pm = job.project_manager_name || 'Unassigned';
    if (!pmMap.has(pm)) {
      pmMap.set(pm, { jobs: 0, contract: 0, cost: 0, profit: 0 });
    }
    const data = pmMap.get(pm);
    data.jobs++;
    data.contract += job.contract;
    data.cost += job.revised_cost;
    data.profit += job.profit;
  });
  
  // Sort by contract value descending
  const sorted = [...pmMap.entries()]
    .map(([pm, data]) => ({
      name: pm,
      ...data,
      margin: data.contract > 0 ? (data.profit / data.contract) * 100 : 0
    }))
    .sort((a, b) => b.contract - a.contract);
  
  if (sorted.length === 0) {
    tbody.innerHTML = '<tr><td colspan="6" class="loading-cell">No data</td></tr>';
    return;
  }
  
  // Top 10 + Other (like the donut chart)
  const top10 = sorted.slice(0, 10);
  const others = sorted.slice(10);
  
  let displayRows = [...top10];
  if (others.length > 0) {
    const otherData = others.reduce((acc, row) => ({
      name: 'Other',
      jobs: acc.jobs + row.jobs,
      contract: acc.contract + row.contract,
      cost: acc.cost + row.cost,
      profit: acc.profit + row.profit
    }), { name: 'Other', jobs: 0, contract: 0, cost: 0, profit: 0 });
    otherData.margin = otherData.contract > 0 ? (otherData.profit / otherData.contract) * 100 : 0;
    displayRows.push(otherData);
  }
  
  // Calculate totals for subtotal row
  const totals = displayRows.reduce((acc, row) => ({
    jobs: acc.jobs + row.jobs,
    contract: acc.contract + row.contract,
    cost: acc.cost + row.cost,
    profit: acc.profit + row.profit
  }), { jobs: 0, contract: 0, cost: 0, profit: 0 });
  totals.margin = totals.contract > 0 ? (totals.profit / totals.contract) * 100 : 0;
  
  const rowsHtml = displayRows.map(row => {
    const profitClass = row.profit >= 0 ? 'positive' : 'negative';
    const marginColor = getMarginColor(row.margin);
    return `<tr>
      <td>${row.name}</td>
      <td class="number-col">${row.jobs}</td>
      <td class="number-col">${formatCurrencyCompact(row.contract)}</td>
      <td class="number-col">${formatCurrencyCompact(row.cost)}</td>
      <td class="number-col ${profitClass}">${formatCurrencyCompact(row.profit)}</td>
      <td class="number-col margin-cell" style="background-color: ${marginColor}">${row.margin.toFixed(1)}%</td>
    </tr>`;
  }).join('');
  
  const totalProfitClass = totals.profit >= 0 ? 'positive' : 'negative';
  const totalMarginColor = getMarginColor(totals.margin);
  const subtotalHtml = `<tr class="subtotal-row">
    <td><strong>Total</strong></td>
    <td class="number-col"><strong>${totals.jobs}</strong></td>
    <td class="number-col"><strong>${formatCurrencyCompact(totals.contract)}</strong></td>
    <td class="number-col"><strong>${formatCurrencyCompact(totals.cost)}</strong></td>
    <td class="number-col ${totalProfitClass}"><strong>${formatCurrencyCompact(totals.profit)}</strong></td>
    <td class="number-col margin-cell" style="background-color: ${totalMarginColor}"><strong>${totals.margin.toFixed(1)}%</strong></td>
  </tr>`;
  
  tbody.innerHTML = rowsHtml + subtotalHtml;
  
  // Apply dark mode styles after PM breakdown renders
  const currentTheme = document.documentElement.getAttribute("data-theme") || "light";
  applyJobBudgetsDarkModeStyles(currentTheme);
}

function renderJobBreakdownByCustomer() {
  const tbody = document.getElementById('jobCustomerBreakdownBody');
  if (!tbody) return;
  
  // Aggregate by Customer - use filtered data
  const jobs = jobBudgetsFiltered || [];
  const custMap = new Map();
  jobs.forEach(job => {
    const cust = job.customer_name || 'Unknown';
    if (!custMap.has(cust)) {
      custMap.set(cust, { jobs: 0, contract: 0, cost: 0, profit: 0 });
    }
    const data = custMap.get(cust);
    data.jobs++;
    data.contract += job.contract;
    data.cost += job.revised_cost;
    data.profit += job.profit;
  });
  
  // Sort by contract value descending
  const sorted = [...custMap.entries()]
    .map(([cust, data]) => ({
      name: cust,
      ...data,
      margin: data.contract > 0 ? (data.profit / data.contract) * 100 : 0
    }))
    .sort((a, b) => b.contract - a.contract);
  
  if (sorted.length === 0) {
    tbody.innerHTML = '<tr><td colspan="6" class="loading-cell">No data</td></tr>';
    return;
  }
  
  // Top 10 + Other (like the donut chart)
  const top10 = sorted.slice(0, 10);
  const others = sorted.slice(10);
  
  let displayRows = [...top10];
  if (others.length > 0) {
    const otherData = others.reduce((acc, row) => ({
      name: 'Other',
      jobs: acc.jobs + row.jobs,
      contract: acc.contract + row.contract,
      cost: acc.cost + row.cost,
      profit: acc.profit + row.profit
    }), { name: 'Other', jobs: 0, contract: 0, cost: 0, profit: 0 });
    otherData.margin = otherData.contract > 0 ? (otherData.profit / otherData.contract) * 100 : 0;
    displayRows.push(otherData);
  }
  
  // Calculate totals for subtotal row
  const totals = displayRows.reduce((acc, row) => ({
    jobs: acc.jobs + row.jobs,
    contract: acc.contract + row.contract,
    cost: acc.cost + row.cost,
    profit: acc.profit + row.profit
  }), { jobs: 0, contract: 0, cost: 0, profit: 0 });
  totals.margin = totals.contract > 0 ? (totals.profit / totals.contract) * 100 : 0;
  
  const rowsHtml = displayRows.map(row => {
    const profitClass = row.profit >= 0 ? 'positive' : 'negative';
    const marginColor = getMarginColor(row.margin);
    return `<tr>
      <td>${row.name}</td>
      <td class="number-col">${row.jobs}</td>
      <td class="number-col">${formatCurrencyCompact(row.contract)}</td>
      <td class="number-col">${formatCurrencyCompact(row.cost)}</td>
      <td class="number-col ${profitClass}">${formatCurrencyCompact(row.profit)}</td>
      <td class="number-col margin-cell" style="background-color: ${marginColor}">${row.margin.toFixed(1)}%</td>
    </tr>`;
  }).join('');
  
  const totalProfitClass = totals.profit >= 0 ? 'positive' : 'negative';
  const totalMarginColor = getMarginColor(totals.margin);
  const subtotalHtml = `<tr class="subtotal-row">
    <td><strong>Total</strong></td>
    <td class="number-col"><strong>${totals.jobs}</strong></td>
    <td class="number-col"><strong>${formatCurrencyCompact(totals.contract)}</strong></td>
    <td class="number-col"><strong>${formatCurrencyCompact(totals.cost)}</strong></td>
    <td class="number-col ${totalProfitClass}"><strong>${formatCurrencyCompact(totals.profit)}</strong></td>
    <td class="number-col margin-cell" style="background-color: ${totalMarginColor}"><strong>${totals.margin.toFixed(1)}%</strong></td>
  </tr>`;
  
  tbody.innerHTML = rowsHtml + subtotalHtml;
  
  // Apply dark mode styles after Customer breakdown renders
  const currentTheme2 = document.documentElement.getAttribute("data-theme") || "light";
  applyJobBudgetsDarkModeStyles(currentTheme2);
}

function formatCurrencyCompact(value) {
  const absValue = Math.abs(value);
  const sign = value < 0 ? '-' : '';
  if (absValue >= 1000000) {
    return sign + '$' + (absValue / 1000000).toFixed(1) + 'M';
  } else if (absValue >= 1000) {
    return sign + '$' + (absValue / 1000).toFixed(1) + 'K';
  } else {
    return sign + '$' + absValue.toFixed(0);
  }
}

function renderJobBudgetsTable() {
  const tbody = document.getElementById('jobBudgetsTableBody');
  if (!tbody) return;
  
  // Update sort indicators
  document.querySelectorAll('.job-budgets-table th.sortable').forEach(th => {
    th.classList.remove('sort-asc', 'sort-desc');
    if (th.dataset.sort === jobBudgetsSortColumn) {
      th.classList.add(jobBudgetsSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
    }
  });
  
  const start = (jobBudgetsCurrentPage - 1) * jobBudgetsPageSize;
  const end = start + jobBudgetsPageSize;
  const pageData = jobBudgetsFiltered.slice(start, end);
  
  if (pageData.length === 0) {
    tbody.innerHTML = '<tr><td colspan="12" class="loading-cell">No jobs match the current filters</td></tr>';
    updateJobPagination(0);
    return;
  }
  
  // Check if columns are expanded
  const contractExpanded = document.querySelector('.expand-icon[data-expand="contract"]')?.classList.contains('expanded');
  const costExpanded = document.querySelector('.expand-icon[data-expand="cost"]')?.classList.contains('expanded');
  const contractHidden = contractExpanded ? '' : 'hidden';
  const costHidden = costExpanded ? '' : 'hidden';
  
  // Calculate totals for ALL filtered data (not just current page)
  const allTotals = {
    originalContract: jobBudgetsFiltered.reduce((sum, j) => sum + (parseFloat(j.original_contract) || 0), 0),
    changeOrders: jobBudgetsFiltered.reduce((sum, j) => sum + (parseFloat(j.tot_income_adj) || 0), 0),
    revisedContract: jobBudgetsFiltered.reduce((sum, j) => sum + (parseFloat(j.revised_contract) || 0), 0),
    originalCost: jobBudgetsFiltered.reduce((sum, j) => sum + (parseFloat(j.original_cost) || 0), 0),
    costAdj: jobBudgetsFiltered.reduce((sum, j) => sum + (parseFloat(j.tot_cost_adj) || 0), 0),
    revisedCost: jobBudgetsFiltered.reduce((sum, j) => sum + (parseFloat(j.revised_cost) || 0), 0),
    estimatedProfit: jobBudgetsFiltered.reduce((sum, j) => sum + (parseFloat(j.profit) || 0), 0)
  };
  // Calculate average margin using weighted average (total profit / total contract)
  // Exclude jobs with zero revised_contract OR zero revised_cost
  const jobsWithMargin = jobBudgetsFiltered.filter(j => 
    parseFloat(j.revised_contract) > 0 && parseFloat(j.revised_cost) > 0
  );
  let avgMargin = 0;
  if (jobsWithMargin.length > 0) {
    const totalContractForMargin = jobsWithMargin.reduce((sum, j) => sum + (parseFloat(j.revised_contract) || 0), 0);
    const totalCostForMargin = jobsWithMargin.reduce((sum, j) => sum + (parseFloat(j.revised_cost) || 0), 0);
    const totalProfitForMargin = totalContractForMargin - totalCostForMargin;
    avgMargin = totalContractForMargin > 0 ? (totalProfitForMargin / totalContractForMargin) * 100 : 0;
  }
  const totalProfitClass = allTotals.estimatedProfit >= 0 ? 'positive' : 'negative';
  const totalMarginColor = getMarginColor(avgMargin);
  
  const totalsRowHtml = `<tr class="totals-row">
    <td colspan="5"><strong>Totals (${jobBudgetsFiltered.length} jobs)</strong></td>
    <td class="number-col contract-detail-col ${contractHidden}"><strong>${formatCurrency(allTotals.originalContract)}</strong></td>
    <td class="number-col contract-detail-col ${contractHidden}"><strong>${formatCurrency(allTotals.changeOrders)}</strong></td>
    <td class="number-col revised-contract-col"><strong>${formatCurrency(allTotals.revisedContract)}</strong></td>
    <td class="number-col cost-detail-col ${costHidden}"><strong>${formatCurrency(allTotals.originalCost)}</strong></td>
    <td class="number-col cost-detail-col ${costHidden}"><strong>${formatCurrency(allTotals.costAdj)}</strong></td>
    <td class="number-col revised-cost-col"><strong>${formatCurrency(allTotals.revisedCost)}</strong></td>
    <td class="number-col ${totalProfitClass}"><strong>${formatCurrency(allTotals.estimatedProfit)}</strong></td>
    <td class="number-col" style="background-color: ${totalMarginColor}"><strong>${avgMargin.toFixed(1)}%</strong></td>
  </tr>`;
  
  const dataRowsHtml = pageData.map(job => {
    const status = getJobStatusLabel(job.job_status);
    const profitClass = job.profit >= 0 ? 'positive' : 'negative';
    
    // Only calculate margin if both revised_contract AND revised_cost are non-zero
    const hasValidMargin = job.contract > 0 && job.revised_cost > 0;
    const margin = hasValidMargin ? (job.profit / job.contract) * 100 : null;
    const marginColor = hasValidMargin ? getMarginColor(margin) : 'transparent';
    const marginDisplay = hasValidMargin ? `${margin.toFixed(1)}%` : '-';
    
    return `<tr>
      <td>${job.job_no}</td>
      <td>${job.job_description || ''}</td>
      <td>${job.customer_name || ''}</td>
      <td><span class="job-status-badge ${status.class}">${status.label}</span></td>
      <td>${job.project_manager_name || ''}</td>
      <td class="number-col contract-detail-col ${contractHidden}">${formatCurrency(job.original_contract)}</td>
      <td class="number-col contract-detail-col ${contractHidden}">${formatCurrency(job.tot_income_adj)}</td>
      <td class="number-col revised-contract-col">${formatCurrency(job.contract)}</td>
      <td class="number-col cost-detail-col ${costHidden}">${formatCurrency(job.original_cost)}</td>
      <td class="number-col cost-detail-col ${costHidden}">${formatCurrency(job.tot_cost_adj)}</td>
      <td class="number-col revised-cost-col">${formatCurrency(job.revised_cost)}</td>
      <td class="number-col ${profitClass}">${formatCurrency(job.profit)}</td>
      <td class="number-col" style="background-color: ${marginColor}">${marginDisplay}</td>
    </tr>`;
  }).join('');
  
  tbody.innerHTML = totalsRowHtml + dataRowsHtml;
  
  updateJobPagination(jobBudgetsFiltered.length);
  
  // Apply dark mode styles after rendering
  const currentTheme = document.documentElement.getAttribute("data-theme") || "light";
  applyJobBudgetsDarkModeStyles(currentTheme);
  
  // Apply column visibility
  if (typeof applyBudgetsColumnVisibility === 'function') {
    applyBudgetsColumnVisibility();
  }
}

function updateJobPagination(total) {
  const totalPages = Math.max(1, Math.ceil(total / jobBudgetsPageSize));
  
  document.getElementById('jobPageInfo').textContent = `Page ${jobBudgetsCurrentPage} of ${totalPages}`;
  document.getElementById('jobPrevPage').disabled = jobBudgetsCurrentPage <= 1;
  document.getElementById('jobNextPage').disabled = jobBudgetsCurrentPage >= totalPages;
}

// ========================================
// CASH REPORT MODULE
// ========================================

let dcrChartInstance = null;
let dcrData = null;
let dcrArData = null;
let dcrApData = null;
let dcrJobsData = null;
let dcrGLData = null;
let dcrAccountGroups = null;
let dcrInitialized = false;
let dcrArMetrics = null;
let dcrApMetrics = null;
let dcrJobsMetrics = null;
let dcrViewMode = 'weekly'; // 'daily' or 'weekly' - weekly is default
let dcrArAllocations = null; // AR receipt job allocations
let dcrApAllocations = null; // AP payment job allocations
let dcrCustomerLookup = {}; // Customer name lookup by customer_no

async function initCashReport() {
  console.log('[DCR] Initializing Cash Report...');
  
  try {
    // Setup view toggle listeners
    setupDcrViewToggle();
    
    // Load all required data
    await loadCashReportData();
    
    console.log('[DCR] Data loaded, dcrData:', dcrData ? 'exists' : 'null');
    
    // Render everything based on current view mode
    renderCashReport();
    
    dcrInitialized = true;
    console.log('[DCR] Initialization complete');
  } catch (error) {
    console.error('[DCR] Initialization failed:', error);
    showDcrError('Failed to initialize: ' + error.message);
  }
}

function setupDcrViewToggle() {
  const toggleBtns = document.querySelectorAll('.dcr-toggle-btn');
  toggleBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const view = btn.dataset.view;
      if (view === dcrViewMode) return;
      
      dcrViewMode = view;
      toggleBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      renderCashReport();
    });
  });
}

async function loadCashReportData() {
  try {
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit ? '/api/cash-data' : '/.netlify/functions/cash-data';
    
    console.log('[DCR] Fetching cash data from:', apiUrl);
    
    // Fetch all data in parallel - use metrics API for totals, raw data for detail breakdowns
    // Also load AR/AP allocation files for transaction matching
    const [cashResponse, arMetrics, apMetrics, jobsMetrics, arData, apData, jobsData, glData, accountGroups, arAllocations, apAllocations] = await Promise.all([
      fetch(apiUrl).then(r => r.json()),
      DataCache.getARMetrics().catch(() => ({ summary: {} })),
      DataCache.getAPMetrics().catch(() => ({ summary: {} })),
      DataCache.getJobsMetrics().catch(() => ({ jobs: [] })),
      DataCache.getARData().catch(() => ({ invoices: [] })),
      DataCache.getAPData().catch(() => ({ invoices: [] })),
      DataCache.getJobsData().catch(() => ({ job_budgets: [] })),
      DataCache.getGLData().catch(() => ({ gl_history_all: [] })),
      DataCache.getAccountGroups().catch(() => ({ income_statement: { groups: [] } })),
      fetch('/data/ar_receipt_job_allocation.json').then(r => r.json()).catch(() => ({ allocations: [] })),
      fetch('/data/ap_payment_job_allocation.json').then(r => r.json()).catch(() => ({ allocations: [] }))
    ]);
    
    console.log('[DCR] Received data:', { 
      accounts: cashResponse.accounts?.length, 
      transactions: cashResponse.transactions?.length,
      arTotal: arMetrics?.summary?.total_due,
      apTotal: apMetrics?.summary?.total,
      jobsMetrics: jobsMetrics?.jobs?.length,
      arInvoices: arData?.invoices?.length,
      apInvoices: apData?.invoices?.length,
      jobs: jobsData?.job_budgets?.length,
      glRecords: glData?.gl_history_all?.length,
      arAllocations: arAllocations?.allocations?.length,
      apAllocations: apAllocations?.allocations?.length
    });
    
    if (!cashResponse.success) {
      throw new Error(cashResponse.error || 'Failed to fetch cash data');
    }
    
    dcrData = cashResponse;
    dcrArMetrics = arMetrics;
    dcrApMetrics = apMetrics;
    dcrJobsMetrics = jobsMetrics;
    dcrArData = arData;
    dcrApData = apData;
    dcrJobsData = jobsData;
    dcrGLData = glData;
    dcrAccountGroups = accountGroups;
    dcrArAllocations = arAllocations?.allocations || [];
    dcrApAllocations = apAllocations?.allocations || [];
    
    // Build customer lookup from AR invoice data
    dcrCustomerLookup = {};
    if (arData?.invoices) {
      arData.invoices.forEach(inv => {
        if (inv.customer_no && inv.customer_name) {
          dcrCustomerLookup[inv.customer_no] = inv.customer_name;
        }
      });
    }
    console.log('[DCR] Built customer lookup with', Object.keys(dcrCustomerLookup).length, 'customers');
    
  } catch (error) {
    console.error('[DCR] Error loading cash report data:', error);
    showDcrError(error.message);
  }
}

function showDcrError(message) {
  const currentBalanceEl = document.getElementById('dcrCurrentBalance');
  const depositsEl = document.getElementById('dcrDeposits');
  const withdrawalsEl = document.getElementById('dcrWithdrawals');
  const percentChangeEl = document.getElementById('dcrPercentChange');
  
  if (currentBalanceEl) currentBalanceEl.textContent = 'Error';
  if (depositsEl) depositsEl.textContent = '--';
  if (withdrawalsEl) withdrawalsEl.textContent = '--';
  if (percentChangeEl) percentChangeEl.textContent = '--';
  
  const depositsContainer = document.getElementById('dcrDepositsContainer');
  const withdrawalsContainer = document.getElementById('dcrWithdrawalsContainer');
  if (depositsContainer) depositsContainer.innerHTML = `<div class="error-message">${message}</div>`;
  if (withdrawalsContainer) withdrawalsContainer.innerHTML = `<div class="error-message">${message}</div>`;
}

function renderCashReport() {
  if (!dcrData) return;
  
  updateDcrLabels();
  renderDcrChart();
  renderDcrMetrics();
  renderDcrSafetyCheck();
  renderDcrTopTransactions();
  renderExecutiveSummary();
}

function updateDcrLabels() {
  const isWeekly = dcrViewMode === 'weekly';
  
  // Update page description
  const desc = document.getElementById('dcrDescription');
  if (desc) {
    desc.textContent = isWeekly 
      ? 'FTG Builders cash position and activity - trailing 10 weeks'
      : 'FTG Builders cash position and activity - trailing 14 days';
  }
  
  // Update chart title
  const chartTitle = document.getElementById('dcrChartTitle');
  if (chartTitle) {
    chartTitle.textContent = isWeekly ? 'Weekly Cash Balance' : 'Daily Cash Balance';
  }
  
  // Update metric labels
  const depositsLabel = document.getElementById('dcrDepositsLabel');
  const depositsSubLabel = document.getElementById('dcrDepositsSublabel');
  const withdrawalsLabel = document.getElementById('dcrWithdrawalsLabel');
  const withdrawalsSubLabel = document.getElementById('dcrWithdrawalsSublabel');
  const changeSubLabel = document.getElementById('dcrChangeSublabel');
  
  if (depositsLabel) depositsLabel.textContent = 'Deposits';
  if (withdrawalsLabel) withdrawalsLabel.textContent = 'Withdrawals';
  
  if (isWeekly) {
    if (depositsSubLabel) depositsSubLabel.textContent = 'Past 7 days (excl. transfers)';
    if (withdrawalsSubLabel) withdrawalsSubLabel.textContent = 'Past 7 days (excl. transfers)';
    if (changeSubLabel) changeSubLabel.textContent = 'Deposits minus withdrawals';
  } else {
    if (depositsSubLabel) depositsSubLabel.textContent = 'Prior day (excl. transfers)';
    if (withdrawalsSubLabel) withdrawalsSubLabel.textContent = 'Prior day (excl. transfers)';
    if (changeSubLabel) changeSubLabel.textContent = 'Deposits minus withdrawals';
  }
  
  // Update transaction section labels
  const depositsTitle = document.getElementById('dcrDepositsTitle');
  const depositsSubtitle = document.getElementById('dcrDepositsSubtitle');
  const withdrawalsTitle = document.getElementById('dcrWithdrawalsTitle');
  const withdrawalsSubtitle = document.getElementById('dcrWithdrawalsSubtitle');
  
  if (depositsTitle) depositsTitle.textContent = 'Top 5 Deposits';
  if (withdrawalsTitle) withdrawalsTitle.textContent = 'Top 5 Withdrawals';
  
  if (isWeekly) {
    if (depositsSubtitle) depositsSubtitle.textContent = 'Past 7 days (excl. transfers)';
    if (withdrawalsSubtitle) withdrawalsSubtitle.textContent = 'Past 7 days (excl. transfers)';
  } else {
    if (depositsSubtitle) depositsSubtitle.textContent = 'Prior day (excl. transfers)';
    if (withdrawalsSubtitle) withdrawalsSubtitle.textContent = 'Prior day (excl. transfers)';
  }
}

function getDcrDateRange() {
  const today = new Date();
  const dates = [];
  const numDays = dcrViewMode === 'weekly' ? 70 : 14; // 10 weeks or 14 days
  
  for (let i = numDays - 1; i >= 0; i--) {
    const d = new Date(today);
    d.setDate(d.getDate() - i);
    dates.push(d.toISOString().split('T')[0]);
  }
  
  return dates;
}

function getWeeklyDataPoints(dailyDates, dailyBalances) {
  // Group into weeks (ending on each Saturday or last available day)
  const weeklyData = [];
  const weeklyLabels = [];
  
  // Take every 7th day starting from the end
  for (let i = dailyBalances.length - 1; i >= 0; i -= 7) {
    const balance = dailyBalances[i];
    const dateStr = dailyDates[i];
    if (balance !== null && balance !== undefined) {
      weeklyData.unshift(balance);
      const date = new Date(dateStr + 'T12:00:00');
      weeklyLabels.unshift(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
    }
  }
  
  return { labels: weeklyLabels, data: weeklyData };
}

function renderDcrChart() {
  const canvas = document.getElementById('dcrCashChart');
  if (!canvas || !dcrData) return;
  
  const ftgAccounts = dcrData.accounts.filter(a => isFTGBuildersAccount(a.name));
  
  if (ftgAccounts.length === 0) {
    console.warn('[DCR] No FTG Builders accounts found');
    return;
  }
  
  const dates = getDcrDateRange();
  const dailyBalances = calculateDcrDailyBalances(ftgAccounts, dates);
  
  let chartLabels, chartData;
  
  if (dcrViewMode === 'weekly') {
    const weeklyResult = getWeeklyDataPoints(dates, dailyBalances);
    chartLabels = weeklyResult.labels;
    chartData = weeklyResult.data;
  } else {
    chartLabels = dates.map(d => {
      const date = new Date(d + 'T12:00:00');
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    });
    chartData = dailyBalances;
  }
  
  if (dcrChartInstance) dcrChartInstance.destroy();
  
  const themeColors = getChartThemeColors();
  const isMobile = window.innerWidth <= 768;
  
  const ctx = canvas.getContext('2d');
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, 'rgba(59, 130, 246, 0.4)');
  gradient.addColorStop(1, 'rgba(59, 130, 246, 0.05)');
  
  dcrChartInstance = new Chart(canvas, {
    type: 'line',
    data: {
      labels: chartLabels,
      datasets: [{
        label: 'FTG Builders Combined',
        data: chartData,
        borderColor: '#3b82f6',
        backgroundColor: gradient,
        fill: true,
        tension: 0.3,
        pointRadius: isMobile ? 2 : 4,
        pointHoverRadius: 6,
        borderWidth: 2
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'index',
        intersect: false
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          titleColor: '#fff',
          bodyColor: '#fff',
          padding: 10,
          callbacks: {
            label: function(context) {
              return formatCurrency(context.parsed.y);
            }
          }
        }
      },
      scales: {
        x: {
          grid: { color: themeColors.gridColor, drawBorder: false },
          ticks: {
            color: themeColors.textColor,
            font: { size: isMobile ? 9 : 11 },
            maxRotation: 45,
            minRotation: 0
          }
        },
        y: {
          grid: { color: themeColors.gridColor, drawBorder: false },
          ticks: {
            color: themeColors.textColor,
            font: { size: isMobile ? 9 : 11 },
            callback: function(value) {
              return '$' + (value / 1000000).toFixed(1) + 'M';
            }
          }
        }
      }
    }
  });
}

// Helper: Check if a date is a weekend (Saturday=6, Sunday=0)
function isDcrWeekend(dateStr) {
  const date = new Date(dateStr + 'T12:00:00');
  const day = date.getDay();
  return day === 0 || day === 6;
}

// Helper: Get US federal holidays for a given year
function getDcrHolidays(year) {
  const holidays = [];
  
  // New Year's Day - Jan 1
  holidays.push(`${year}-01-01`);
  
  // MLK Day - 3rd Monday of January
  let d = new Date(year, 0, 1);
  let mondayCount = 0;
  while (mondayCount < 3) {
    if (d.getDay() === 1) mondayCount++;
    if (mondayCount < 3) d.setDate(d.getDate() + 1);
  }
  holidays.push(d.toISOString().split('T')[0]);
  
  // Presidents Day - 3rd Monday of February
  d = new Date(year, 1, 1);
  mondayCount = 0;
  while (mondayCount < 3) {
    if (d.getDay() === 1) mondayCount++;
    if (mondayCount < 3) d.setDate(d.getDate() + 1);
  }
  holidays.push(d.toISOString().split('T')[0]);
  
  // Memorial Day - Last Monday of May
  d = new Date(year, 5, 0); // Last day of May
  while (d.getDay() !== 1) d.setDate(d.getDate() - 1);
  holidays.push(d.toISOString().split('T')[0]);
  
  // Independence Day - July 4
  holidays.push(`${year}-07-04`);
  
  // Labor Day - 1st Monday of September
  d = new Date(year, 8, 1);
  while (d.getDay() !== 1) d.setDate(d.getDate() + 1);
  holidays.push(d.toISOString().split('T')[0]);
  
  // Thanksgiving - 4th Thursday of November
  d = new Date(year, 10, 1);
  let thursdayCount = 0;
  while (thursdayCount < 4) {
    if (d.getDay() === 4) thursdayCount++;
    if (thursdayCount < 4) d.setDate(d.getDate() + 1);
  }
  holidays.push(d.toISOString().split('T')[0]);
  
  // Christmas - Dec 25
  holidays.push(`${year}-12-25`);
  
  return holidays;
}

// Helper: Check if a date is a US federal holiday
function isDcrHoliday(dateStr) {
  const year = parseInt(dateStr.substring(0, 4));
  const holidays = getDcrHolidays(year);
  return holidays.includes(dateStr);
}

// Helper: Check if a date is a business day (not weekend, not holiday)
function isDcrBusinessDay(dateStr) {
  return !isDcrWeekend(dateStr) && !isDcrHoliday(dateStr);
}

function calculateDcrDailyBalances(ftgAccounts, dates) {
  const ftgAccountNames = ftgAccounts.map(a => a.name);
  const currentBalance = ftgAccounts.reduce((sum, a) => sum + a.balance, 0);
  
  const txnsByDate = {};
  dcrData.transactions.forEach(txn => {
    if (!ftgAccountNames.includes(txn.account)) return;
    try {
      const txnDate = new Date(txn.date);
      const dateStr = txnDate.toISOString().split('T')[0];
      if (!txnsByDate[dateStr]) txnsByDate[dateStr] = 0;
      txnsByDate[dateStr] += txn.amount;
    } catch (e) {}
  });
  
  const today = new Date().toISOString().split('T')[0];
  const sortedDates = [...dates].sort((a, b) => b.localeCompare(a));
  
  const balances = {};
  let runningBalance = currentBalance;
  let prevDateStr = null;
  let lastBusinessDayBalance = currentBalance;
  
  for (const dateStr of sortedDates) {
    if (dateStr > today) {
      balances[dateStr] = null;
    } else if (dateStr === today) {
      balances[dateStr] = currentBalance;
      if (isDcrBusinessDay(dateStr)) {
        lastBusinessDayBalance = currentBalance;
      }
      prevDateStr = dateStr;
    } else {
      // Calculate balance change from previous day's transactions
      const nextDayChange = prevDateStr ? (txnsByDate[prevDateStr] || 0) : 0;
      runningBalance -= nextDayChange;
      
      // For weekends/holidays, use the last business day balance
      if (!isDcrBusinessDay(dateStr)) {
        balances[dateStr] = lastBusinessDayBalance;
      } else {
        balances[dateStr] = runningBalance;
        lastBusinessDayBalance = runningBalance;
      }
      prevDateStr = dateStr;
    }
  }
  
  return dates.map(d => balances[d]);
}

function renderDcrMetrics() {
  if (!dcrData) return;
  
  const ftgAccounts = dcrData.accounts.filter(a => isFTGBuildersAccount(a.name));
  const currentBalance = ftgAccounts.reduce((sum, a) => sum + a.balance, 0);
  const ftgAccountNames = ftgAccounts.map(a => a.name);
  
  // Calculate deposits/withdrawals based on view mode
  const today = new Date();
  let txnStartDate, txnEndDate;
  
  if (dcrViewMode === 'weekly') {
    // Past 7 days
    txnEndDate = new Date(today);
    txnEndDate.setDate(txnEndDate.getDate() - 1);
    txnStartDate = new Date(today);
    txnStartDate.setDate(txnStartDate.getDate() - 7);
  } else {
    // Prior day only
    txnStartDate = new Date(today);
    txnStartDate.setDate(txnStartDate.getDate() - 1);
    txnEndDate = txnStartDate;
  }
  
  const startStr = txnStartDate.toISOString().split('T')[0];
  const endStr = txnEndDate.toISOString().split('T')[0];
  
  const periodTxns = dcrData.transactions.filter(txn => {
    if (!ftgAccountNames.includes(txn.account)) return false;
    try {
      const txnDate = new Date(txn.date);
      const dateStr = txnDate.toISOString().split('T')[0];
      return dateStr >= startStr && dateStr <= endStr;
    } catch (e) { return false; }
  });
  
  let deposits = 0;
  let withdrawals = 0;
  
  periodTxns.forEach(txn => {
    if (isDcrTransfer(txn, periodTxns)) return;
    if (txn.amount > 0) {
      deposits += txn.amount;
    } else {
      withdrawals += Math.abs(txn.amount);
    }
  });
  
  // Calculate percent change
  const dates = getDcrDateRange();
  const dailyBalances = calculateDcrDailyBalances(ftgAccounts, dates);
  
  let percentChange = 0;
  if (dcrViewMode === 'weekly') {
    const weeklyResult = getWeeklyDataPoints(dates, dailyBalances);
    const currentWeek = weeklyResult.data[weeklyResult.data.length - 1];
    const priorWeek = weeklyResult.data[weeklyResult.data.length - 2];
    if (priorWeek && priorWeek !== 0) {
      percentChange = ((currentWeek - priorWeek) / priorWeek) * 100;
    }
  } else {
    const todayBalance = dailyBalances[dailyBalances.length - 1] || currentBalance;
    const priorDayBalance = dailyBalances[dailyBalances.length - 2];
    if (priorDayBalance && priorDayBalance !== 0) {
      percentChange = ((todayBalance - priorDayBalance) / priorDayBalance) * 100;
    }
  }
  
  // Calculate prior period values for comparison
  let priorDeposits = 0;
  let priorWithdrawals = 0;
  let priorBalance = currentBalance;
  let balanceChange = 0;
  
  if (dcrViewMode === 'weekly') {
    // Current period: days 1-7 ago (txnStartDate to txnEndDate already set above)
    // Prior period: days 8-14 ago (7 days immediately preceding the current window)
    const priorEndDate = new Date(today);
    priorEndDate.setDate(priorEndDate.getDate() - 8); // Day after current period ends
    const priorStartDate = new Date(today);
    priorStartDate.setDate(priorStartDate.getDate() - 14); // 7 days before prior end
    
    const priorStartStr = priorStartDate.toISOString().split('T')[0];
    const priorEndStr = priorEndDate.toISOString().split('T')[0];
    
    const priorTxns = dcrData.transactions.filter(txn => {
      if (!ftgAccountNames.includes(txn.account)) return false;
      try {
        const txnDate = new Date(txn.date);
        const dateStr = txnDate.toISOString().split('T')[0];
        return dateStr >= priorStartStr && dateStr <= priorEndStr;
      } catch (e) { return false; }
    });
    
    priorTxns.forEach(txn => {
      if (isDcrTransfer(txn, priorTxns)) return;
      if (txn.amount > 0) {
        priorDeposits += txn.amount;
      } else {
        priorWithdrawals += Math.abs(txn.amount);
      }
    });
    
    // Get prior week balance
    const weeklyResult = getWeeklyDataPoints(dates, dailyBalances);
    priorBalance = weeklyResult.data[weeklyResult.data.length - 2] || currentBalance;
    balanceChange = currentBalance - priorBalance;
  } else {
    // Daily mode: Current period is yesterday (1 day ago)
    // Prior period is the day before yesterday (2 days ago)
    const priorDayDate = new Date(today);
    priorDayDate.setDate(priorDayDate.getDate() - 2);
    const priorDayStr = priorDayDate.toISOString().split('T')[0];
    
    const priorTxns = dcrData.transactions.filter(txn => {
      if (!ftgAccountNames.includes(txn.account)) return false;
      try {
        const txnDate = new Date(txn.date);
        const dateStr = txnDate.toISOString().split('T')[0];
        return dateStr === priorDayStr;
      } catch (e) { return false; }
    });
    
    priorTxns.forEach(txn => {
      if (isDcrTransfer(txn, priorTxns)) return;
      if (txn.amount > 0) {
        priorDeposits += txn.amount;
      } else {
        priorWithdrawals += Math.abs(txn.amount);
      }
    });
    
    priorBalance = dailyBalances[dailyBalances.length - 2] || currentBalance;
    balanceChange = currentBalance - priorBalance;
  }
  
  // Calculate deltas
  const depositsDelta = deposits - priorDeposits;
  const withdrawalsDelta = withdrawals - priorWithdrawals;
  const netChange = deposits - withdrawals;
  const priorNetChange = priorDeposits - priorWithdrawals;
  const netDelta = netChange - priorNetChange;
  
  // Store metrics for executive summary
  window.dcrMetrics = {
    currentBalance,
    balanceChange,
    deposits,
    withdrawals,
    depositsDelta,
    withdrawalsDelta,
    netChange,
    percentChange
  };
  
  // Update DOM
  const currentBalanceEl = document.getElementById('dcrCurrentBalance');
  const depositsEl = document.getElementById('dcrDeposits');
  const withdrawalsEl = document.getElementById('dcrWithdrawals');
  const percentChangeEl = document.getElementById('dcrPercentChange');
  
  if (currentBalanceEl) currentBalanceEl.textContent = formatCurrency(currentBalance);
  if (depositsEl) depositsEl.textContent = deposits > 0 ? '+' + formatCurrency(deposits) : '$0';
  if (withdrawalsEl) withdrawalsEl.textContent = withdrawals > 0 ? '-' + formatCurrency(withdrawals) : '$0';
  
  if (percentChangeEl) {
    // Show net change as dollar amount (deposits - withdrawals), not percent
    const sign = netChange >= 0 ? '+' : '-';
    percentChangeEl.textContent = sign + formatCurrency(Math.abs(netChange));
    percentChangeEl.className = 'dcr-metric-value ' + (netChange >= 0 ? 'positive' : 'negative');
  }
  
  // Update delta badges - only show for balance (first tile)
  updateDeltaBadge('dcrBalanceDelta', balanceChange, true);
  // Hide deposits/withdrawals/net deltas - just show totals
  const depositsDeltaEl = document.getElementById('dcrDepositsDelta');
  const withdrawalsDeltaEl = document.getElementById('dcrWithdrawalsDelta');
  const netDeltaEl = document.getElementById('dcrNetDelta');
  if (depositsDeltaEl) depositsDeltaEl.style.display = 'none';
  if (withdrawalsDeltaEl) withdrawalsDeltaEl.style.display = 'none';
  if (netDeltaEl) netDeltaEl.style.display = 'none';
}

function updateDeltaBadge(elementId, delta, positiveIsGood) {
  const el = document.getElementById(elementId);
  if (!el) return;
  
  if (Math.abs(delta) < 0.01) {
    el.textContent = 'No change';
    el.className = 'dcr-metric-delta delta-neutral';
    return;
  }
  
  const sign = delta >= 0 ? '+' : '';
  const arrow = delta >= 0 ? '↑' : '↓';
  el.textContent = `${arrow} ${sign}${formatCurrency(Math.abs(delta))}`;
  
  // Determine if this is good or bad
  const isPositive = positiveIsGood ? delta > 0 : delta < 0;
  el.className = 'dcr-metric-delta ' + (isPositive ? 'delta-positive' : 'delta-negative');
}

function renderExecutiveSummary() {
  const summaryEl = document.getElementById('dcrSummaryText');
  if (!summaryEl || !window.dcrMetrics) return;
  
  const m = window.dcrMetrics;
  const periodLabel = dcrViewMode === 'weekly' ? 'this week' : 'yesterday';
  const comparisonLabel = dcrViewMode === 'weekly' ? 'vs. prior week' : 'vs. prior day';
  
  // Build executive summary text
  let summary = '';
  
  // Balance change
  if (Math.abs(m.balanceChange) < 100) {
    summary += `Cash balance is <span class="highlight-neutral">${formatCurrency(m.currentBalance)}</span>, essentially unchanged ${comparisonLabel}. `;
  } else if (m.balanceChange > 0) {
    summary += `Cash <span class="highlight-positive">increased ${formatCurrency(m.balanceChange)}</span> ${periodLabel} to <span class="highlight-neutral">${formatCurrency(m.currentBalance)}</span>. `;
  } else {
    summary += `Cash <span class="highlight-negative">decreased ${formatCurrency(Math.abs(m.balanceChange))}</span> ${periodLabel} to <span class="highlight-neutral">${formatCurrency(m.currentBalance)}</span>. `;
  }
  
  // Activity summary
  if (m.deposits > 0 || m.withdrawals > 0) {
    summary += `Received <span class="highlight-positive">${formatCurrency(m.deposits)}</span> in deposits, paid out <span class="highlight-negative">${formatCurrency(m.withdrawals)}</span>. `;
  }
  
  // Safety check status (if available)
  const safetyEl = document.getElementById('dcrSafetyTotal');
  if (safetyEl && safetyEl.textContent !== '--') {
    const safetyValue = safetyEl.textContent;
    const isPositive = safetyEl.classList.contains('positive');
    if (isPositive) {
      summary += `Cash Safety Buffer remains <span class="highlight-positive">healthy at ${safetyValue}</span>.`;
    } else {
      summary += `<span class="highlight-negative">Cash Safety Buffer is ${safetyValue}</span> - monitor closely.`;
    }
  }
  
  summaryEl.innerHTML = summary;
}

function renderDcrSafetyCheck() {
  if (!dcrData) return;
  
  // Get current cash balance
  const ftgAccounts = dcrData.accounts.filter(a => isFTGBuildersAccount(a.name));
  const cashBalance = ftgAccounts.reduce((sum, a) => sum + a.balance, 0);
  
  // Get total AR from metrics API (canonical source)
  let totalAR = 0;
  if (dcrArMetrics?.summary?.total_due) {
    totalAR = dcrArMetrics.summary.total_due;
  } else if (dcrArData?.invoices) {
    // Fallback to raw data if metrics unavailable
    totalAR = dcrArData.invoices.reduce((sum, inv) => {
      const amount = parseFloat(inv.calculated_amount_due) || parseFloat(inv.amount_due) || 0;
      return sum + amount;
    }, 0);
  }
  
  // Get total AP from metrics API (canonical source)
  let totalAP = 0;
  if (dcrApMetrics?.summary?.total) {
    totalAP = dcrApMetrics.summary.total_due;
  } else if (dcrApData?.invoices) {
    // Fallback to raw data if metrics unavailable
    totalAP = dcrApData.invoices.reduce((sum, inv) => {
      const amount = parseFloat(inv.remaining_balance) || 0;
      return sum + amount;
    }, 0);
  }
  
  // Get Net Over/Under Bill from metrics API (canonical source)
  let netOUB = 0;
  if (dcrJobsMetrics?.jobs && dcrJobsMetrics.jobs.length > 0) {
    // Use pre-computed over_under_billing from jobs metrics for active jobs WITH BUDGETS
    // This matches the calculation on Job Overview, Job Actuals, and Over/Under Billing pages
    dcrJobsMetrics.jobs.forEach(job => {
      if (job.job_status === 'A' && job.has_budget) {
        netOUB += job.over_under_billing || 0;
      }
    });
    console.log('[DCR] Using jobs metrics for Net OUB (active jobs with budgets):', netOUB);
  } else if (typeof oubData !== 'undefined' && oubData.length > 0) {
    // Fallback to pre-calculated oubData from Over/Under Billing page
    oubData.forEach(job => {
      netOUB += job.over_under || 0;
    });
    console.log('[DCR] Using oubData fallback for Net OUB:', netOUB);
  }
  
  // Calculate 3-month operating expense reserve (SG&A)
  const opExpenseReserve = calculateDcr3MonthOpExpense();
  
  // Calculate safety check: Cash + AR - AP - Net OUB - Operating Reserve
  // If Net OUB is positive (over-billed), it reduces safety
  // If Net OUB is negative (under-billed), it increases safety
  const safetyTotal = cashBalance + totalAR - totalAP - netOUB - opExpenseReserve;
  
  console.log('[DCR] Safety Check values:', { cashBalance, totalAR, totalAP, netOUB, opExpenseReserve, safetyTotal });
  
  // Update DOM
  const cashEl = document.getElementById('dcrSafetyCash');
  const arEl = document.getElementById('dcrSafetyAR');
  const apEl = document.getElementById('dcrSafetyAP');
  const oubEl = document.getElementById('dcrSafetyOUB');
  const opExpEl = document.getElementById('dcrSafetyOpExp');
  const totalEl = document.getElementById('dcrSafetyTotal');
  
  const formatM = (val) => {
    const m = val / 1000000;
    return (val < 0 ? '-' : '') + '$' + Math.abs(m).toFixed(1) + 'M';
  };
  if (cashEl) cashEl.textContent = formatM(cashBalance);
  if (arEl) arEl.textContent = formatM(totalAR);
  if (apEl) apEl.textContent = formatM(totalAP);
  
  if (oubEl) {
    oubEl.textContent = formatM(Math.abs(netOUB));
    // Add class based on whether it's over or under billed
    oubEl.className = 'dcr-safety-value ' + (netOUB >= 0 ? 'negative' : 'positive');
    // Update label to show over vs under
    const oubLabel = oubEl.previousElementSibling;
    if (oubLabel) {
      oubLabel.textContent = netOUB >= 0 ? 'Net Over Billing' : 'Net Under Billing';
    }
  }
  
  if (opExpEl) {
    opExpEl.textContent = formatM(opExpenseReserve);
    opExpEl.className = 'dcr-safety-value negative';
  }
  
  if (totalEl) {
    totalEl.textContent = formatM(safetyTotal);
    totalEl.className = 'dcr-safety-total ' + (safetyTotal >= 0 ? 'positive' : 'negative');
  }
}

// Calculate trailing 3-month operating expenses (SG&A)
function calculateDcr3MonthOpExpense() {
  if (!dcrGLData?.gl_history_all || !dcrAccountGroups?.income_statement?.groups) {
    console.log('[DCR] Missing GL or account groups data for op expense calc');
    return 0;
  }
  
  // Build GL lookup for this calculation
  const glLookup = {};
  dcrGLData.gl_history_all.forEach(row => {
    const acctNum = row.Account_Num || row.account_no;
    if (acctNum) {
      glLookup[acctNum] = row;
    }
  });
  
  // Get the last 3 completed months
  const today = new Date();
  const trailingMonths = [];
  for (let i = 1; i <= 3; i++) {
    const d = new Date(today.getFullYear(), today.getMonth() - i, 1);
    trailingMonths.push(`${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`);
  }
  
  console.log('[DCR] Calculating op expense for months:', trailingMonths);
  
  // Operating expense account ranges (7000-7299 based on account_groups.json)
  // This includes: Salaries & Benefits (7010-7200), Advertising (7040), Facility (7085-7180),
  // Travel & Entertainment (7080-7190), Insurance (7140-7145), Professional Services (7100-7120),
  // Amortization (7599), Administrative & Other (7050-7230)
  const opExpenseAccounts = [];
  
  // Collect all accounts from 7000-7599 range (Operating Expenses)
  Object.keys(glLookup).forEach(acct => {
    const num = parseInt(acct);
    if (num >= 7000 && num < 7600) {
      opExpenseAccounts.push(num);
    }
  });
  
  // Sum operating expenses for the trailing 3 months
  let totalOpExp = 0;
  opExpenseAccounts.forEach(acctNum => {
    const acctData = glLookup[acctNum];
    if (acctData) {
      trailingMonths.forEach(month => {
        const value = parseFloat(acctData[month]) || 0;
        totalOpExp += Math.abs(value); // Expenses are typically negative, take absolute value
      });
    }
  });
  
  console.log('[DCR] 3-month operating expense total:', totalOpExp);
  return totalOpExp;
}

function isDcrTransfer(txn, allTxns) {
  const descLower = (txn.description || '').toLowerCase();
  const payeeLower = (txn.payee || '').toLowerCase();
  
  if (descLower.includes('transfer') || payeeLower.includes('transfer')) {
    const hasOffset = allTxns.some(other => 
      other !== txn && 
      Math.abs(other.amount + txn.amount) < 0.01 &&
      (other.description || '').toLowerCase().includes('transfer')
    );
    if (hasOffset) return true;
  }
  
  const hasExactOffset = allTxns.some(other =>
    other !== txn && Math.abs(other.amount + txn.amount) < 0.01
  );
  
  return hasExactOffset;
}

function renderDcrTopTransactions() {
  const depositsContainer = document.getElementById('dcrDepositsContainer');
  const withdrawalsContainer = document.getElementById('dcrWithdrawalsContainer');
  
  if (!depositsContainer || !withdrawalsContainer || !dcrData) return;
  
  const ftgAccountNames = dcrData.accounts
    .filter(a => isFTGBuildersAccount(a.name))
    .map(a => a.name);
  
  // Determine date range based on view mode
  const today = new Date();
  let startDate, endDate;
  
  if (dcrViewMode === 'weekly') {
    endDate = new Date(today);
    endDate.setDate(endDate.getDate() - 1);
    startDate = new Date(today);
    startDate.setDate(startDate.getDate() - 7);
  } else {
    startDate = new Date(today);
    startDate.setDate(startDate.getDate() - 1);
    endDate = startDate;
  }
  
  const startStr = startDate.toISOString().split('T')[0];
  const endStr = endDate.toISOString().split('T')[0];
  
  // Filter transactions for the period
  const periodTxns = dcrData.transactions.filter(txn => {
    if (!ftgAccountNames.includes(txn.account)) return false;
    try {
      const txnDate = new Date(txn.date);
      const dateStr = txnDate.toISOString().split('T')[0];
      return dateStr >= startStr && dateStr <= endStr;
    } catch (e) { return false; }
  });
  
  // Separate deposits and withdrawals, excluding transfers
  const deposits = [];
  const withdrawals = [];
  
  periodTxns.forEach(txn => {
    if (isDcrTransfer(txn, periodTxns)) return;
    if (txn.amount > 0) {
      deposits.push(txn);
    } else {
      withdrawals.push(txn);
    }
  });
  
  // Sort by amount (descending for deposits, ascending for withdrawals)
  deposits.sort((a, b) => b.amount - a.amount);
  withdrawals.sort((a, b) => a.amount - b.amount); // Most negative first
  
  // Take top 5
  const topDeposits = deposits.slice(0, 5);
  const topWithdrawals = withdrawals.slice(0, 5);
  
  // Render deposits
  depositsContainer.innerHTML = renderDcrTransactionList(topDeposits, 'deposit');
  
  // Render withdrawals
  withdrawalsContainer.innerHTML = renderDcrTransactionList(topWithdrawals, 'withdrawal');
  
  // Export buttons removed from top 5 deposits/withdrawals tables
}

function addCashReportTableExportButtons() {
  const cashTables = [
    { id: 'dcrDepositsTable', name: 'cash-deposits' },
    { id: 'dcrWithdrawalsTable', name: 'cash-withdrawals' }
  ];
  
  cashTables.forEach(({ id, name }) => {
    const table = document.getElementById(id);
    if (!table) return;
    
    let container = table.closest('.dcr-table-container') || 
                    table.closest('.dcr-transaction-card') ||
                    table.closest('.dcr-table-section') ||
                    table.parentElement;
    if (!container) return;
    
    if (container.querySelector('.table-export-btns')) return;
    
    const btnRow = document.createElement('div');
    btnRow.className = 'table-export-row';
    btnRow.style.cssText = 'display:flex;justify-content:flex-end;margin-bottom:8px;';
    
    const btnGroup = document.createElement('div');
    btnGroup.className = 'table-export-btns';
    
    const csvBtn = document.createElement('button');
    csvBtn.className = 'export-table-btn csv-btn';
    csvBtn.textContent = 'CSV';
    csvBtn.title = 'Export to CSV';
    csvBtn.onclick = () => exportTableToCsv(id, name);
    
    const excelBtn = document.createElement('button');
    excelBtn.className = 'export-table-btn excel-btn';
    excelBtn.textContent = 'Excel';
    excelBtn.title = 'Export to Excel';
    excelBtn.onclick = () => exportTableToExcel(id, name);
    
    const dropdownBtn = document.createElement('button');
    dropdownBtn.className = 'table-export-dropdown-btn';
    dropdownBtn.innerHTML = '⬇';
    dropdownBtn.title = 'Export options';
    
    const dropdownMenu = document.createElement('div');
    dropdownMenu.className = 'table-export-dropdown-menu hidden';
    
    const csvOption = document.createElement('button');
    csvOption.textContent = 'CSV';
    csvOption.onclick = (e) => { e.stopPropagation(); exportTableToCsv(id, name); dropdownMenu.classList.add('hidden'); };
    
    const excelOption = document.createElement('button');
    excelOption.textContent = 'Excel';
    excelOption.onclick = (e) => { e.stopPropagation(); exportTableToExcel(id, name); dropdownMenu.classList.add('hidden'); };
    
    dropdownMenu.appendChild(csvOption);
    dropdownMenu.appendChild(excelOption);
    
    dropdownBtn.onclick = (e) => {
      e.stopPropagation();
      document.querySelectorAll('.table-export-dropdown-menu').forEach(m => {
        if (m !== dropdownMenu) m.classList.add('hidden');
      });
      dropdownMenu.classList.toggle('hidden');
    };
    
    btnGroup.appendChild(csvBtn);
    btnGroup.appendChild(excelBtn);
    btnGroup.appendChild(dropdownBtn);
    btnGroup.appendChild(dropdownMenu);
    btnRow.appendChild(btnGroup);
    
    table.parentNode.insertBefore(btnRow, table);
  });
}

// Match deposit amount against AR receipt allocations to find customer/job
// Uses the ar_receipt_job_allocation.json data for precise matching
function matchDepositToAR(amount) {
  if (!dcrArAllocations || dcrArAllocations.length === 0) return null;
  
  const absAmount = Math.abs(amount);
  const matches = [];
  
  // Group allocations by receipt_document_no (unique receipt identifier) to handle multi-job receipts
  const receiptGroups = {};
  dcrArAllocations.forEach(alloc => {
    const receiptDocNo = alloc.receipt_document_no;
    if (!receiptGroups[receiptDocNo]) {
      receiptGroups[receiptDocNo] = [];
    }
    receiptGroups[receiptDocNo].push(alloc);
  });
  
  // Look for receipts where receipt_amount matches the transaction amount
  Object.entries(receiptGroups).forEach(([receiptDocNo, allocs]) => {
    const receiptAmt = parseFloat(allocs[0].receipt_amount) || 0;
    if (Math.abs(receiptAmt - absAmount) < 0.01) {
      // Found a match - get allocation info and aggregate for multi-job receipts
      const firstAlloc = allocs[0];
      const customerNo = firstAlloc.customer_no;
      const customerName = dcrCustomerLookup[customerNo] || `Customer #${customerNo}`;
      
      // Get all unique jobs from this receipt
      const jobs = [...new Set(allocs.map(a => a.job_no))].filter(j => j);
      const jobDescriptions = [...new Set(allocs.map(a => a.job_description))].filter(j => j);
      
      matches.push({
        type: 'exact',
        customer: customerName,
        customer_no: customerNo,
        job_no: jobs.length === 1 ? jobs[0] : (jobs.length > 1 ? jobs.join(', ') : ''),
        job_desc: jobDescriptions.length === 1 ? jobDescriptions[0] : (jobDescriptions.length > 1 ? 'Multiple jobs' : ''),
        invoice_no: firstAlloc.invoice_no,
        receipt_no: firstAlloc.receipt_no,
        receipt_doc_no: receiptDocNo,
        confidence: 'high',
        allocationCount: allocs.length
      });
    }
  });
  
  // If no exact receipt match, try matching against applied_amount (partial payments)
  if (matches.length === 0) {
    dcrArAllocations.forEach(alloc => {
      const appliedAmt = parseFloat(alloc.applied_amount) || 0;
      if (Math.abs(appliedAmt - absAmount) < 0.01) {
        const customerNo = alloc.customer_no;
        const customerName = dcrCustomerLookup[customerNo] || `Customer #${customerNo}`;
        
        matches.push({
          type: 'exact',
          customer: customerName,
          customer_no: customerNo,
          job_no: alloc.job_no || '',
          job_desc: alloc.job_description || '',
          invoice_no: alloc.invoice_no,
          receipt_no: alloc.receipt_no,
          receipt_doc_no: alloc.receipt_document_no,
          confidence: 'high'
        });
      }
    });
  }
  
  // Dedupe matches by receipt_doc_no (each unique receipt should appear once)
  const seen = new Set();
  const uniqueMatches = matches.filter(m => {
    const key = m.receipt_doc_no || `${m.customer_no}-${m.job_no}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
  
  // Return best match (first one found)
  if (uniqueMatches.length >= 1) return uniqueMatches[0];
  return null;
}

// Match withdrawal amount against AP payment allocations AND AP invoices to find vendor/job
// Uses ap_payment_job_allocation.json for job-related payments AND ap_invoices.json for other vendors
function matchWithdrawalToAP(amount) {
  const absAmount = Math.abs(amount);
  const matches = [];
  
  // FIRST: Try matching against AP payment allocations (job-related payments)
  if (dcrApAllocations && dcrApAllocations.length > 0) {
    // Group allocations by payment_document_no to handle multi-voucher payments
    const paymentGroups = {};
    dcrApAllocations.forEach(alloc => {
      const paymentDoc = alloc.payment_document_no;
      if (!paymentGroups[paymentDoc]) {
        paymentGroups[paymentDoc] = {
          totalAmount: 0,
          allocations: [],
          paymentDate: parseFloat(alloc.payment_date) || 0
        };
      }
      paymentGroups[paymentDoc].allocations.push(alloc);
      // Sum the applied amounts for this payment
      paymentGroups[paymentDoc].totalAmount += parseFloat(alloc.cash_applied_amount) || 0;
    });
    
    // Look for exact matches on total payment amount (sum of cash_applied_amount or payment_amount)
    Object.entries(paymentGroups).forEach(([paymentDoc, group]) => {
      const paymentAmt = parseFloat(group.allocations[0]?.payment_amount) || 0;
      if (Math.abs(group.totalAmount - absAmount) < 0.01 || Math.abs(paymentAmt - absAmount) < 0.01) {
        // Found a match - aggregate info from all allocations
        const allocs = group.allocations;
        const firstAlloc = allocs[0];
        
        // Get unique vendors and jobs
        const vendors = [...new Set(allocs.map(a => a.vendor_name))].filter(v => v);
        const jobs = [...new Set(allocs.map(a => a.job_no))].filter(j => j);
        const jobDescriptions = [...new Set(allocs.map(a => a.job_description))].filter(j => j);
        
        matches.push({
          type: 'exact',
          source: 'allocation',
          vendor: vendors.length === 1 ? vendors[0] : (vendors.length > 1 ? vendors.join(', ') : ''),
          vendor_no: firstAlloc.vendor_no,
          job_no: jobs.length === 1 ? jobs[0] : (jobs.length > 1 ? jobs.join(', ') : ''),
          job_desc: jobDescriptions.length === 1 ? jobDescriptions[0] : (jobDescriptions.length > 1 ? 'Multiple jobs' : ''),
          voucher_no: firstAlloc.voucher_no,
          payment_doc: paymentDoc,
          paymentDate: group.paymentDate,
          confidence: 'high',
          allocationCount: allocs.length
        });
      }
    });
    
    // Also try matching individual cash_applied_amount from allocations
    dcrApAllocations.forEach(alloc => {
      const cashAppliedAmt = parseFloat(alloc.cash_applied_amount) || 0;
      if (cashAppliedAmt > 0 && Math.abs(cashAppliedAmt - absAmount) < 0.01) {
        const existingMatch = matches.find(m => 
          m.vendor_no === alloc.vendor_no && m.job_no === (alloc.job_no || '')
        );
        if (!existingMatch) {
          matches.push({
            type: 'exact',
            source: 'allocation',
            vendor: alloc.vendor_name || '',
            vendor_no: alloc.vendor_no,
            job_no: alloc.job_no || '',
            job_desc: alloc.job_description || '',
            voucher_no: alloc.voucher_no,
            confidence: 'high'
          });
        }
      }
    });
  }
  
  // SECOND: Also try matching against AP invoices (for vendors not in allocation file)
  // This catches payroll vendors, benefits, etc. that may not have job allocations
  if (dcrApData?.invoices && dcrApData.invoices.length > 0) {
    dcrApData.invoices.forEach(inv => {
      const invoiceAmt = parseFloat(inv.invoice_amount) || 0;
      const paidAmt = parseFloat(inv.amount_paid_to_date) || 0;
      
      // Check if invoice amount or paid amount matches the withdrawal
      if (Math.abs(invoiceAmt - absAmount) < 0.01 || Math.abs(paidAmt - absAmount) < 0.01) {
        // Check if we already have this vendor+job combo from allocations
        const existingMatch = matches.find(m => 
          m.vendor === inv.vendor_name && m.job_no === (inv.job_no || '')
        );
        
        if (!existingMatch) {
          matches.push({
            type: 'exact',
            source: 'invoice',
            vendor: inv.vendor_name || '',
            vendor_no: '',
            job_no: inv.job_no || '',
            job_desc: inv.job_description || '',
            invoice_no: inv.invoice_no,
            confidence: 'high'
          });
        }
      }
    });
  }
  
  // If multiple matches found, prioritize allocation matches over invoice matches, then by payment date
  if (matches.length > 1) {
    matches.sort((a, b) => {
      // Prioritize allocation matches (more precise)
      if (a.source === 'allocation' && b.source !== 'allocation') return -1;
      if (b.source === 'allocation' && a.source !== 'allocation') return 1;
      // Then by payment date
      return (b.paymentDate || 0) - (a.paymentDate || 0);
    });
  }
  
  // Dedupe matches by vendor + job
  const seen = new Set();
  const uniqueMatches = matches.filter(m => {
    const key = `${m.vendor || m.vendor_no}-${m.job_no}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
  
  // Return best match
  if (uniqueMatches.length >= 1) return uniqueMatches[0];
  return null;
}


function renderDcrTransactionList(txns, type) {
  if (txns.length === 0) {
    const periodLabel = dcrViewMode === 'weekly' ? 'past 7 days' : 'prior day';
    return `<div class="dcr-no-data">No ${type}s found for the ${periodLabel}</div>`;
  }
  
  const tableId = type === 'deposit' ? 'dcrDepositsTable' : 'dcrWithdrawalsTable';
  let html = `<table id="${tableId}" class="dcr-transaction-table dcr-top-transactions">
    <thead>
      <tr>
        <th>Date</th>
        <th>Description</th>
        <th style="text-align:right;">Amount</th>
      </tr>
    </thead>
    <tbody>`;
  
  txns.forEach(txn => {
    const dateObj = new Date(txn.date);
    const displayDate = dateObj.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric' 
    });
    
    const amountClass = txn.amount >= 0 ? 'positive' : 'negative';
    const amountDisplay = formatCurrency(Math.abs(txn.amount));
    const sign = txn.amount >= 0 ? '+' : '-';
    const descDisplay = txn.description || txn.payee || '-';
    
    // Try to match transaction to AR/AP data
    const match = type === 'deposit' 
      ? matchDepositToAR(txn.amount)
      : matchWithdrawalToAP(txn.amount);
    
    // Build match info row if we have a match
    let matchRow = '';
    if (match) {
      const entityName = match.customer || match.vendor || '';
      const jobInfo = match.job_no ? `Job ${match.job_no}` : '';
      const jobDesc = match.job_desc ? ` - ${match.job_desc.substring(0, 20)}${match.job_desc.length > 20 ? '...' : ''}` : '';
      const pmInfo = match.pm ? ` (${match.pm.split(' ')[0]})` : '';
      const confidenceIcon = match.confidence === 'high' ? '●' : '○';
      const confidenceClass = match.confidence === 'high' ? 'match-high' : 'match-medium';
      
      // Format: "Name (Job #(s))" for both deposits (customer) and withdrawals (vendor)
      let displayInfo;
      const jobNos = match.job_no || '';
      if (type === 'withdrawal' && match.vendor) {
        // For withdrawals: Full vendor name (no truncation) with job numbers
        displayInfo = jobNos 
          ? `${match.vendor} (${jobNos})`
          : match.vendor;
      } else {
        // For deposits: Customer Name (Job #(s))
        displayInfo = jobNos 
          ? `${entityName} (${jobNos})`
          : entityName;
      }
      
      const tooltipText = `${entityName}${jobInfo ? ' | ' + jobInfo + (match.job_desc || '') : ''}`;
      
      matchRow = `
        <tr class="dcr-match-row ${confidenceClass}">
          <td colspan="3">
            <span class="match-indicator" title="${match.confidence === 'high' ? 'Exact match' : 'Close match'}">${confidenceIcon}</span>
            <span class="match-info" title="${tooltipText}">${displayInfo}</span>
          </td>
        </tr>`;
    }
    
    html += `
      <tr>
        <td class="txn-date">${displayDate}</td>
        <td class="txn-description" title="${descDisplay}">${descDisplay.length > 40 ? descDisplay.substring(0, 37) + '...' : descDisplay}</td>
        <td class="txn-amount ${amountClass}">${sign}${amountDisplay}</td>
      </tr>${matchRow}`;
  });
  
  html += '</tbody></table>';
  return html;
}

// Cash Report AI Analysis
async function performCashReportAiAnalysis() {
  const btn = document.getElementById('dcrAiAnalyzeBtn');
  const contentEl = document.getElementById('dcrAiAnalysisContent');
  
  btn.disabled = true;
  btn.textContent = 'Analyzing...';
  contentEl.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div> Analyzing cash position...</div>';
  
  try {
    const statementData = extractCashReportData();
    const hostname = window.location.hostname;
    const isReplit = hostname.includes('replit') || hostname.includes('127.0.0.1') || hostname === 'localhost';
    const apiUrl = isReplit ? '/api/analyze-cash-report' : '/.netlify/functions/analyze-cash-report';
    
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({statementData, periodInfo: 'Cash Report Analysis'})
    });
    
    const result = await response.json();
    if (result.success) {
      // Format the analysis with highlighted dollar amounts
      const formattedAnalysis = formatCashAnalysis(result.analysis);
      contentEl.innerHTML = formattedAnalysis;
    } else {
      contentEl.innerHTML = `<div style="color: #dc2626;">Error: ${result.error}</div>`;
    }
  } catch (e) {
    contentEl.innerHTML = `<div style="color: #dc2626;">Error: ${e.message}</div>`;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Run Analysis';
  }
}


async function emailCashReport() {
  const btn = document.getElementById('dcrEmailReportBtn');
  btn.disabled = true;
  btn.textContent = 'Sending...';
  
  // Prompt for email address
  const toEmail = prompt('Enter recipient email address:', '');
  if (!toEmail) {
    btn.disabled = false;
    btn.textContent = 'Email Report';
    return;
  }
  
  try {
    // Gather current report data
    const reportData = gatherCashReportDataForEmail();
    const aiAnalysis = document.getElementById('dcrAiAnalysisContent')?.textContent || '';
    
    const response = await fetch('/api/email-cash-report', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        to: toEmail,
        reportData: reportData,
        aiAnalysis: aiAnalysis
      })
    });
    
    const result = await response.json();
    
    if (result.success) {
      alert('Cash Report email sent successfully!');
    } else {
      throw new Error(result.error || 'Failed to send email');
    }
  } catch (err) {
    console.error('Email error:', err);
    alert('Failed to send email: ' + err.message);
  } finally {
    btn.disabled = false;
    btn.textContent = 'Email Report';
  }
}

function gatherCashReportDataForEmail() {
  // Use the extractCashReportData function which properly grabs data from DOM IDs
  const data = extractCashReportData();
  
  // Also get daily balance chart data for email
  const dailyBalances = getDailyBalancesForEmail();
  
  // Use balanceChange (actual cash balance movement) instead of netChange (deposits - withdrawals)
  // This ensures consistency between the AI analysis and the displayed values
  const numericNetChange = window.dcrMetrics?.balanceChange ?? null;
  
  return {
    summary: {
      currentBalance: data.summary.currentBalance,
      deposits: data.summary.deposits,
      withdrawals: data.summary.withdrawals,
      netChange: data.summary.netChange,
      netChangeNumeric: numericNetChange,
      periodLabel: data.summary.viewMode === 'weekly' ? 'Weekly Cash Report' : 'Daily Cash Report'
    },
    safetyCheck: {
      cash: data.safetyCheck.cash,
      ar: data.safetyCheck.ar,
      ap: data.safetyCheck.ap,
      oub: data.safetyCheck.oub,
      opExp: data.safetyCheck.opExp,
      total: data.safetyCheck.total
    },
    topDeposits: data.topDeposits,
    topWithdrawals: data.topWithdrawals,
    dailyBalances: dailyBalances
  };
}

function getDailyBalancesForEmail() {
  // Get weekly balances from the chart data for email (last 10 weeks)
  if (!dcrData || !dcrData.transactions) return [];
  
  const ftgAccounts = dcrData.accounts.filter(a => isFTGBuildersAccount(a.name));
  const ftgAccountNames = ftgAccounts.map(a => a.name);
  const currentBalance = ftgAccounts.reduce((sum, a) => sum + a.balance, 0);
  
  // Build weekly balances for last 10 weeks
  const today = new Date();
  const weeklyBalances = [];
  
  // Get all transactions sorted by date
  const allTxns = dcrData.transactions
    .filter(txn => ftgAccountNames.includes(txn.account))
    .map(txn => ({ ...txn, dateObj: new Date(txn.date) }))
    .sort((a, b) => b.dateObj - a.dateObj);
  
  // Calculate balance for each of last 10 weeks (going back by 7 days per week)
  let runningBalance = currentBalance;
  for (let week = 0; week < 10; week++) {
    const weekEndDate = new Date(today);
    weekEndDate.setDate(today.getDate() - (week * 7));
    const weekLabel = weekEndDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    
    // Get all transactions for this week (7 days)
    const weekTxns = [];
    for (let day = 0; day < 7; day++) {
      const targetDate = new Date(today);
      targetDate.setDate(today.getDate() - (week * 7) - day);
      const dateStr = targetDate.toISOString().split('T')[0];
      const dayTxns = allTxns.filter(t => t.dateObj.toISOString().split('T')[0] === dateStr);
      weekTxns.push(...dayTxns);
    }
    
    weeklyBalances.unshift({
      date: weekLabel,
      balance: runningBalance,
      formatted: formatCurrencyCompact(runningBalance)
    });
    
    // Subtract this week's transactions to get prior week balance
    weekTxns.forEach(t => {
      runningBalance -= t.amount;
    });
  }
  
  return weeklyBalances;
}

// ============================================================
// AP AGING EMAIL FUNCTIONS
// ============================================================

function gatherAPAgingDataForEmail() {
  // Get summary metrics from DOM
  const totalDue = document.getElementById('apAgingTotalDue')?.textContent || '--';
  const current = document.getElementById('apAgingCurrent')?.textContent || '--';
  const days31to60 = document.getElementById('apAging31to60')?.textContent || '--';
  const days61to90 = document.getElementById('apAging61to90')?.textContent || '--';
  const days90plus = document.getElementById('apAging90plus')?.textContent || '--';
  const retainage = document.getElementById('apAgingRetainage')?.textContent || '--';
  // avgDays removed per user request
  const dataAsOf = document.getElementById('apAgingDataAsOf')?.textContent || '--';
  
  // Get vendor data from table (top 15 vendors)
  const vendors = [];
  const tableBody = document.querySelector('#apAgingTable tbody');
  if (tableBody) {
    const rows = tableBody.querySelectorAll('tr:not(.vendor-detail-row)');
    rows.forEach((row, idx) => {
      if (idx >= 15) return; // Limit to top 15
      const cells = row.querySelectorAll('td');
      if (cells.length >= 6) {
        vendors.push({
          name: cells[0]?.textContent?.trim() || '',
          totalDue: cells[1]?.textContent?.trim() || '',
          current: cells[2]?.textContent?.trim() || '',
          days31to60: cells[3]?.textContent?.trim() || '',
          days61to90: cells[4]?.textContent?.trim() || '',
          days90plus: cells[5]?.textContent?.trim() || '',
          retainage: cells[6]?.textContent?.trim() || ''
        });
      }
    });
  }
  
  // Get vendor count
  const vendorCount = document.querySelectorAll('#apAgingTable tbody tr:not(.vendor-detail-row)').length || 0;
  
  return {
    summary: {
      totalDue,
      current,
      days31to60,
      days61to90,
      days90plus,
      retainage,
      dataAsOf,
      vendorCount
    },
    vendors
  };
}

async function sendAPAgingEmail(toEmail) {
  const reportData = gatherAPAgingDataForEmail();
  
  const response = await fetch('/api/email-ap-aging', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      to: toEmail,
      reportData: reportData
    })
  });
  
  const result = await response.json();
  
  if (!result.success) {
    throw new Error(result.error || 'Failed to send email');
  }
  
  return result;
}

// ============================================================
// AR AGING EMAIL FUNCTIONS
// ============================================================

function gatherARAgingDataForEmail() {
  // Get summary metrics from DOM
  const totalDue = document.getElementById('arAgingTotalDue')?.textContent || '--';
  const collectible = document.getElementById('arAgingCollectible')?.textContent || '--';
  const current = document.getElementById('arAgingCurrent')?.textContent || '--';
  const days31to60 = document.getElementById('arAging31to60')?.textContent || '--';
  const days61to90 = document.getElementById('arAging61to90')?.textContent || '--';
  const days90plus = document.getElementById('arAging90plus')?.textContent || '--';
  const retainage = document.getElementById('arAgingRetainage')?.textContent || '--';
  const avgDays = document.getElementById('arAgingAvgDays')?.textContent || '--';
  const dataAsOf = document.getElementById('arAgingDataAsOf')?.textContent || '--';
  
  // Get customer data from table (top 15 customers)
  const customers = [];
  const tableBody = document.querySelector('#arAgingTable tbody');
  if (tableBody) {
    const rows = tableBody.querySelectorAll('tr.customer-row, tr:not(.customer-detail-row)');
    rows.forEach((row, idx) => {
      if (idx >= 15) return; // Limit to top 15
      const cells = row.querySelectorAll('td');
      if (cells.length >= 7) {
        customers.push({
          name: cells[0]?.textContent?.trim() || '',
          totalDue: cells[1]?.textContent?.trim() || '',
          current: cells[2]?.textContent?.trim() || '',
          days31to60: cells[3]?.textContent?.trim() || '',
          days61to90: cells[4]?.textContent?.trim() || '',
          days90plus: cells[5]?.textContent?.trim() || '',
          retainage: cells[6]?.textContent?.trim() || ''
        });
      }
    });
  }
  
  // Get customer count
  const customerCount = document.querySelectorAll('#arAgingTable tbody tr').length || 0;
  
  return {
    summary: {
      totalDue,
      collectible,
      current,
      days31to60,
      days61to90,
      days90plus,
      retainage,
      avgDays,
      dataAsOf,
      customerCount
    },
    customers
  };
}

async function sendARAgingEmail(toEmail) {
  const reportData = gatherARAgingDataForEmail();
  
  const response = await fetch('/api/email-ar-aging', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      to: toEmail,
      reportData: reportData
    })
  });
  
  const result = await response.json();
  
  if (!result.success) {
    throw new Error(result.error || 'Failed to send email');
  }
  
  return result;
}

// Expose email functions to window scope for inline onclick handlers
window.sendAPAgingEmail = sendAPAgingEmail;
window.sendARAgingEmail = sendARAgingEmail;

// Overview Email Functions
async function sendOverviewEmail(toEmail, statusEl, sendBtn) {
  sendBtn.disabled = true;
  statusEl.textContent = "Preparing overview report...";
  statusEl.className = "email-status";
  
  try {
    const reportData = gatherOverviewDataForEmail();
    const aiAnalysis = document.getElementById('overviewAiAnalysisContent')?.textContent || '';
    
    statusEl.textContent = "Sending email...";
    
    const response = await fetch('/api/email-overview', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ to: toEmail, reportData: reportData, aiAnalysis: aiAnalysis })
    });
    
    const result = await response.json();
    
    if (result.success) {
      statusEl.textContent = "Email sent successfully!";
      statusEl.className = "email-status success";
      setTimeout(closeEmailModal, 2000);
    } else {
      statusEl.textContent = "Error: " + (result.error || "Failed to send email");
      statusEl.className = "email-status error";
    }
  } catch (e) {
    statusEl.textContent = "Error sending email: " + e.message;
    statusEl.className = "email-status error";
  } finally {
    sendBtn.disabled = false;
  }
}

function gatherOverviewDataForEmail() {
  const tiles = [];
  document.querySelectorAll('.overview-metric-tile').forEach(tile => {
    const title = tile.querySelector('.metric-tile-title')?.textContent.trim() || '';
    const stats = [];
    tile.querySelectorAll('.stat-box').forEach(box => {
      const label = box.querySelector('.stat-label')?.textContent.trim() || '';
      const value = box.querySelector('.stat-value')?.textContent.trim() || '';
      const cls = box.querySelector('.stat-value')?.className || '';
      if (label) stats.push({ label, value, class: cls });
    });
    if (title) tiles.push({ title, stats });
  });
  
  return {
    tiles: tiles,
    dataAsOf: document.getElementById('overviewDataAsOf')?.textContent || '--'
  };
}

// Income Statement Email Functions
async function sendIncomeStatementEmail(toEmail, statusEl, sendBtn) {
  sendBtn.disabled = true;
  statusEl.textContent = "Preparing income statement...";
  
  try {
    const reportData = gatherIncomeStatementDataForEmail();
    const aiAnalysis = document.getElementById('isAiAnalysisContent')?.textContent || '';
    
    statusEl.textContent = "Sending email...";
    
    const response = await fetch('/api/email-income-statement', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ to: toEmail, reportData: reportData, aiAnalysis: aiAnalysis })
    });
    
    const result = await response.json();
    
    if (result.success) {
      statusEl.textContent = "Email sent successfully!";
      statusEl.className = "email-status success";
      setTimeout(closeEmailModal, 2000);
    } else {
      statusEl.textContent = "Error: " + (result.error || "Failed to send email");
      statusEl.className = "email-status error";
    }
  } catch (e) {
    statusEl.textContent = "Error sending email: " + e.message;
    statusEl.className = "email-status error";
  } finally {
    sendBtn.disabled = false;
  }
}

function gatherIncomeStatementDataForEmail() {
  const period = document.getElementById('incomeStatementPeriod')?.textContent || '--';
  const lineItems = [];
  
  document.querySelectorAll('#incomeStatementTable tbody tr').forEach(row => {
    const cells = row.querySelectorAll('td');
    if (cells.length >= 2) {
      const name = cells[0]?.textContent.trim() || '';
      const amount = cells[1]?.textContent.trim() || '';
      const indent = (cells[0]?.style.paddingLeft?.replace('px', '') || 0) / 16;
      const isTotal = row.classList.contains('total-row') || name.toLowerCase().includes('total');
      if (name) lineItems.push({ name, amount, indent: Math.floor(indent), isTotal });
    }
  });
  
  return {
    period: period,
    summary: {
      revenue: document.querySelector('#incomeStatementSection .summary-value.revenue')?.textContent || '--',
      grossProfit: document.querySelector('#incomeStatementSection .summary-value.gross-profit')?.textContent || '--',
      operatingIncome: document.querySelector('#incomeStatementSection .summary-value.operating-income')?.textContent || '--',
      netIncome: document.querySelector('#incomeStatementSection .summary-value.net-income')?.textContent || '--'
    },
    lineItems: lineItems.slice(0, 30)
  };
}

// Balance Sheet Email Functions
async function sendBalanceSheetEmail(toEmail, statusEl, sendBtn) {
  sendBtn.disabled = true;
  statusEl.textContent = "Preparing balance sheet...";
  
  try {
    const reportData = gatherBalanceSheetDataForEmail();
    const aiAnalysis = document.getElementById('bsAiAnalysisContent')?.textContent || '';
    
    statusEl.textContent = "Sending email...";
    
    const response = await fetch('/api/email-balance-sheet', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ to: toEmail, reportData: reportData, aiAnalysis: aiAnalysis })
    });
    
    const result = await response.json();
    
    if (result.success) {
      statusEl.textContent = "Email sent successfully!";
      statusEl.className = "email-status success";
      setTimeout(closeEmailModal, 2000);
    } else {
      statusEl.textContent = "Error: " + (result.error || "Failed to send email");
      statusEl.className = "email-status error";
    }
  } catch (e) {
    statusEl.textContent = "Error sending email: " + e.message;
    statusEl.className = "email-status error";
  } finally {
    sendBtn.disabled = false;
  }
}

function gatherBalanceSheetDataForEmail() {
  const period = document.getElementById('balanceSheetPeriod')?.textContent || '--';
  const lineItems = [];
  
  document.querySelectorAll('#balanceSheetTable tbody tr').forEach(row => {
    const cells = row.querySelectorAll('td');
    if (cells.length >= 2) {
      const name = cells[0]?.textContent.trim() || '';
      const amount = cells[1]?.textContent.trim() || '';
      const indent = (cells[0]?.style.paddingLeft?.replace('px', '') || 0) / 16;
      const isTotal = row.classList.contains('total-row') || name.toLowerCase().includes('total');
      if (name) lineItems.push({ name, amount, indent: Math.floor(indent), isTotal });
    }
  });
  
  return {
    period: period,
    summary: {
      totalAssets: document.querySelector('#balanceSheet .summary-value.total-assets')?.textContent || '--',
      totalLiabilities: document.querySelector('#balanceSheet .summary-value.total-liabilities')?.textContent || '--',
      totalEquity: document.querySelector('#balanceSheet .summary-value.total-equity')?.textContent || '--'
    },
    lineItems: lineItems.slice(0, 40)
  };
}

// Cash Flow Email Functions
async function sendCashFlowEmail(toEmail, statusEl, sendBtn) {
  sendBtn.disabled = true;
  statusEl.textContent = "Preparing cash flow statement...";
  
  try {
    const reportData = gatherCashFlowDataForEmail();
    const aiAnalysis = document.getElementById('cfAiAnalysisContent')?.textContent || '';
    
    statusEl.textContent = "Sending email...";
    
    const response = await fetch('/api/email-cash-flow', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ to: toEmail, reportData: reportData, aiAnalysis: aiAnalysis })
    });
    
    const result = await response.json();
    
    if (result.success) {
      statusEl.textContent = "Email sent successfully!";
      statusEl.className = "email-status success";
      setTimeout(closeEmailModal, 2000);
    } else {
      statusEl.textContent = "Error: " + (result.error || "Failed to send email");
      statusEl.className = "email-status error";
    }
  } catch (e) {
    statusEl.textContent = "Error sending email: " + e.message;
    statusEl.className = "email-status error";
  } finally {
    sendBtn.disabled = false;
  }
}

function gatherCashFlowDataForEmail() {
  const period = document.getElementById('cashFlowPeriod')?.textContent || '--';
  const lineItems = [];
  
  document.querySelectorAll('#cashFlowTable tbody tr').forEach(row => {
    const cells = row.querySelectorAll('td');
    if (cells.length >= 2) {
      const name = cells[0]?.textContent.trim() || '';
      const amount = cells[1]?.textContent.trim() || '';
      const indent = (cells[0]?.style.paddingLeft?.replace('px', '') || 0) / 16;
      const isTotal = row.classList.contains('total-row') || name.toLowerCase().includes('total');
      if (name) lineItems.push({ name, amount, indent: Math.floor(indent), isTotal });
    }
  });
  
  return {
    period: period,
    summary: {
      operating: document.querySelector('#cashFlow .summary-value.operating')?.textContent || '--',
      investing: document.querySelector('#cashFlow .summary-value.investing')?.textContent || '--',
      financing: document.querySelector('#cashFlow .summary-value.financing')?.textContent || '--',
      netChange: document.querySelector('#cashFlow .summary-value.net-change')?.textContent || '--'
    },
    lineItems: lineItems.slice(0, 40)
  };
}

// Job Overview Email Functions
async function sendJobOverviewEmail(toEmail, statusEl, sendBtn) {
  sendBtn.disabled = true;
  statusEl.textContent = "Preparing job overview...";
  
  try {
    const reportData = gatherJobOverviewDataForEmail();
    const aiAnalysis = document.getElementById('joAiAnalysisContent')?.textContent || '';
    
    statusEl.textContent = "Sending email...";
    
    const response = await fetch('/api/email-job-overview', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ to: toEmail, reportData: reportData, aiAnalysis: aiAnalysis })
    });
    
    const result = await response.json();
    
    if (result.success) {
      statusEl.textContent = "Email sent successfully!";
      statusEl.className = "email-status success";
      setTimeout(closeEmailModal, 2000);
    } else {
      statusEl.textContent = "Error: " + (result.error || "Failed to send email");
      statusEl.className = "email-status error";
    }
  } catch (e) {
    statusEl.textContent = "Error sending email: " + e.message;
    statusEl.className = "email-status error";
  } finally {
    sendBtn.disabled = false;
  }
}

function gatherJobOverviewDataForEmail() {
  const pmFilter = document.querySelector('#jobOverview .pm-tab-btn.active')?.textContent.trim() || 'All';
  const jobs = [];
  
  document.querySelectorAll('#jobOverviewTable tbody tr').forEach(row => {
    const cells = row.querySelectorAll('td');
    if (cells.length >= 5) {
      jobs.push({
        jobNo: cells[0]?.textContent.trim() || '',
        jobName: cells[1]?.textContent.trim() || '',
        contract: cells[2]?.textContent.trim() || '',
        billed: cells[3]?.textContent.trim() || '',
        percentComplete: cells[4]?.textContent.trim() || ''
      });
    }
  });
  
  return {
    pmFilter: pmFilter,
    summary: {
      totalContract: document.getElementById('joTotalContract')?.textContent || '--',
      totalBilled: document.getElementById('joTotalBilled')?.textContent || '--',
      backlog: document.getElementById('joBacklog')?.textContent || '--',
      jobCount: jobs.length
    },
    jobs: jobs.slice(0, 20)
  };
}



// Job Budgets Email Functions
async function sendJobBudgetsEmail(toEmail, statusEl, sendBtn) {
  sendBtn.disabled = true;
  statusEl.textContent = "Preparing job budgets report...";
  
  try {
    const reportData = gatherJobBudgetsDataForEmail();
    const aiAnalysis = document.getElementById('jbAiAnalysisContent')?.textContent || '';
    
    statusEl.textContent = "Sending email...";
    
    const response = await fetch('/api/email-job-budgets', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ to: toEmail, reportData: reportData, aiAnalysis: aiAnalysis })
    });
    
    const result = await response.json();
    
    if (result.success) {
      statusEl.textContent = "Email sent successfully!";
      statusEl.className = "email-status success";
      setTimeout(closeEmailModal, 2000);
    } else {
      statusEl.textContent = "Error: " + (result.error || "Failed to send email");
      statusEl.className = "email-status error";
    }
  } catch (e) {
    statusEl.textContent = "Error sending email: " + e.message;
    statusEl.className = "email-status error";
  } finally {
    sendBtn.disabled = false;
  }
}

function gatherJobBudgetsDataForEmail() {
  const pmFilter = document.querySelector('#jobBudgets .pm-tab-btn.active')?.textContent.trim() || 'All';
  const jobs = [];
  
  document.querySelectorAll('#jobBudgetsTable tbody tr').forEach(row => {
    const cells = row.querySelectorAll('td');
    if (cells.length >= 5) {
      jobs.push({
        jobNo: cells[0]?.textContent.trim() || '',
        jobName: cells[1]?.textContent.trim() || '',
        budget: cells[2]?.textContent.trim() || '',
        actual: cells[3]?.textContent.trim() || '',
        variance: cells[4]?.textContent.trim() || ''
      });
    }
  });
  
  return {
    pmFilter: pmFilter,
    summary: {
      totalBudget: document.getElementById('jbTotalBudget')?.textContent || '--',
      totalActual: document.getElementById('jbTotalActual')?.textContent || '--',
      variance: document.getElementById('jbVariance')?.textContent || '--'
    },
    jobs: jobs.slice(0, 20)
  };
}

// Job Actuals Email Functions
async function sendJobActualsEmail(toEmail, statusEl, sendBtn) {
  sendBtn.disabled = true;
  statusEl.textContent = "Preparing job actuals report...";
  
  try {
    const reportData = gatherJobActualsDataForEmail();
    const aiAnalysis = document.getElementById('jaAiAnalysisContent')?.textContent || '';
    
    statusEl.textContent = "Sending email...";
    
    const response = await fetch('/api/email-job-actuals', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ to: toEmail, reportData: reportData, aiAnalysis: aiAnalysis })
    });
    
    const result = await response.json();
    
    if (result.success) {
      statusEl.textContent = "Email sent successfully!";
      statusEl.className = "email-status success";
      setTimeout(closeEmailModal, 2000);
    } else {
      statusEl.textContent = "Error: " + (result.error || "Failed to send email");
      statusEl.className = "email-status error";
    }
  } catch (e) {
    statusEl.textContent = "Error sending email: " + e.message;
    statusEl.className = "email-status error";
  } finally {
    sendBtn.disabled = false;
  }
}

function gatherJobActualsDataForEmail() {
  const pmFilter = document.querySelector('#jobActuals .pm-tab-btn.active')?.textContent.trim() || 'All';
  const jobs = [];
  
  document.querySelectorAll('#jobActualsTable tbody tr').forEach(row => {
    const cells = row.querySelectorAll('td');
    if (cells.length >= 3) {
      jobs.push({
        jobNo: cells[0]?.textContent.trim() || '',
        jobName: cells[1]?.textContent.trim() || '',
        actual: cells[2]?.textContent.trim() || '',
        period: cells[3]?.textContent.trim() || ''
      });
    }
  });
  
  return {
    pmFilter: pmFilter,
    summary: {
      totalActual: document.getElementById('jaTotalActual')?.textContent || '--',
      jobCount: jobs.length
    },
    jobs: jobs.slice(0, 20)
  };
}



// ============================================================
// AGING EMAIL MODAL FUNCTIONS
// ============================================================

let currentAgingEmailType = 'ap'; // 'ap' or 'ar'

function showAgingEmailModal(type) {
  currentAgingEmailType = type;
  const modal = document.getElementById('agingEmailModal');
  const header = document.getElementById('agingEmailModalHeader');
  const title = document.getElementById('agingEmailModalTitle');
  const input = document.getElementById('agingEmailTo');
  const status = document.getElementById('agingEmailStatus');
  const sendBtn = document.getElementById('sendAgingEmailBtn');
  
  // Reset all state to prevent crossover between report types
  input.value = '';
  status.textContent = '';
  status.className = 'email-status';
  if (sendBtn) {
    sendBtn.disabled = false;
    sendBtn.textContent = 'Send Email';
  }
  
  // Apply type-specific theming
  if (type === 'ap') {
    header.style.background = '#dc2626';
    title.textContent = 'Email AP Aging Report';
  } else {
    header.style.background = '#16a34a';
    title.textContent = 'Email AR Aging Report';
  }
  
  modal.classList.remove('hidden');
}

function closeAgingEmailModal() {
  const modal = document.getElementById('agingEmailModal');
  modal.classList.add('hidden');
}

function addAgingEmailRecipient(email) {
  const input = document.getElementById('agingEmailTo');
  const current = input.value.trim();
  if (current) {
    // Check if email is already added
    const emails = current.split(',').map(e => e.trim().toLowerCase());
    if (!emails.includes(email.toLowerCase())) {
      input.value = current + ', ' + email;
    }
  } else {
    input.value = email;
  }
}

async function sendAgingEmail() {
  const input = document.getElementById('agingEmailTo');
  const status = document.getElementById('agingEmailStatus');
  const btn = document.getElementById('sendAgingEmailBtn');
  const toEmail = input.value.trim();
  
  if (!toEmail) {
    status.textContent = 'Please enter a recipient email address';
    status.className = 'email-status error';
    return;
  }
  
  btn.disabled = true;
  btn.textContent = 'Sending...';
  status.textContent = 'Preparing report...';
  status.className = 'email-status';
  
  try {
    if (currentAgingEmailType === 'ap') {
      await sendAPAgingEmail(toEmail);
    } else {
      await sendARAgingEmail(toEmail);
    }
    status.textContent = 'Email sent successfully!';
    status.className = 'email-status success';
    setTimeout(closeAgingEmailModal, 2000);
  } catch (err) {
    status.textContent = 'Error: ' + err.message;
    status.className = 'email-status error';
  } finally {
    btn.disabled = false;
    btn.textContent = 'Send Email';
  }
}

// Expose aging modal functions to window scope
window.showAgingEmailModal = showAgingEmailModal;
window.closeAgingEmailModal = closeAgingEmailModal;
window.addAgingEmailRecipient = addAgingEmailRecipient;
window.sendAgingEmail = sendAgingEmail;

// Format cash analysis with green/red highlights for dollar amounts
function formatCashAnalysis(text) {
  // Only highlight the first "increased" or "decreased" amount - the net cash change
  // All other dollar amounts remain in normal black text
  
  let formatted = text;
  let hasColored = false;
  
  // Color only the FIRST "decreased $XXX" in red
  formatted = formatted.replace(
    /\b(decreased)\s+(\$[\d,\.]+[KMB]?)/i,
    (match, context, amount) => {
      if (!hasColored) {
        hasColored = true;
        return `${context} <span class="highlight-negative">${amount}</span>`;
      }
      return match;
    }
  );
  
  // Color only the FIRST "increased $XXX" in green (if not already colored)
  if (!hasColored) {
    formatted = formatted.replace(
      /\b(increased)\s+(\$[\d,\.]+[KMB]?)/i,
      (match, context, amount) => `${context} <span class="highlight-positive">${amount}</span>`
    );
  }
  
  return formatted;
}

function extractCashReportData() {
  // Get current balance and metrics
  const currentBalance = document.getElementById('dcrCurrentBalance')?.textContent || '--';
  const deposits = document.getElementById('dcrDeposits')?.textContent || '--';
  const withdrawals = document.getElementById('dcrWithdrawals')?.textContent || '--';
  // Use actual balance change (current - prior balance) not deposits - withdrawals
  // This is more accurate as it reflects actual bank balance movement
  const balanceChange = window.dcrMetrics?.balanceChange;
  let netChange;
  if (balanceChange !== undefined && balanceChange !== null) {
    const sign = balanceChange >= 0 ? '+' : '-';
    netChange = sign + '$' + Math.abs(balanceChange).toLocaleString('en-US', {maximumFractionDigits: 0});
  } else {
    netChange = document.getElementById('dcrPercentChange')?.textContent || '--';
  }
  
  // Get safety check values
  const safetyCash = document.getElementById('dcrSafetyCash')?.textContent || '--';
  const safetyAR = document.getElementById('dcrSafetyAR')?.textContent || '--';
  const safetyAP = document.getElementById('dcrSafetyAP')?.textContent || '--';
  const safetyOUB = document.getElementById('dcrSafetyOUB')?.textContent || '--';
  const safetyOpExp = document.getElementById('dcrSafetyOpExp')?.textContent || '--';
  const safetyTotal = document.getElementById('dcrSafetyTotal')?.textContent || '--';
  
  // Get view mode (daily/weekly)
  const viewMode = dcrViewMode || 'weekly';
  const periodLabel = viewMode === 'weekly' ? 'this week' : 'prior day';
  
  // Get top deposits from the table
  const depositsContainer = document.getElementById('dcrDepositsContainer');
  const topDeposits = [];
  if (depositsContainer) {
    const rows = depositsContainer.querySelectorAll('tr:not(.dcr-match-row)');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      if (cells.length >= 3) {
        const matchRow = row.nextElementSibling;
        let attribution = '';
        if (matchRow && matchRow.classList.contains('dcr-match-row')) {
          attribution = matchRow.querySelector('.match-info')?.textContent || '';
        }
        topDeposits.push({
          date: cells[0]?.textContent || '',
          description: cells[1]?.textContent || '',
          amount: cells[2]?.textContent || '',
          attribution: attribution
        });
      }
    });
  }
  
  // Get top withdrawals from the table
  const withdrawalsContainer = document.getElementById('dcrWithdrawalsContainer');
  const topWithdrawals = [];
  if (withdrawalsContainer) {
    const rows = withdrawalsContainer.querySelectorAll('tr:not(.dcr-match-row)');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      if (cells.length >= 3) {
        const matchRow = row.nextElementSibling;
        let attribution = '';
        if (matchRow && matchRow.classList.contains('dcr-match-row')) {
          attribution = matchRow.querySelector('.match-info')?.textContent || '';
        }
        topWithdrawals.push({
          date: cells[0]?.textContent || '',
          description: cells[1]?.textContent || '',
          amount: cells[2]?.textContent || '',
          attribution: attribution
        });
      }
    });
  }
  
  return {
    summary: {
      currentBalance,
      deposits,
      withdrawals,
      netChange,
      viewMode,
      periodLabel
    },
    safetyCheck: {
      cash: safetyCash,
      ar: safetyAR,
      ap: safetyAP,
      oub: safetyOUB,
      opExp: safetyOpExp,
      total: safetyTotal
    },
    topDeposits,
    topWithdrawals
  };
}

// ========================================
// JOB OVERVIEW MODULE
// ========================================

let joData = [];
let joFiltered = [];
let joArInvoices = [];
let joPmJobsChart = null;
let joPmContractChart = null;
let joPmMarginChart = null;
let joClientJobsChart = null;
let joClientContractChart = null;
let joClientMarginChart = null;
let joInitialized = false;

function initJobOverview() {
  if (joInitialized && joData.length > 0) {
    updateJobOverviewCharts();
    return;
  }
  
  const configHeader = document.querySelector('#jobOverview .config-header');
  const configBody = document.getElementById('jobOverviewConfigBody');
  if (configHeader && configBody) {
    configHeader.classList.remove('collapsed');
    configBody.classList.remove('collapsed');
  }
  
  loadJobOverviewData();
  setupJobOverviewEventListeners();
  joInitialized = true;
}

function setupJobOverviewEventListeners() {
  document.getElementById('joStatusActive')?.addEventListener('change', filterJobOverview);
  document.getElementById('joStatusInactive')?.addEventListener('change', filterJobOverview);
  document.getElementById('joStatusClosed')?.addEventListener('change', filterJobOverview);
  document.getElementById('joStatusOverhead')?.addEventListener('change', filterJobOverview);
  document.getElementById('joPmFilter')?.addEventListener('change', filterJobOverview);
  document.getElementById('joCustomerFilter')?.addEventListener('change', filterJobOverview);
}

async function loadJobOverviewData() {
  try {
    // Fetch pre-computed job metrics from the canonical metrics API
    const metricsData = await DataCache.getJobsMetrics();
    const jobs = metricsData.jobs || [];
    
    // Also load AR invoices for additional analysis
    try {
      const arData = await DataCache.getARMetrics();
      joArInvoices = arData?.invoices || [];
    } catch (arErr) {
      console.warn('Could not load AR invoices for job overview:', arErr);
      joArInvoices = [];
    }
    
    // Map metrics API response to expected format for the page
    joData = jobs.map(job => ({
      job_no: job.job_no,
      job_description: job.job_description,
      customer_name: job.customer_name,
      project_manager_name: job.project_manager,
      job_status: job.job_status,
      original_contract: job.original_contract || 0,
      tot_income_adj: job.tot_income_adj || 0,
      contract: job.contract,
      revised_contract: job.contract,
      original_cost: job.original_cost || 0,
      tot_cost_adj: job.tot_cost_adj || 0,
      revised_cost: job.budget_cost,
      actual_cost: job.actual_cost,
      billed: job.billed,
      billed_revenue: job.billed,
      earned_revenue: job.earned_revenue,
      percent_complete: job.percent_complete,
      backlog: job.backlog,
      over_under: job.over_under_billing,
      over_under_billing: job.over_under_billing,
      profit: job.profit,
      margin: job.margin,
      profit_margin: job.margin,
      has_budget: job.has_budget,
      valid_for_profit: job.valid_for_profit,
      profit_basis: job.profit_basis
    }));
    
    populateJobOverviewFilters();
    
    const dataAsOf = document.getElementById('jobOverviewDataAsOf');
    if (dataAsOf && metricsData.generated_at) {
      dataAsOf.textContent = new Date(metricsData.generated_at).toLocaleDateString();
    }
    
    filterJobOverview();
  } catch (err) {
    console.error('Error loading job overview:', err);
  }
}
async function populateJobOverviewFilters() {
  // Build PM tabs using async loader to ensure PMs are available
  await loadAndBuildPmTabs('joPmTabs', 'jo', () => {
    filterJobOverview();
  });
}

function filterJobOverview() {
  const showActive = document.getElementById('joStatusActive')?.checked;
  const showInactive = document.getElementById('joStatusInactive')?.checked;
  const showClosed = document.getElementById('joStatusClosed')?.checked;
  const showOverhead = document.getElementById('joStatusOverhead')?.checked;
  
  // Get PM from tabs instead of dropdown
  const pmFilter = getSelectedPmForPage('jo');
  
  const allowedStatuses = [];
  if (showActive) allowedStatuses.push('A');
  if (showInactive) allowedStatuses.push('I');
  if (showClosed) allowedStatuses.push('C');
  if (showOverhead) allowedStatuses.push('O');
  
  joFiltered = joData.filter(job => {
    if (allowedStatuses.length > 0 && !allowedStatuses.includes(job.job_status)) return false;
    if (pmFilter && job.project_manager_name !== pmFilter) return false;
    return true;
  });
  
  updateJobOverviewMetrics();
  updateJobOverviewCharts();
  renderProfitabilityHeatmap();
  
  // Render waterfall chart
  renderWaterfallChart();
  
  // Render migrated PM Report sections
  renderJoPmSections();
}

function updateJobOverviewMetrics() {
  // This function updates the PM Key Metrics tiles using joPmr* IDs
  // The actual metric updates are handled by renderJoPmrMetrics() in the PM section
  // This function is kept for backward compatibility but delegates to the PM metrics renderer
  
  // Just trigger the PM metrics update which handles all the metric tiles
  renderJoPmrMetrics(joFiltered);
}

// ========================================
// PROFITABILITY HEAT MAP
// ========================================

function renderProfitabilityHeatmap() {
  const container = document.getElementById('profitabilityHeatmap');
  if (!container) return;
  
  // Check if a single PM is selected
  const selectedPm = getSelectedPmForPage('jo');
  const isSinglePmSelected = selectedPm && selectedPm !== '__ALL__';
  
  // If single PM selected, render Job Status view instead
  if (isSinglePmSelected) {
    renderSinglePmHeatmap(container, selectedPm);
    return;
  }
  
  // Always use PM view when "All Project Managers" is selected
  const groupByFilter = 'pm';
  
  // Update description text
  const descEl = document.getElementById('heatmapDescription');
  if (descEl) {
    descEl.textContent = 'Profit margin by Project Manager and job size. Darker green = higher margin, red = negative margin.';
  }
  
  // Use joFiltered which is already filtered by page-level PM tabs and status checkboxes
  let baseJobs = joFiltered || [];
  
  // Exclude configured PMs (for PM view) and jobs without valid financial data
  // For closed jobs: must have billed revenue and actual cost
  // For active jobs: must have revised contract and revised cost (budget)
  const jobs = baseJobs.filter(j => {
    if (groupByFilter === 'pm' && PM_EXCLUSION_CONFIG.isExcluded(j.project_manager_name)) return false;
    
    const isClosed = j.job_status === 'C';
    if (isClosed) {
      return (j.billed_revenue || 0) > 0 && (j.actual_cost || 0) > 0;
    } else {
      return (j.revised_contract || 0) > 0 && (j.revised_cost || 0) > 0;
    }
  });
  
  if (jobs.length === 0) {
    container.innerHTML = '<div style="padding:20px;text-align:center;opacity:0.6;">No job data available for heat map</div>';
    return;
  }
  
  // Define job size ranges (contract value buckets)
  const sizeRanges = [
    { label: '<$100K', min: 0, max: 100000 },
    { label: '$100K-$500K', min: 100000, max: 500000 },
    { label: '$500K-$1M', min: 500000, max: 1000000 },
    { label: '$1M-$5M', min: 1000000, max: 5000000 },
    { label: '$5M+', min: 5000000, max: Infinity }
  ];
  
  // Determine grouping field based on filter
  const groupField = groupByFilter === 'pm' ? 'project_manager_name' : 'customer_name';
  const groupLabel = groupByFilter === 'pm' ? 'Project Manager' : 'Client';
  
  // Get unique group values from the filtered jobs
  const groups = [...new Set(jobs.map(j => j[groupField]).filter(Boolean))].sort();
  
  // Build data matrix: Group x Size Range
  const matrix = {};
  groups.forEach(group => {
    matrix[group] = {};
    sizeRanges.forEach(range => {
      matrix[group][range.label] = {
        jobs: [],
        totalContract: 0,
        totalCost: 0,
        avgMargin: null,
        jobCount: 0
      };
    });
  });
  
  // Populate matrix with job data
  jobs.forEach(job => {
    const group = job[groupField];
    if (!group || !matrix[group]) return;
    
    // For closed jobs, use actual billed revenue and actual cost
    // For active jobs, use revised contract and revised cost (budget)
    const isClosed = job.job_status === 'C';
    const contract = isClosed ? (job.billed_revenue || 0) : (job.contract || 0);
    const cost = isClosed ? (job.actual_cost || 0) : (job.revised_cost || 0);
    
    // Find size range based on contract/revenue value
    const range = sizeRanges.find(r => contract >= r.min && contract < r.max);
    if (!range) return;
    
    const cell = matrix[group][range.label];
    cell.jobs.push(job);
    cell.totalContract += contract;
    cell.totalCost += cost;
    cell.jobCount++;
  });
  
  // Calculate average margin for each cell
  Object.keys(matrix).forEach(group => {
    sizeRanges.forEach(range => {
      const cell = matrix[group][range.label];
      if (cell.jobCount > 0 && cell.totalContract > 0) {
        const profit = cell.totalContract - cell.totalCost;
        cell.avgMargin = (profit / cell.totalContract) * 100;
      }
    });
  });
  
  // Find min/max margins for color scaling
  let minMargin = 0, maxMargin = 30;
  Object.values(matrix).forEach(row => {
    Object.values(row).forEach(cell => {
      if (cell.avgMargin !== null) {
        minMargin = Math.min(minMargin, cell.avgMargin);
        maxMargin = Math.max(maxMargin, cell.avgMargin);
      }
    });
  });
  
  // Build HTML table
  let html = '<div class="heatmap-grid">';
  
  // Header row
  html += '<div class="heatmap-row header-row">';
  html += `<div class="heatmap-cell header pm-header">${groupLabel}</div>`;
  sizeRanges.forEach(range => {
    html += `<div class="heatmap-cell header">${range.label}</div>`;
  });
  html += '<div class="heatmap-cell header">Avg</div>';
  html += '</div>';
  
  // Data rows - sort groups by overall margin (highest first)
  const groupStats = groups.map(group => {
    const row = matrix[group];
    let totalContract = 0, totalCost = 0;
    Object.values(row).forEach(cell => {
      totalContract += cell.totalContract;
      totalCost += cell.totalCost;
    });
    const overallMargin = totalContract > 0 ? ((totalContract - totalCost) / totalContract) * 100 : 0;
    return { group, overallMargin, totalContract, totalCost };
  });
  groupStats.sort((a, b) => b.overallMargin - a.overallMargin);
  
  groupStats.forEach(({ group, overallMargin, totalContract }) => {
    html += '<div class="heatmap-row">';
    html += `<div class="heatmap-cell pm-label">${group}</div>`;
    
    sizeRanges.forEach(range => {
      const cell = matrix[group][range.label];
      
      if (cell.avgMargin === null || cell.jobCount === 0) {
        html += '<div class="heatmap-cell no-data">-</div>';
      } else {
        const bgColor = getHeatmapColor(cell.avgMargin, minMargin, maxMargin);
        const tooltip = `${cell.jobCount} job${cell.jobCount > 1 ? 's' : ''} | Avg: ${cell.avgMargin.toFixed(1)}% margin | Total: ${formatCurrencyCompact(cell.totalContract)}`;
        
        html += `<div class="heatmap-cell data-cell heatmap-tooltip" style="background:${bgColor}">
          ${cell.avgMargin.toFixed(1)}%
          <span class="tooltip-content">${tooltip}</span>
        </div>`;
      }
    });
    
    // PM weighted average column
    const avgBgColor = getHeatmapColor(overallMargin, minMargin, maxMargin);
    const avgTooltip = `Weighted avg margin for ${group} | Total: ${formatCurrencyCompact(totalContract)}`;
    html += `<div class="heatmap-cell data-cell heatmap-tooltip" style="background:${avgBgColor}">
      ${overallMargin.toFixed(1)}%
      <span class="tooltip-content">${avgTooltip}</span>
    </div>`;
    
    html += '</div>';
  });
  
  // Subtotal row - only show when all PMs are displayed (not filtered to single PM)
  const isAllPmsForSubtotal = !selectedPm || selectedPm === '__ALL__';
  
  if (isAllPmsForSubtotal && groupStats.length > 1) {
    // Calculate totals for each size range
    const rangeTotals = {};
    sizeRanges.forEach(range => {
      rangeTotals[range.label] = { totalContract: 0, totalCost: 0, jobCount: 0 };
    });
    
    let grandTotalContract = 0, grandTotalCost = 0;
    
    Object.keys(matrix).forEach(group => {
      sizeRanges.forEach(range => {
        const cell = matrix[group][range.label];
        rangeTotals[range.label].totalContract += cell.totalContract;
        rangeTotals[range.label].totalCost += cell.totalCost;
        rangeTotals[range.label].jobCount += cell.jobCount;
        grandTotalContract += cell.totalContract;
        grandTotalCost += cell.totalCost;
      });
    });
    
    html += '<div class="heatmap-row subtotal-row">';
    html += '<div class="heatmap-cell pm-label" style="font-weight:700;">AVERAGE</div>';
    
    sizeRanges.forEach(range => {
      const rt = rangeTotals[range.label];
      if (rt.jobCount === 0 || rt.totalContract === 0) {
        html += '<div class="heatmap-cell no-data">-</div>';
      } else {
        const avgMargin = ((rt.totalContract - rt.totalCost) / rt.totalContract) * 100;
        const bgColor = getHeatmapColor(avgMargin, minMargin, maxMargin);
        const tooltip = `${rt.jobCount} job${rt.jobCount > 1 ? 's' : ''} | Avg: ${avgMargin.toFixed(1)}% margin | Total: ${formatCurrencyCompact(rt.totalContract)}`;
        
        html += `<div class="heatmap-cell data-cell heatmap-tooltip" style="background:${bgColor}">
          ${avgMargin.toFixed(1)}%
          <span class="tooltip-content">${tooltip}</span>
        </div>`;
      }
    });
    
    // Grand total average
    const grandAvgMargin = grandTotalContract > 0 ? ((grandTotalContract - grandTotalCost) / grandTotalContract) * 100 : 0;
    const grandBgColor = getHeatmapColor(grandAvgMargin, minMargin, maxMargin);
    const grandTooltip = `Overall weighted average | Total: ${formatCurrencyCompact(grandTotalContract)}`;
    html += `<div class="heatmap-cell data-cell heatmap-tooltip" style="background:${grandBgColor}">
      ${grandAvgMargin.toFixed(1)}%
      <span class="tooltip-content">${grandTooltip}</span>
    </div>`;
    
    html += '</div>';
  }
  
  html += '</div>';
  container.innerHTML = html;
}

function getHeatmapColor(value, min, max) {
  // Normalize value between 0 and 1 (0 = loss/low, 1 = high profit)
  // Use 0% as the neutral point
  const scaleMax = Math.max(max, 30); // Ensure at least 30% scale for better color spread
  let normalized;
  
  if (value < 0) {
    // Negative margin: red gradient
    normalized = Math.max(0, (value - min) / (0 - min));
    // Interpolate from dark red to orange
    const r = 220;
    const g = Math.round(38 + (normalized * 80));
    const b = Math.round(38 + (normalized * 20));
    return `rgb(${r}, ${g}, ${b})`;
  } else {
    // Positive margin: green gradient
    normalized = Math.min(1, value / scaleMax);
    // Interpolate from yellow-green to dark green
    if (normalized < 0.3) {
      // Light green
      return `rgb(${Math.round(250 - normalized * 200)}, ${Math.round(200 + normalized * 55)}, ${Math.round(100 - normalized * 50)})`;
    } else if (normalized < 0.6) {
      // Medium green
      return `rgb(${Math.round(132 - (normalized - 0.3) * 200)}, ${Math.round(204 + (normalized - 0.3) * 30)}, ${Math.round(22 + (normalized - 0.3) * 50)})`;
    } else {
      // Dark green
      return `rgb(${Math.round(16 - (normalized - 0.6) * 20)}, ${Math.round(185 - (normalized - 0.6) * 30)}, ${Math.round(129 - (normalized - 0.6) * 30)})`;
    }
  }
}

function renderSinglePmHeatmap(container, pmName) {
  const descEl = document.getElementById('heatmapDescription');
  if (descEl) {
    descEl.textContent = `Profit margin by job status for ${pmName}. Active = estimated margin, Closed = actual margin.`;
  }
  
  // Use joData (full dataset) filtered only by PM - NOT joFiltered
  // The heatmap should always show all status rows regardless of checkbox selections
  let baseJobs = (joData || []).filter(j => j.project_manager_name === pmName);
  
  // Filter to only jobs with valid financial data
  // For closed jobs: profit margin = (billed_revenue - actual_cost) / billed_revenue
  // For active jobs: profit margin = (revised_contract - revised_cost) / revised_contract
  const jobs = baseJobs.filter(j => {
    const isClosed = j.job_status === 'C';
    if (isClosed) {
      return (j.billed_revenue || 0) > 0 && (j.actual_cost || 0) > 0;
    } else {
      return (j.revised_contract || 0) > 0 && (j.revised_cost || 0) > 0;
    }
  });
  
  if (jobs.length === 0) {
    container.innerHTML = '<div style="padding:20px;text-align:center;opacity:0.6;">No job data available for heat map</div>';
    return;
  }
  
  // Define job size ranges (contract value buckets)
  const sizeRanges = [
    { label: '<$100K', min: 0, max: 100000 },
    { label: '$100K-$500K', min: 100000, max: 500000 },
    { label: '$500K-$1M', min: 500000, max: 1000000 },
    { label: '$1M-$5M', min: 1000000, max: 5000000 },
    { label: '$5M+', min: 5000000, max: Infinity }
  ];
  
  // Define status rows
  const statusRows = [
    { label: 'Active Jobs', status: 'A', marginType: 'estimated' },
    { label: 'Closed Jobs', status: 'C', marginType: 'actual' },
    { label: 'All Jobs', status: 'ALL', marginType: 'weighted' }
  ];
  
  // Build data matrix: Status x Size Range
  const matrix = {};
  statusRows.forEach(row => {
    matrix[row.label] = {};
    sizeRanges.forEach(range => {
      matrix[row.label][range.label] = {
        jobs: [],
        totalContract: 0,
        totalCost: 0,
        avgMargin: null,
        jobCount: 0
      };
    });
  });
  
  // Populate matrix with job data
  jobs.forEach(job => {
    const isClosed = job.job_status === 'C';
    const statusLabel = isClosed ? 'Closed Jobs' : 'Active Jobs';
    
    // For closed jobs, use actual billed revenue and actual cost
    // For active jobs, use revised contract and revised cost (budget/estimated)
    const contract = isClosed ? (job.billed_revenue || 0) : (job.contract || 0);
    const cost = isClosed ? (job.actual_cost || 0) : (job.revised_cost || 0);
    
    // Find size range based on contract/revenue value
    const range = sizeRanges.find(r => contract >= r.min && contract < r.max);
    if (!range) return;
    
    // Add to status-specific row
    const cell = matrix[statusLabel][range.label];
    cell.jobs.push(job);
    cell.totalContract += contract;
    cell.totalCost += cost;
    cell.jobCount++;
    
    // Also add to "All Jobs" row
    const allCell = matrix['All Jobs'][range.label];
    allCell.jobs.push(job);
    allCell.totalContract += contract;
    allCell.totalCost += cost;
    allCell.jobCount++;
  });
  
  // Calculate average margin for each cell
  Object.keys(matrix).forEach(status => {
    sizeRanges.forEach(range => {
      const cell = matrix[status][range.label];
      if (cell.jobCount > 0 && cell.totalContract > 0) {
        const profit = cell.totalContract - cell.totalCost;
        cell.avgMargin = (profit / cell.totalContract) * 100;
      }
    });
  });
  
  // Find min/max margins for color scaling
  let minMargin = 0, maxMargin = 30;
  Object.values(matrix).forEach(row => {
    Object.values(row).forEach(cell => {
      if (cell.avgMargin !== null) {
        minMargin = Math.min(minMargin, cell.avgMargin);
        maxMargin = Math.max(maxMargin, cell.avgMargin);
      }
    });
  });
  
  // Build HTML table
  let html = '<div class="heatmap-grid">';
  
  // Header row
  html += '<div class="heatmap-row header-row">';
  html += '<div class="heatmap-cell header pm-header">Job Status</div>';
  sizeRanges.forEach(range => {
    html += `<div class="heatmap-cell header">${range.label}</div>`;
  });
  html += '</div>';
  
  // Data rows - use statusRows order (Active, Closed, All)
  statusRows.forEach(({ label }) => {
    html += '<div class="heatmap-row">';
    html += `<div class="heatmap-cell pm-label">${label}</div>`;
    
    sizeRanges.forEach(range => {
      const cell = matrix[label][range.label];
      
      if (cell.avgMargin === null || cell.jobCount === 0) {
        html += '<div class="heatmap-cell no-data">-</div>';
      } else {
        const bgColor = getHeatmapColor(cell.avgMargin, minMargin, maxMargin);
        const marginTypeLabel = label === 'Active Jobs' ? 'Est.' : label === 'Closed Jobs' ? 'Actual' : 'Wtd. Avg.';
        const tooltip = `${cell.jobCount} job${cell.jobCount > 1 ? 's' : ''} | ${marginTypeLabel}: ${cell.avgMargin.toFixed(1)}% margin | Total: ${formatCurrencyCompact(cell.totalContract)}`;
        
        html += `<div class="heatmap-cell data-cell heatmap-tooltip" style="background:${bgColor}">
          ${cell.avgMargin.toFixed(1)}%
          <span class="tooltip-content">${tooltip}</span>
        </div>`;
      }
    });
    
    html += '</div>';
  });
  
  html += '</div>';
  container.innerHTML = html;
}

// ========================================
// JOB OVERVIEW - MIGRATED PM SECTIONS
// ========================================

let joPmRadarChart = null;
let joPmrMarginChart = null;
let joPmrBudgetActualChart = null;
let joPmrBillingChart = null;
let joPmrArAgingChart = null;

function renderJoPmSections() {
  const jobs = joFiltered || [];
  const selectedPm = getSelectedPmForPage('jo');
  const isAllPms = !selectedPm || selectedPm === '__ALL__';
  
  // Render PM Key Metrics
  renderJoPmrMetrics(jobs);
  
  // Render PM Charts (Margin Distribution, Budget vs Actual, Billing Trend, AR Aging)
  renderJoPmrCharts(jobs);
  
  // Render PM Performance Radar
  renderJoPmRadarChart(jobs, selectedPm, isAllPms);
  
  // Render tables
  renderJoClientSummaryTable(jobs);
  renderJoOverUnderTable(jobs);
  renderJoMissingBudgetsTable(jobs);
}

function renderJoPmrMetrics(jobs) {
  // Count all filtered jobs (not just active)
  const totalJobs = jobs.length;
  const totalContract = jobs.reduce((sum, j) => sum + (j.revised_contract || 0), 0);
  const totalEarnedRevenue = jobs.reduce((sum, j) => sum + (j.earned_revenue || 0), 0);
  const totalBilledRevenue = jobs.reduce((sum, j) => sum + (j.billed_revenue || 0), 0);
  const backlog = totalContract - totalBilledRevenue;
  
  // Net Over/Under: Only include jobs with valid budgets (matching Over/Under Billing page calculation)
  const jobsWithValidBudget = jobs.filter(j => (j.revised_contract || 0) > 0 && (j.revised_cost || 0) > 0);
  const netOverUnder = jobsWithValidBudget.reduce((sum, j) => sum + ((j.billed_revenue || 0) - (j.earned_revenue || 0)), 0);
  
  // Get selected PM for filtering AR invoices
  const selectedPm = getSelectedPmForPage('jo');
  const isAllPms = !selectedPm || selectedPm === '__ALL__';
  
  // Build set of job numbers from filtered jobs for AR matching
  const filteredJobNos = new Set(jobs.map(j => j.job_no));
  
  // Calculate AR Exposure from AR invoices (matching PM and/or jobs)
  let arExposure = 0;
  joArInvoices.forEach(inv => {
    // Filter by PM if a specific PM is selected
    if (!isAllPms && inv.project_manager_name !== selectedPm) return;
    // Use calculated_amount_due (same as AR Aging report)
    const amtDue = parseFloat(inv.calculated_amount_due) || 0;
    if (amtDue <= 0) return;
    arExposure += amtDue;
  });
  
  // Calculate billed last month from AR invoices
  const now = new Date();
  const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
  const lastMonthStart = new Date(lastMonthEnd.getFullYear(), lastMonthEnd.getMonth(), 1);
  const excelEpoch = new Date(1899, 11, 30);
  let billedLastMonth = 0;
  
  joArInvoices.forEach(inv => {
    // Filter by PM if a specific PM is selected
    if (!isAllPms && inv.project_manager_name !== selectedPm) return;
    const invoiceDateSerial = parseFloat(inv.invoice_date) || 0;
    const invoiceDate = new Date(excelEpoch.getTime() + invoiceDateSerial * 24 * 60 * 60 * 1000);
    if (invoiceDate >= lastMonthStart && invoiceDate <= lastMonthEnd) {
      billedLastMonth += parseFloat(inv.invoice_amount) || 0;
    }
  });
  
  // Update metric tiles
  const setMetric = (id, value) => {
    const el = document.getElementById(id);
    if (el) el.textContent = value;
  };
  
  // Row 1: # of Jobs, Contract Value, Billed Revenue, Earned Revenue
  setMetric('joPmrTotalJobs', totalJobs.toLocaleString());
  setMetric('joPmrTotalContract', formatCurrencyCompact(totalContract));
  setMetric('joPmrBilledRevenue', formatCurrencyCompact(totalBilledRevenue));
  setMetric('joPmrTotalEarnedRevenue', formatCurrencyCompact(totalEarnedRevenue));
  
  // Row 2: Billed Last Month, AR Exposure, Backlog, Net Over/(Under)
  setMetric('joPmrBilledLastMonth', formatCurrencyCompact(billedLastMonth));
  setMetric('joPmrArExposure', formatCurrencyCompact(arExposure));
  setMetric('joPmrBacklog', formatCurrencyCompact(backlog));
  setMetric('joPmrNetOverUnder', formatCurrencyCompact(netOverUnder));
  
  // Color for over/under
  const ouEl = document.getElementById('joPmrNetOverUnder');
  if (ouEl) ouEl.style.color = netOverUnder >= 0 ? '#10b981' : '#ef4444';
}

function renderJoPmrCharts(jobs) {
  renderJoPmrMarginChart(jobs);
  renderJoPmrBudgetActualChart(jobs);
  renderJoPmrBillingChart(jobs);
  renderJoPmrArAgingChart(jobs);
}

function renderJoPmrMarginChart(jobs) {
  const canvas = document.getElementById('joPmrMarginChart');
  if (!canvas) return;
  
  if (joPmrMarginChart) {
    joPmrMarginChart.destroy();
    joPmrMarginChart = null;
  }
  
  const validJobs = jobs.filter(j => j.revised_contract > 0 && j.revised_cost > 0);
  const margins = validJobs.map(j => ((j.revised_contract - j.revised_cost) / j.revised_contract * 100));
  
  const buckets = [
    { label: '<0%', min: -Infinity, max: 0, count: 0 },
    { label: '0-10%', min: 0, max: 10, count: 0 },
    { label: '10-20%', min: 10, max: 20, count: 0 },
    { label: '20-30%', min: 20, max: 30, count: 0 },
    { label: '30%+', min: 30, max: Infinity, count: 0 }
  ];
  
  margins.forEach(m => {
    const bucket = buckets.find(b => m >= b.min && m < b.max);
    if (bucket) bucket.count++;
  });
  
  // Calculate max value and add headroom for data labels
  const maxCount = Math.max(...buckets.map(b => b.count));
  const yMax = Math.max(maxCount + 2, Math.ceil(maxCount * 1.25));
  
  const ctx = canvas.getContext('2d');
  joPmrMarginChart = new Chart(ctx, {
    type: 'bar',
    plugins: [ChartDataLabels],
    data: {
      labels: buckets.map(b => b.label),
      datasets: [{
        data: buckets.map(b => b.count),
        backgroundColor: ['#ef4444', '#f59e0b', '#eab308', '#84cc16', '#10b981'],
        borderRadius: 4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        datalabels: {
          display: true,
          anchor: 'end',
          align: 'top',
          offset: 2,
          font: { size: 11, weight: '600' },
          color: 'var(--text-primary)',
          formatter: (value) => value > 0 ? value : ''
        }
      },
      scales: {
        y: { beginAtZero: true, max: yMax, ticks: { stepSize: 1, color: 'var(--text-secondary)' }, grid: { color: 'var(--border-color)' } },
        x: { ticks: { color: 'var(--text-secondary)' }, grid: { display: false } }
      }
    }
  });
}

function renderJoPmrBudgetActualChart(jobs) {
  const canvas = document.getElementById('joPmrBudgetActualChart');
  if (!canvas) return;
  
  if (joPmrBudgetActualChart) {
    joPmrBudgetActualChart.destroy();
    joPmrBudgetActualChart = null;
  }
  
  const totalBudget = jobs.reduce((sum, j) => sum + (j.revised_cost || 0), 0);
  const totalActual = jobs.reduce((sum, j) => sum + (j.actual_cost || 0), 0);
  const remaining = Math.max(0, totalBudget - totalActual);
  
  const ctx = canvas.getContext('2d');
  joPmrBudgetActualChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: ['Budget vs Actual'],
      datasets: [
        {
          label: 'Actual Cost',
          data: [totalActual],
          backgroundColor: totalActual <= totalBudget ? '#10b981' : '#ef4444',
          borderRadius: { topLeft: 0, topRight: 0, bottomLeft: 4, bottomRight: 4 }
        },
        {
          label: 'Remaining Budget',
          data: [remaining],
          backgroundColor: '#e2e8f0',
          borderRadius: { topLeft: 4, topRight: 4, bottomLeft: 0, bottomRight: 0 }
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: true, position: 'bottom', labels: { boxWidth: 12, padding: 8, color: 'var(--text-secondary)' } },
        tooltip: {
          callbacks: {
            label: function(context) {
              const label = context.dataset.label || '';
              const value = context.raw || 0;
              return label + ': ' + formatCurrencyCompact(value);
            },
            afterBody: function() {
              return 'Total Budget: ' + formatCurrencyCompact(totalBudget);
            }
          }
        }
      },
      scales: {
        x: { 
          stacked: true,
          ticks: { display: false },
          grid: { display: false }
        },
        y: { 
          stacked: true,
          beginAtZero: true,
          ticks: { 
            callback: v => '$' + Math.round(v / 1000000) + 'M',
            color: 'var(--text-secondary)',
            stepSize: 25000000
          },
          grid: { color: 'var(--border-color)' }
        }
      }
    }
  });
}

function renderJoPmrBillingChart(jobs) {
  const canvas = document.getElementById('joPmrBillingChart');
  if (!canvas) return;
  
  if (joPmrBillingChart) {
    joPmrBillingChart.destroy();
    joPmrBillingChart = null;
  }
  
  // Get selected PM for filtering
  const selectedPm = getSelectedPmForPage('jo');
  const isAllPms = !selectedPm || selectedPm === '__ALL__';
  
  // Calculate trailing 6 months
  const now = new Date();
  const months = [];
  for (let i = 5; i >= 0; i--) {
    const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
    months.push({
      label: d.toLocaleDateString('en-US', { month: 'short', year: '2-digit' }),
      start: d,
      end: new Date(d.getFullYear(), d.getMonth() + 1, 0),
      total: 0
    });
  }
  
  // Sum up invoice amounts by month from AR invoices
  const excelEpoch = new Date(1899, 11, 30);
  joArInvoices.forEach(inv => {
    // Filter by PM if a specific PM is selected
    if (!isAllPms && inv.project_manager_name !== selectedPm) return;
    
    const invoiceDateSerial = parseFloat(inv.invoice_date) || 0;
    const invoiceDate = new Date(excelEpoch.getTime() + invoiceDateSerial * 24 * 60 * 60 * 1000);
    const invoiceAmount = parseFloat(inv.invoice_amount) || 0;
    
    // Find which month bucket this invoice falls into
    for (const month of months) {
      if (invoiceDate >= month.start && invoiceDate <= month.end) {
        month.total += invoiceAmount;
        break;
      }
    }
  });
  
  const ctx = canvas.getContext('2d');
  joPmrBillingChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: months.map(m => m.label),
      datasets: [{
        label: 'Billed',
        data: months.map(m => m.total),
        borderColor: '#3b82f6',
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        fill: true,
        tension: 0.3,
        pointRadius: 4,
        pointBackgroundColor: '#3b82f6'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: { legend: { display: false } },
      scales: {
        y: { beginAtZero: true, ticks: { callback: v => formatCurrencyCompact(v), color: 'var(--text-secondary)' }, grid: { color: 'var(--border-color)' } },
        x: { ticks: { color: 'var(--text-secondary)', font: { size: 9 } }, grid: { display: false } }
      }
    }
  });
}

function renderJoPmrArAgingChart(jobs) {
  const canvas = document.getElementById('joPmrArAgingChart');
  if (!canvas) return;
  
  if (joPmrArAgingChart) {
    joPmrArAgingChart.destroy();
    joPmrArAgingChart = null;
  }
  
  // Get selected PM for filtering AR invoices
  const selectedPm = getSelectedPmForPage('jo');
  const isAllPms = !selectedPm || selectedPm === '__ALL__';
  
  // Get total billed revenue from jobs
  const totalBilled = jobs.reduce((sum, j) => sum + (j.billed_revenue || 0), 0);
  
  // Calculate AR Outstanding from actual AR invoices (filtered by PM if applicable)
  let arOutstanding = 0;
  joArInvoices.forEach(inv => {
    if (!isAllPms) {
      const invPm = inv.project_manager_name || inv.pm_name || '';
      if (invPm !== selectedPm) return;
    }
    arOutstanding += parseFloat(inv.amount_due) || 0;
  });
  
  // Collected revenue = Total Billed - AR Outstanding
  const collected = Math.max(0, totalBilled - arOutstanding);
  
  // Calculate underbilled revenue: sum of (earned - billed) for jobs where billed < earned (only underbilled jobs)
  // Only include active jobs in underbilled calculation
  const activeJobs = jobs.filter(j => j.job_status === 'A');
  let underbilled = 0;
  activeJobs.forEach(j => {
    const billed = j.billed_revenue || 0;
    const earned = j.earned_revenue || 0;
    if (billed < earned) {
      // Job is underbilled - add the difference
      underbilled += (earned - billed);
    }
    // Do not count overbilled jobs (where billed > earned)
  });
  
  const ctx = canvas.getContext('2d');
  joPmrArAgingChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['Collected', 'AR Outstanding', 'Underbilled'],
      datasets: [{
        data: [Math.max(0, collected), Math.max(0, arOutstanding), Math.max(0, underbilled)],
        backgroundColor: ['#10b981', '#f59e0b', '#ef4444'],
        borderWidth: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { position: 'bottom', labels: { color: 'var(--text-primary)', font: { size: 10 } } },
        tooltip: {
          callbacks: {
            label: function(context) {
              return context.label + ': ' + formatCurrencyCompact(context.raw);
            }
          }
        }
      }
    }
  });
}

function renderJoPmRadarChart(jobs, selectedPm, isAllPms) {
  const canvas = document.getElementById('joPmRadarChart');
  if (!canvas) return;
  
  if (joPmRadarChart) {
    joPmRadarChart.destroy();
    joPmRadarChart = null;
  }
  
  const legendBox = document.getElementById('joRadarLegendBox');
  
  // Calculate portfolio averages using full joData (not status-filtered)
  const allActiveJobs = joData.filter(j => j.job_status === 'A' && !PM_EXCLUSION_CONFIG.isExcluded(j.project_manager_name));
  
  // Aggregate by PM for portfolio
  const pmStats = {};
  allActiveJobs.forEach(job => {
    const pm = job.project_manager_name;
    if (!pm || PM_EXCLUSION_CONFIG.isExcluded(pm)) return;
    if (!pmStats[pm]) pmStats[pm] = { jobs: 0, jobsWithBudget: 0, contract: 0, contractWithBudget: 0, cost: 0, billed: 0, earned: 0 };
    pmStats[pm].jobs++;
    // Track jobs with valid revenue estimates - exclude jobs without revenue
    // For closed jobs: must have contract > 0 (actual revenue)
    // For active jobs: must have revised_contract > 0 (revenue estimate)
    const hasValidRevenue = (job.contract || job.revised_contract || 0) > 0;
    const hasBudget = hasValidRevenue && (job.revised_cost || 0) > 0;
    if (hasBudget) {
      pmStats[pm].jobsWithBudget++;
      pmStats[pm].contractWithBudget += job.contract || 0;
    }
    pmStats[pm].contract += job.contract || 0;
    pmStats[pm].cost += job.revised_cost || 0;
    pmStats[pm].billed += job.billed_revenue || 0;
    pmStats[pm].earned += job.earned_revenue || 0;
  });
  
  const pmCount = Object.keys(pmStats).length;
  if (pmCount === 0) {
    if (legendBox) legendBox.innerHTML = '<div style="text-align:center;color:var(--text-muted);padding:20px;">No data available</div>';
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    return;
  }
  
  // Calculate averages
  const avgJobs = Object.values(pmStats).reduce((s, p) => s + p.jobs, 0) / pmCount;
  const avgContract = Object.values(pmStats).reduce((s, p) => s + p.contract, 0) / pmCount;
  const totalPortfolioContract = Object.values(pmStats).reduce((s, p) => s + p.contract, 0);
  const totalPortfolioCost = Object.values(pmStats).reduce((s, p) => s + p.cost, 0);
  const avgMargin = totalPortfolioContract > 0 ? ((totalPortfolioContract - totalPortfolioCost) / totalPortfolioContract * 100) : 0;
  const avgBilled = Object.values(pmStats).reduce((s, p) => s + p.billed, 0) / pmCount;
  const avgEarned = Object.values(pmStats).reduce((s, p) => s + p.earned, 0) / pmCount;
  const avgBillingPosition = avgEarned > 0 ? (avgBilled / avgEarned * 100) : 100;
  // Average job size: sum contract values ONLY from jobs with valid revenue
  // Excludes: closed jobs without revenue, active jobs without revenue estimate
  const totalJobsWithBudget = Object.values(pmStats).reduce((s, p) => s + p.jobsWithBudget, 0);
  const totalContractWithBudget = Object.values(pmStats).reduce((s, p) => s + p.contractWithBudget, 0);
  const avgJobSize = totalJobsWithBudget > 0 ? (totalContractWithBudget / totalJobsWithBudget) : 0;
  
  // Normalize so COMPANY AVERAGE = 50 (halfway between center and outer edge)
  // PM values are scaled relative to company average: value/avg * 50
  // At average = 50, at 2x average = 100, at 0 = 0
  
  const normalizeToAvg = (val, avg) => {
    if (avg === 0 || avg === undefined) return val > 0 ? 75 : 50;
    return Math.max(0, Math.min(100, (val / avg) * 50));
  };
  
  // Company average data - all values are exactly 50 (the midpoint)
  const avgData = [50, 50, 50, 50, 50];
  
  // Store actual average values for normalization of PM data
  const avgValues = {
    jobs: avgJobs,
    contract: avgContract,
    margin: avgMargin,
    jobSize: avgJobSize,
    billingPosition: avgBillingPosition
  };
  
  const datasets = [];
  let legendHtml = '';
  
  // Check if a specific PM is selected
  const showPmOverlay = !isAllPms && selectedPm;
  
  if (showPmOverlay) {
    // Get PM's active jobs from full dataset (not filtered by status checkboxes)
    const pmJobs = joData.filter(j => j.job_status === 'A' && j.project_manager_name === selectedPm);
    
    if (pmJobs.length > 0) {
      // Calculate PM metrics
      const pmContract = pmJobs.reduce((s, j) => s + (j.revised_contract || 0), 0);
      const pmCost = pmJobs.reduce((s, j) => s + (j.revised_cost || 0), 0);
      const pmMargin = pmContract > 0 ? ((pmContract - pmCost) / pmContract * 100) : 0;
      const pmBilled = pmJobs.reduce((s, j) => s + (j.billed_revenue || 0), 0);
      const pmEarned = pmJobs.reduce((s, j) => s + (j.earned_revenue || 0), 0);
      const pmBillingPosition = pmEarned > 0 ? (pmBilled / pmEarned * 100) : 100;
      // Average job size: exclude closed jobs without revenue, active jobs without revenue estimate
      const pmJobsWithBudgetArr = pmJobs.filter(j => {
        const hasRevenue = (j.contract || j.revised_contract || 0) > 0;
        return hasRevenue && (j.revised_cost || 0) > 0;
      });
      const pmContractWithBudget = pmJobsWithBudgetArr.reduce((s, j) => s + (j.revised_contract || 0), 0);
      const pmJobSize = pmJobsWithBudgetArr.length > 0 ? (pmContractWithBudget / pmJobsWithBudgetArr.length) : 0;
      
      const pmData = [
        normalizeToAvg(pmJobs.length, avgValues.jobs),
        normalizeToAvg(pmContract, avgValues.contract),
        normalizeToAvg(pmMargin, avgValues.margin),
        normalizeToAvg(pmJobSize, avgValues.jobSize),
        normalizeToAvg(pmBillingPosition, avgValues.billingPosition)
      ];
      
      // Generate point colors based on comparison to company average
      // Green if above average, yellow/orange/red if below (closer to center = more red)
      const getPointColor = (pmVal, avgVal) => {
        if (pmVal >= avgVal) {
          return '#10b981'; // Green - above average
        } else {
          // Below average: interpolate from yellow to orange to red based on how far below
          const ratio = avgVal > 0 ? pmVal / avgVal : 0; // 0 = at center, 1 = at average
          if (ratio >= 0.75) {
            return '#eab308'; // Yellow - slightly below
          } else if (ratio >= 0.5) {
            return '#f97316'; // Orange - moderately below
          } else {
            return '#ef4444'; // Red - significantly below
          }
        }
      };
      
      const pointColors = pmData.map((val, i) => getPointColor(val, avgData[i]));
      
      // Add PM dataset first (on top)
      datasets.push({
        label: selectedPm,
        data: pmData,
        actualValues: {
          jobCount: pmJobs.length,
          contractValue: pmContract,
          profitMargin: pmMargin,
          avgJobSize: pmJobSize,
          billingPosition: pmBillingPosition
        },
        backgroundColor: 'rgba(59, 130, 246, 0.15)',
        borderColor: '#3b82f6',
        borderWidth: 2,
        pointBackgroundColor: pointColors,
        pointBorderColor: pointColors,
        pointRadius: 5,
        pointHoverRadius: 7
      });
      
      legendHtml = `
        <div style="display:flex;gap:16px;justify-content:center;margin-top:8px;">
          <span style="display:flex;align-items:center;gap:4px;"><span style="width:12px;height:3px;background:#3b82f6;border-radius:2px;"></span><span style="font-size:11px;color:var(--text-secondary);">${selectedPm}</span></span>
          <span style="display:flex;align-items:center;gap:4px;"><span style="width:12px;height:3px;background:#9ca3af;border-radius:2px;border:1px dashed #9ca3af;"></span><span style="font-size:11px;color:var(--text-secondary);">Company Avg</span></span>
        </div>
      `;
    } else {
      legendHtml = `
        <div style="display:flex;gap:16px;justify-content:center;margin-top:8px;">
          <span style="display:flex;align-items:center;gap:4px;"><span style="width:12px;height:3px;background:#9ca3af;border-radius:2px;"></span><span style="font-size:11px;color:var(--text-secondary);">Company Average</span></span>
        </div>
        <div style="text-align:center;color:var(--text-muted);font-size:10px;margin-top:4px;">No active jobs for ${selectedPm}</div>
      `;
    }
  } else {
    // All PMs selected - show company average only
    legendHtml = `
      <div style="display:flex;gap:16px;justify-content:center;margin-top:8px;">
        <span style="display:flex;align-items:center;gap:4px;"><span style="width:12px;height:3px;background:#9ca3af;border-radius:2px;"></span><span style="font-size:11px;color:var(--text-secondary);">Company Average</span></span>
      </div>
      <div style="text-align:center;color:var(--text-muted);font-size:10px;margin-top:4px;">Select a PM to compare</div>
    `;
  }
  
  // Add company average dataset (shown for all cases)
  datasets.push({
    label: 'Company Avg',
    data: avgData,
    actualValues: {
      jobCount: Math.round(avgJobs),
      contractValue: avgContract,
      profitMargin: avgMargin,
      avgJobSize: avgJobSize,
      billingPosition: avgBillingPosition
    },
    backgroundColor: 'rgba(156, 163, 175, 0.15)',
    borderColor: '#9ca3af',
    borderWidth: showPmOverlay ? 1 : 2,
    borderDash: showPmOverlay ? [5, 5] : [],
    pointBackgroundColor: '#9ca3af'
  });
  
  const ctx = canvas.getContext('2d');
  // Store actual values for tooltips
  const actualAvgValues = {
    jobCount: Math.round(avgJobs),
    contractValue: avgContract,
    profitMargin: avgMargin,
    avgJobSize: avgJobSize,
    billingPosition: avgBillingPosition
  };
  
  joPmRadarChart = new Chart(ctx, {
    type: 'radar',
    data: {
      labels: ['Job Count', 'Contract Value', 'Profit Margin', 'Avg Job Size', 'Billing Position'],
      datasets: datasets
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        r: {
          beginAtZero: true,
          max: 100,
          ticks: { display: false },
          grid: { color: 'var(--border-color)' },
          pointLabels: { color: 'var(--text-primary)', font: { size: 10 } }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: function(context) {
              const label = context.dataset.label || '';
              const index = context.dataIndex;
              const actualVals = context.dataset.actualValues || actualAvgValues;
              const labels = ['Job Count', 'Contract Value', 'Profit Margin', 'Avg Job Size', 'Billing Position'];
              
              if (index === 0) return label + ': ' + actualVals.jobCount + ' jobs';
              if (index === 1) return label + ': ' + formatCurrencyCompact(actualVals.contractValue);
              if (index === 2) return label + ': ' + actualVals.profitMargin.toFixed(1) + '%';
              if (index === 3) return label + ': ' + formatCurrencyCompact(actualVals.avgJobSize) + ' avg';
              if (index === 4) return label + ': ' + actualVals.billingPosition.toFixed(0) + '% billed vs earned';
              return label + ': ' + context.raw.toFixed(1);
            }
          }
        }
      }
    }
  });
  
  if (legendBox) {
    legendBox.innerHTML = legendHtml;
  }
}

function renderJoClientSummaryTable(jobs) {
  const tbody = document.getElementById('joClientSummaryTableBody');
  if (!tbody) return;
  
  // Calculate last month date range
  const now = new Date();
  const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
  const lastMonthStart = new Date(lastMonthEnd.getFullYear(), lastMonthEnd.getMonth(), 1);
  const excelEpoch = new Date(1899, 11, 30);
  
  // Build map of billedLastMonth by customer from AR invoices
  const billedLastMonthByClient = {};
  if (joArInvoices && joArInvoices.length > 0) {
    joArInvoices.forEach(inv => {
      const invoiceDateSerial = parseFloat(inv.invoice_date) || 0;
      const invoiceDate = new Date(excelEpoch.getTime() + invoiceDateSerial * 24 * 60 * 60 * 1000);
      if (invoiceDate >= lastMonthStart && invoiceDate <= lastMonthEnd) {
        const client = inv.customer_name || 'Unknown';
        billedLastMonthByClient[client] = (billedLastMonthByClient[client] || 0) + (parseFloat(inv.invoice_amount) || 0);
      }
    });
  }
  
  // Group by client
  const clientMap = {};
  jobs.forEach(job => {
    const client = job.customer_name || 'Unknown';
    if (!clientMap[client]) {
      clientMap[client] = { contract: 0, cost: 0, profit: 0, billedLastMonth: 0, billedToDate: 0, costToDate: 0 };
    }
    clientMap[client].contract += job.contract || 0;
    clientMap[client].cost += job.revised_cost || 0;
    clientMap[client].profit += (job.contract || 0) - (job.revised_cost || 0);
    clientMap[client].billedToDate += job.billed_revenue || 0;
    clientMap[client].costToDate += job.actual_cost || 0;
    clientMap[client].billedLastMonth = billedLastMonthByClient[client] || 0;
  });
  
  const clients = Object.entries(clientMap).map(([name, data]) => ({
    name,
    ...data,
    margin: data.contract > 0 ? (data.profit / data.contract * 100) : 0
  })).sort((a, b) => b.contract - a.contract);
  
  // Calculate totals
  const totals = clients.reduce((acc, c) => ({
    contract: acc.contract + c.contract,
    cost: acc.cost + c.cost,
    profit: acc.profit + c.profit,
    billedLastMonth: acc.billedLastMonth + c.billedLastMonth,
    billedToDate: acc.billedToDate + c.billedToDate,
    costToDate: acc.costToDate + c.costToDate
  }), { contract: 0, cost: 0, profit: 0, billedLastMonth: 0, billedToDate: 0, costToDate: 0 });
  totals.avgMargin = totals.contract > 0 ? (totals.profit / totals.contract * 100) : 0;
  totals.count = clients.length;
  
  // Store in pagination state
  const state = joTablePagination.clientSummary;
  state.data = clients;
  state.totals = totals;
  state.page = 1;
  state.totalPages = Math.ceil(clients.length / state.pageSize);
  
  joRenderClientSummaryRows(clients.slice(0, state.pageSize), state);
  joTableUpdatePaginationControls('clientSummary');
}

function joRenderClientSummaryRows(pageData, state) {
  const tbody = document.getElementById('joClientSummaryTableBody');
  if (!tbody) return;
  const totals = state.totals;
  
  let html = `
    <tr class="pmr-subtotal-row">
      <td>TOTAL (${totals.count})</td>
      <td class="text-right">${formatCurrencyCompact(totals.contract)}</td>
      <td class="text-right">${formatCurrencyCompact(totals.cost)}</td>
      <td class="text-right">${formatCurrencyCompact(totals.profit)}</td>
      <td class="text-right" style="color:${totals.avgMargin >= 0 ? '#10b981' : '#ef4444'}">${totals.avgMargin.toFixed(1)}%</td>
      <td class="text-right">${formatCurrencyCompact(totals.billedLastMonth)}</td>
      <td class="text-right">${formatCurrencyCompact(totals.billedToDate)}</td>
      <td class="text-right">${formatCurrencyCompact(totals.costToDate)}</td>
    </tr>
  `;
  
  html += pageData.map(c => `
    <tr class="jo-detail-row">
      <td>${c.name}</td>
      <td class="text-right">${formatCurrencyCompact(c.contract)}</td>
      <td class="text-right">${formatCurrencyCompact(c.cost)}</td>
      <td class="text-right">${formatCurrencyCompact(c.profit)}</td>
      <td class="text-right" style="color:${c.margin >= 0 ? '#10b981' : '#ef4444'}">${c.margin.toFixed(1)}%</td>
      <td class="text-right">${formatCurrencyCompact(c.billedLastMonth)}</td>
      <td class="text-right">${formatCurrencyCompact(c.billedToDate)}</td>
      <td class="text-right">${formatCurrencyCompact(c.costToDate)}</td>
    </tr>
  `).join('');
  
  tbody.innerHTML = html;
}

function renderJoOverUnderTable(jobs) {
  const tbody = document.getElementById('joOverUnderTableBody');
  if (!tbody) return;
  
  const jobsWithOverUnder = jobs.filter(j => j.revised_contract > 0).map(j => ({
    ...j,
    overUnder: (j.billed_revenue || 0) - (j.earned_revenue || 0),
    pctComplete: j.revised_contract > 0 ? ((j.earned_revenue || 0) / j.revised_contract * 100) : 0
  })).sort((a, b) => Math.abs(b.overUnder) - Math.abs(a.overUnder));
  
  // Calculate totals
  const totals = jobsWithOverUnder.reduce((acc, j) => ({
    contract: acc.contract + (j.revised_contract || 0),
    actualCost: acc.actualCost + (j.actual_cost || 0),
    earnedRevenue: acc.earnedRevenue + (j.earned_revenue || 0),
    billedRevenue: acc.billedRevenue + (j.billed_revenue || 0),
    overUnder: acc.overUnder + j.overUnder
  }), { contract: 0, actualCost: 0, earnedRevenue: 0, billedRevenue: 0, overUnder: 0 });
  totals.avgPctComplete = totals.contract > 0 ? (totals.earnedRevenue / totals.contract * 100) : 0;
  totals.count = jobsWithOverUnder.length;
  
  // Store in pagination state
  const state = joTablePagination.overUnder;
  state.data = jobsWithOverUnder;
  state.totals = totals;
  state.page = 1;
  state.totalPages = Math.ceil(jobsWithOverUnder.length / state.pageSize);
  
  joRenderOverUnderRows(jobsWithOverUnder.slice(0, state.pageSize), state);
  joTableUpdatePaginationControls('overUnder');
}

function joRenderOverUnderRows(pageData, state) {
  const tbody = document.getElementById('joOverUnderTableBody');
  if (!tbody) return;
  const totals = state.totals;
  
  let html = `
    <tr class="pmr-subtotal-row">
      <td colspan="3">TOTAL (${totals.count} jobs)</td>
      <td class="text-right">${formatCurrencyCompact(totals.contract)}</td>
      <td class="text-right">${formatCurrencyCompact(totals.actualCost)}</td>
      <td class="text-right">${totals.avgPctComplete.toFixed(1)}%</td>
      <td class="text-right">${formatCurrencyCompact(totals.earnedRevenue)}</td>
      <td class="text-right">${formatCurrencyCompact(totals.billedRevenue)}</td>
      <td class="text-right" style="color:${totals.overUnder >= 0 ? '#10b981' : '#ef4444'};font-weight:600;">${formatCurrencyCompact(totals.overUnder)}</td>
    </tr>
  `;
  
  html += pageData.map(j => `
    <tr class="jo-detail-row">
      <td>${j.job_no}</td>
      <td>${j.job_description || '-'}</td>
      <td>${j.customer_name || '-'}</td>
      <td class="text-right">${formatCurrencyCompact(j.revised_contract)}</td>
      <td class="text-right">${formatCurrencyCompact(j.actual_cost)}</td>
      <td class="text-right">${j.pctComplete.toFixed(1)}%</td>
      <td class="text-right">${formatCurrencyCompact(j.earned_revenue)}</td>
      <td class="text-right">${formatCurrencyCompact(j.billed_revenue)}</td>
      <td class="text-right" style="color:${j.overUnder >= 0 ? '#10b981' : '#ef4444'};font-weight:600;">${formatCurrencyCompact(j.overUnder)}</td>
    </tr>
  `).join('');
  
  tbody.innerHTML = html;
}

function renderJoMissingBudgetsTable(jobs) {
  const tbody = document.getElementById('joMissingBudgetsTableBody');
  if (!tbody) return;
  
  // Jobs with >$2500 actual cost but missing budget
  const missingBudgets = jobs.filter(j => {
    const actualCost = j.actual_cost || 0;
    const budgetedRev = j.revised_contract || 0;
    const budgetedCost = j.revised_cost || 0;
    return actualCost > 2500 && (budgetedRev === 0 || budgetedCost === 0);
  }).sort((a, b) => (b.actual_cost || 0) - (a.actual_cost || 0));
  
  // Calculate totals
  const totals = missingBudgets.reduce((acc, j) => ({
    actualCost: acc.actualCost + (j.actual_cost || 0),
    budgetedRev: acc.budgetedRev + (j.revised_contract || 0),
    budgetedCost: acc.budgetedCost + (j.revised_cost || 0)
  }), { actualCost: 0, budgetedRev: 0, budgetedCost: 0 });
  totals.count = missingBudgets.length;
  
  // Store in pagination state
  const state = joTablePagination.missingBudgets;
  state.data = missingBudgets;
  state.totals = totals;
  state.page = 1;
  state.totalPages = Math.ceil(missingBudgets.length / state.pageSize);
  
  joRenderMissingBudgetsRows(missingBudgets.slice(0, state.pageSize), state);
  joTableUpdatePaginationControls('missingBudgets');
}

function joRenderMissingBudgetsRows(pageData, state) {
  const tbody = document.getElementById('joMissingBudgetsTableBody');
  if (!tbody) return;
  const totals = state.totals;
  
  let html = `
    <tr class="pmr-subtotal-row">
      <td colspan="2">TOTAL (${totals.count} jobs)</td>
      <td>-</td>
      <td>-</td>
      <td class="text-right">${formatCurrencyCompact(totals.actualCost)}</td>
      <td class="text-right">${formatCurrencyCompact(totals.budgetedRev)}</td>
      <td class="text-right">${formatCurrencyCompact(totals.budgetedCost)}</td>
      <td>-</td>
    </tr>
  `;
  
  html += pageData.map(j => {
    const issue = [];
    if (!j.revised_contract) issue.push('No Revenue');
    if (!j.revised_cost) issue.push('No Cost');
    return `
      <tr class="jo-detail-row">
        <td>${j.job_no}</td>
        <td>${j.job_description || '-'}</td>
        <td>${j.customer_name || '-'}</td>
        <td>${j.job_status || '-'}</td>
        <td class="text-right">${formatCurrencyCompact(j.actual_cost)}</td>
        <td class="text-right">${formatCurrencyCompact(j.revised_contract)}</td>
        <td class="text-right">${formatCurrencyCompact(j.revised_cost)}</td>
        <td style="color:#f59e0b;">${issue.join(', ')}</td>
      </tr>
    `;
  }).join('');
  
  tbody.innerHTML = html;
}

// Toggle functions for the migrated tables
function toggleJoClientSummaryDetail() {
  const table = document.getElementById('joClientSummaryTable');
  const btn = document.getElementById('joClientSummaryToggle');
  if (table && btn) {
    table.classList.toggle('expanded');
    btn.textContent = table.classList.contains('expanded') ? 'Collapse' : 'Expand';
  }
}

function toggleJoOverUnderDetail() {
  const table = document.getElementById('joOverUnderTable');
  const btn = document.getElementById('joOverUnderToggle');
  if (table && btn) {
    table.classList.toggle('expanded');
    btn.textContent = table.classList.contains('expanded') ? 'Collapse' : 'Expand';
  }
}

function toggleJoMissingBudgetsDetail() {
  const table = document.getElementById('joMissingBudgetsTable');
  const btn = document.getElementById('joMissingBudgetsToggle');
  if (table && btn) {
    table.classList.toggle('expanded');
    btn.textContent = table.classList.contains('expanded') ? 'Collapse' : 'Expand';
  }
}

// ========================================
// PM PERFORMANCE RADAR CHART
// ========================================

let pmRadarChart = null;
let pmRadarData = null;

// Pagination state for Job Overview tables
const joTablePagination = {
  clientSummary: { page: 1, pageSize: 10, data: [], totalPages: 1, totals: null },
  overUnder: { page: 1, pageSize: 10, data: [], totalPages: 1, totals: null },
  missingBudgets: { page: 1, pageSize: 10, data: [], totalPages: 1, totals: null }
};

function joTableChangePage(tableKey, delta) {
  const state = joTablePagination[tableKey];
  const newPage = state.page + delta;
  if (newPage >= 1 && newPage <= state.totalPages) {
    state.page = newPage;
    joTableRenderPage(tableKey);
  }
}

function joTableChangePageSize(tableKey, newSize) {
  const state = joTablePagination[tableKey];
  state.pageSize = parseInt(newSize);
  state.page = 1;
  state.totalPages = Math.ceil(state.data.length / state.pageSize);
  joTableRenderPage(tableKey);
}

function joTableUpdatePaginationControls(tableKey) {
  const state = joTablePagination[tableKey];
  const prevBtn = document.getElementById(`jo${tableKey.charAt(0).toUpperCase() + tableKey.slice(1)}PrevBtn`);
  const nextBtn = document.getElementById(`jo${tableKey.charAt(0).toUpperCase() + tableKey.slice(1)}NextBtn`);
  const pageInfo = document.getElementById(`jo${tableKey.charAt(0).toUpperCase() + tableKey.slice(1)}PageInfo`);
  
  if (prevBtn) prevBtn.disabled = state.page <= 1;
  if (nextBtn) nextBtn.disabled = state.page >= state.totalPages;
  if (pageInfo) {
    const start = (state.page - 1) * state.pageSize + 1;
    const end = Math.min(state.page * state.pageSize, state.data.length);
    pageInfo.textContent = `${start}-${end} of ${state.data.length}`;
  }
}


function joTableRenderPage(tableKey) {
  const state = joTablePagination[tableKey];
  const start = (state.page - 1) * state.pageSize;
  const end = start + state.pageSize;
  const pageData = state.data.slice(start, end);
  
  if (tableKey === 'clientSummary') {
    joRenderClientSummaryRows(pageData, state);
  } else if (tableKey === 'overUnder') {
    joRenderOverUnderRows(pageData, state);
  } else if (tableKey === 'missingBudgets') {
    joRenderMissingBudgetsRows(pageData, state);
  }
  joTableUpdatePaginationControls(tableKey);
}
function initPmRadarSelect() {
  // Radar chart now uses pmrSelectedPm from main config - no separate dropdown needed
  // This function is kept for compatibility but does nothing
}

function calculatePmRadarData() {
  // Use jobActualsData which has billed/earned revenue, combined with jobBudgetsData for contract/cost
  if ((!jobActualsData || jobActualsData.length === 0) && (!jobBudgetsData || jobBudgetsData.length === 0)) return null;
  
  // Build budget map for quick lookup
  const budgetMap = new Map();
  jobBudgetsData.forEach(b => budgetMap.set(String(b.job_no), b));
  
  // Filter to active jobs only, excluding configured PMs
  const activeJobs = jobActualsData.filter(j => {
    const budget = budgetMap.get(String(j.job_no));
    const status = budget?.job_status || j.job_status;
    const pmName = j.project_manager_name || budget?.project_manager_name;
    const contract = parseFloat(budget?.revised_contract) || j.revised_contract || 0;
    return status === 'A' && pmName && !PM_EXCLUSION_CONFIG.isExcluded(pmName) && contract > 0;
  });
  
  if (activeJobs.length === 0) return null;
  
  // Aggregate by PM
  const pmStats = {};
  activeJobs.forEach(job => {
    const budget = budgetMap.get(String(job.job_no)) || {};
    const pm = job.project_manager_name || budget.project_manager_name;
    if (!pm) return;
    
    if (!pmStats[pm]) {
      pmStats[pm] = {
        name: pm,
        jobCount: 0,
        jobsWithBudget: 0,
        contractValue: 0,
        contractWithBudget: 0,
        revisedCost: 0,
        billedRevenue: 0,
        earnedRevenue: 0
      };
    }
    pmStats[pm].jobCount++;
    const contract = parseFloat(budget.revised_contract) || job.contract || 0;
    const cost = parseFloat(budget.revised_cost) || job.revised_cost || 0;
    const billed = parseFloat(job.billed_revenue) || parseFloat(job.billed) || 0;
    const actualCost = parseFloat(job.actual_cost) || 0;
    const status = budget?.job_status || job.job_status || '';
    // Track jobs with valid data for avgJobSize:
    // - Active jobs: must have contract > 0 AND budget cost > 0
    // - Closed jobs: must have billed > 0 AND actual cost > 0
    const isValidForAvgSize = status === 'C' 
      ? (billed > 0 && actualCost > 0)
      : (contract > 0 && cost > 0);
    if (isValidForAvgSize) {
      pmStats[pm].jobsWithBudget++;
      // Use contract for active, billed for closed
      pmStats[pm].contractWithBudget += status === 'C' ? billed : contract;
    }
    pmStats[pm].contractValue += contract;
    pmStats[pm].revisedCost += cost;
    pmStats[pm].billedRevenue += job.billed_revenue || 0;
    pmStats[pm].earnedRevenue += job.earned_revenue || 0;
  });
  
  // Calculate derived metrics for each PM
  const pmData = Object.values(pmStats).map(pm => {
    const profitMargin = pm.contractValue > 0 ? ((pm.contractValue - pm.revisedCost) / pm.contractValue) * 100 : 0;
    const overUnderPct = pm.earnedRevenue > 0 ? ((pm.billedRevenue - pm.earnedRevenue) / pm.earnedRevenue) * 100 : 0;
    // Average job size: use contractWithBudget (only jobs with budgets) divided by jobsWithBudget count
    const avgJobSize = pm.jobsWithBudget > 0 ? pm.contractWithBudget / pm.jobsWithBudget : 0;
    
    return {
      ...pm,
      profitMargin,
      overUnderPct,
      avgJobSize
    };
  });
  
  // Calculate portfolio averages
  const totals = pmData.reduce((acc, pm) => {
    acc.jobCount += pm.jobCount;
    acc.jobsWithBudget += pm.jobsWithBudget;
    acc.contractValue += pm.contractValue;
    acc.contractWithBudget += pm.contractWithBudget;
    acc.revisedCost += pm.revisedCost;
    acc.billedRevenue += pm.billedRevenue;
    acc.earnedRevenue += pm.earnedRevenue;
    return acc;
  }, { jobCount: 0, jobsWithBudget: 0, contractValue: 0, contractWithBudget: 0, revisedCost: 0, billedRevenue: 0, earnedRevenue: 0 });
  
  const avgProfitMargin = totals.contractValue > 0 ? ((totals.contractValue - totals.revisedCost) / totals.contractValue) * 100 : 0;
  const avgOverUnderPct = totals.earnedRevenue > 0 ? ((totals.billedRevenue - totals.earnedRevenue) / totals.earnedRevenue) * 100 : 0;
  const avgJobCount = pmData.length > 0 ? totals.jobCount / pmData.length : 0;
  const avgContractValue = pmData.length > 0 ? totals.contractValue / pmData.length : 0;
  // Average job size: use contractWithBudget divided by jobsWithBudget count
  const avgJobSize = totals.jobsWithBudget > 0 ? totals.contractWithBudget / totals.jobsWithBudget : 0;
  
  return {
    pms: pmData,
    portfolio: {
      profitMargin: avgProfitMargin,
      overUnderPct: avgOverUnderPct,
      jobCount: avgJobCount,
      contractValue: avgContractValue,
      avgJobSize: avgJobSize
    }
  };
}

function renderPmRadarChart() {
  console.log('[RADAR DEBUG] renderPmRadarChart v2 called - Dec 29');
  const canvas = document.getElementById('pmRadarChart');
  const legendBox = document.getElementById('radarLegendBox');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  // Use the PM selected in config options (pmrSelectedPm) - ignore '__ALL__' for radar comparison
  const selectedPm = (pmrSelectedPm && pmrSelectedPm !== '__ALL__' && !PM_EXCLUSION_CONFIG.isExcluded(pmrSelectedPm)) 
    ? pmrSelectedPm 
    : null;
  
  // Calculate data if not already done
  if (!pmRadarData) {
    pmRadarData = calculatePmRadarData();
  }
  
  if (!pmRadarData) {
    if (legendBox) legendBox.innerHTML = '<span style="color:var(--text-muted);">No data available</span>';
    return;
  }
  
  const portfolio = pmRadarData.portfolio;
  const pmInfo = selectedPm ? pmRadarData.pms.find(p => p.name === selectedPm) : null;
  
  // Define metrics for radar (all normalized 0-100 for comparison)
  const metrics = ['Profit Margin', 'Job Count', 'Contract Value', 'Avg Job Size', 'Billing Position'];
  
  // Normalize values for radar chart - COMPANY AVERAGE = 50 (halfway)
  // Each metric is scaled so company average is always at 50%
  // Values above average go toward 100, below average go toward 0
  
  function normalizeValue(value, metric) {
    // Get the company average for this metric
    let avg;
    if (metric === 'profitMargin') avg = portfolio.profitMargin;
    else if (metric === 'jobCount') avg = portfolio.jobCount;
    else if (metric === 'contractValue') avg = portfolio.contractValue;
    else if (metric === 'avgJobSize') avg = portfolio.avgJobSize;
    else if (metric === 'overUnderPct') avg = portfolio.overUnderPct;
    else avg = 50;
    
    // Handle edge case where average is 0 or very small
    if (Math.abs(avg) < 0.001) {
      // If average is ~0, use absolute scaling
      if (Math.abs(value) < 0.001) return 50;
      return value > 0 ? 75 : 25;
    }
    
    // Scale so that average = 50
    // value/avg * 50 means: at avg, result is 50; at 2x avg, result is 100; at 0, result is 0
    const normalized = (value / avg) * 50;
    
    // Clamp to 0-100 range
    return Math.max(0, Math.min(100, normalized));
  }
  
  // Portfolio average data
  const portfolioData = [
    normalizeValue(portfolio.profitMargin, 'profitMargin'),
    normalizeValue(portfolio.jobCount, 'jobCount'),
    normalizeValue(portfolio.contractValue, 'contractValue'),
    normalizeValue(portfolio.avgJobSize, 'avgJobSize'),
    normalizeValue(portfolio.overUnderPct, 'overUnderPct')
  ];
  console.log('[Radar] Portfolio raw:', portfolio);
  console.log('[Radar] Portfolio normalized (should all be 50):', portfolioData);
  
  // PM specific data
  const pmChartData = pmInfo ? [
    normalizeValue(pmInfo.profitMargin, 'profitMargin'),
    normalizeValue(pmInfo.jobCount, 'jobCount'),
    normalizeValue(pmInfo.contractValue, 'contractValue'),
    normalizeValue(pmInfo.avgJobSize, 'avgJobSize'),
    normalizeValue(pmInfo.overUnderPct, 'overUnderPct')
  ] : null;
  
  const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
  const textColor = isDarkMode ? '#e2e8f0' : '#374151';
  const gridColor = isDarkMode ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.1)';
  
  // Function to get color based on normalized value (0-100)
  // Red (low) -> Yellow (middle) -> Green (high)
  function getValueColor(value) {
    const v = Math.max(0, Math.min(100, value));
    if (v <= 50) {
      // Red to Yellow (0-50)
      const ratio = v / 50;
      const r = 239;
      const g = Math.round(68 + (180 * ratio)); // 68 to 248
      const b = Math.round(68 * (1 - ratio)); // 68 to 0
      return `rgba(${r}, ${g}, ${b}, 1)`;
    } else {
      // Yellow to Green (50-100)
      const ratio = (v - 50) / 50;
      const r = Math.round(248 - (232 * ratio)); // 248 to 16
      const g = Math.round(180 + (5 * ratio)); // 180 to 185
      const b = Math.round(0 + (129 * ratio)); // 0 to 129
      return `rgba(${r}, ${g}, ${b}, 1)`;
    }
  }
  
  // Build datasets
  const datasets = [{
    label: 'Company Average',
    data: portfolioData,
    backgroundColor: 'rgba(99, 102, 241, 0.2)',
    borderColor: 'rgba(99, 102, 241, 0.8)',
    borderWidth: 2,
    pointBackgroundColor: 'rgba(99, 102, 241, 1)',
    pointRadius: 4
  }];
  
  if (pmChartData) {
    // Generate per-point colors based on value
    const pointColors = pmChartData.map(v => getValueColor(v));
    
    datasets.push({
      label: selectedPm,
      data: pmChartData,
      backgroundColor: 'rgba(100, 100, 100, 0.15)',
      borderColor: 'rgba(150, 150, 150, 0.6)',
      borderWidth: 2,
      pointBackgroundColor: pointColors,
      pointBorderColor: pointColors,
      pointRadius: 7,
      pointHoverRadius: 9
    });
  }
  
  // Destroy existing chart
  if (pmRadarChart) {
    pmRadarChart.destroy();
  }
  
  pmRadarChart = new Chart(ctx, {
    type: 'radar',
    data: {
      labels: metrics,
      datasets: datasets
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: function(context) {
              const idx = context.dataIndex;
              const pm = context.dataset.label;
              const isPortfolio = pm === 'Company Average';
              const source = isPortfolio ? portfolio : pmInfo;
              if (!source) return '';
              
              const rawValues = [
                `${source.profitMargin.toFixed(1)}%`,
                source.jobCount.toString(),
                formatCurrencyCompact(source.contractValue),
                formatCurrencyCompact(source.avgJobSize),
                `${source.overUnderPct >= 0 ? '+' : ''}${source.overUnderPct.toFixed(1)}%`
              ];
              return `${pm}: ${rawValues[idx]}`;
            }
          }
        }
      },
      scales: {
        r: {
          beginAtZero: true,
          max: 100,
          ticks: {
            display: false,
            stepSize: 25
          },
          grid: {
            color: gridColor
          },
          angleLines: {
            color: gridColor
          },
          pointLabels: {
            color: textColor,
            font: { size: 11, weight: '500' }
          }
        }
      }
    }
  });
  
  // Update legend
  if (legendBox) {
    let legendHtml = `
      <div class="radar-legend-item">
        <div class="radar-legend-color" style="background:rgba(99, 102, 241, 0.7);"></div>
        <span>Company Average</span>
      </div>
    `;
    if (selectedPm) {
      legendHtml += `
        <div class="radar-legend-item">
          <div class="radar-legend-gradient" style="width:80px;height:16px;border-radius:3px;background:linear-gradient(to right, #ef4444, #f59e0b, #10b981);"></div>
          <span>${selectedPm} (color = performance)</span>
        </div>
      `;
    } else {
      legendHtml += `
        <div class="radar-legend-hint" style="color:var(--text-muted);font-size:12px;margin-top:8px;">
          Select a specific PM above to compare against company average
        </div>
      `;
    }
    legendBox.innerHTML = legendHtml;
  }
}

// ========================================
// INCOME STATEMENT WATERFALL CHART
// ========================================

let isWaterfallChart = null;

function renderIsWaterfallChart(retryCount = 0) {
  const canvas = document.getElementById('isWaterfallChart');
  const section = document.getElementById('isWaterfallSection');
  
  // Check if we're in single period mode
  const viewMode = document.getElementById('isViewMode')?.value || 'single';
  
  // Hide/show section based on view mode
  if (section) {
    if (viewMode !== 'single') {
      section.style.display = 'none';
      return;
    }
    section.style.display = 'block';
  }
  
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  
  // Get current period settings
  const periodType = document.getElementById('isPeriodType')?.value || 'month';
  const periodSelect = document.getElementById('isPeriodSelect');
  let periodValue = periodSelect?.value;
  
  // If no period value, try to get the first option as fallback
  if (!periodValue && periodSelect?.options?.length > 0) {
    periodValue = periodSelect.options[0].value;
  }
  
  // If still no data, retry a few times (handles page reload timing)
  if (!periodValue || !isAccountGroups?.income_statement?.groups) {
    if (retryCount < 3) {
      setTimeout(() => renderIsWaterfallChart(retryCount + 1), 150);
    }
    return;
  }
  
  // Build income statement rows for current period
  const periodMonths = getPeriodMonths(periodValue, periodType);
  const groups = isAccountGroups.income_statement.groups;
  const rows = buildIncomeStatementRows(periodMonths, groups);
  
  // Extract key values for waterfall - DETAILED breakdown
  const getValue = (label) => {
    const row = rows.find(r => r.label === label);
    return row ? (row.value || 0) : 0;
  };
  
  // Detailed categories from account_groups.json
  const revenue = getValue('Revenue');
  
  // Direct Expenses breakdown
  const directLabor = getValue('Direct Labor');
  const materials = getValue('Materials');
  const subcontracts = getValue('Subcontracts');
  const rentedEquipment = getValue('Rented Equipment');
  const otherDirectCosts = getValue('Other Direct Costs');
  
  // Indirect Expenses breakdown
  const indirectLabor = getValue('Indirect Labor');
  const depreciation = getValue('Depreciation');
  const vehicleExpense = getValue('Vehicle Expense');
  const otherIndirectCosts = getValue('Other Indirect Costs');
  
  const grossProfit = getValue('Gross Profit');
  const operatingExpenses = getValue('Operating Expenses');
  const operatingIncome = getValue('Operating Income');
  
  const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
  const textColor = isDarkMode ? '#e2e8f0' : '#374151';
  const gridColor = isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.08)';
  
  // Destroy existing chart
  if (isWaterfallChart) {
    isWaterfallChart.destroy();
  }
  
  // Build waterfall data using floating bars [base, top] - DETAILED breakdown
  // Sequence: Revenue → Direct Labor → Materials → Subcontracts → Other Direct →
  //           Indirect Labor → Other Indirect → Gross Profit → Operating Exp → Operating Income
  
  let waterfallData = [];
  let labels = [];
  let runningTotal = revenue;
  
  // 1. Revenue (starting point)
  waterfallData.push([0, revenue]);
  labels.push('Revenue');
  
  // 2. Direct Labor (deduction)
  if (Math.abs(directLabor) > 0.01) {
    const afterDirectLabor = runningTotal - Math.abs(directLabor);
    waterfallData.push([afterDirectLabor, runningTotal]);
    labels.push('Direct Labor');
    runningTotal = afterDirectLabor;
  }
  
  // 3. Materials (deduction)
  if (Math.abs(materials) > 0.01) {
    const afterMaterials = runningTotal - Math.abs(materials);
    waterfallData.push([afterMaterials, runningTotal]);
    labels.push('Materials');
    runningTotal = afterMaterials;
  }
  
  // 4. Subcontracts (deduction)
  if (Math.abs(subcontracts) > 0.01) {
    const afterSubcontracts = runningTotal - Math.abs(subcontracts);
    waterfallData.push([afterSubcontracts, runningTotal]);
    labels.push('Subcontracts');
    runningTotal = afterSubcontracts;
  }
  
  // 5. Other Direct Costs (Rented Equipment + Other Direct)
  const otherDirect = Math.abs(rentedEquipment) + Math.abs(otherDirectCosts);
  if (otherDirect > 0.01) {
    const afterOtherDirect = runningTotal - otherDirect;
    waterfallData.push([afterOtherDirect, runningTotal]);
    labels.push('Other Direct');
    runningTotal = afterOtherDirect;
  }
  
  // 6. Indirect Labor (deduction)
  if (Math.abs(indirectLabor) > 0.01) {
    const afterIndirectLabor = runningTotal - Math.abs(indirectLabor);
    waterfallData.push([afterIndirectLabor, runningTotal]);
    labels.push('Indirect Labor');
    runningTotal = afterIndirectLabor;
  }
  
  // 7. Other Indirect Costs (Depreciation + Vehicle + Other Indirect)
  const otherIndirect = Math.abs(depreciation) + Math.abs(vehicleExpense) + Math.abs(otherIndirectCosts);
  if (otherIndirect > 0.01) {
    const afterOtherIndirect = runningTotal - otherIndirect;
    waterfallData.push([afterOtherIndirect, runningTotal]);
    labels.push('Other Indirect');
    runningTotal = afterOtherIndirect;
  }
  
  // 8. Gross Profit (subtotal)
  waterfallData.push(grossProfit >= 0 ? [0, grossProfit] : [grossProfit, 0]);
  labels.push('Gross Profit');
  runningTotal = grossProfit;
  
  // 9. Operating Expenses (grouped as one bar)
  if (Math.abs(operatingExpenses) > 0.01) {
    const afterOpExp = runningTotal - Math.abs(operatingExpenses);
    waterfallData.push([afterOpExp, runningTotal]);
    labels.push('Operating Exp');
    runningTotal = afterOpExp;
  }
  
  // 10. Operating Income (final result)
  waterfallData.push(operatingIncome >= 0 ? [0, operatingIncome] : [operatingIncome, 0]);
  labels.push('Op Income');
  
  // Create gradient colors for green and red bars
  const chartHeight = canvas.height || 300;
  
  // Green gradient (dark to light, top to bottom)
  const greenGradient = ctx.createLinearGradient(0, 0, 0, chartHeight);
  greenGradient.addColorStop(0, 'rgba(5, 150, 105, 0.9)');  // Darker green at top
  greenGradient.addColorStop(1, 'rgba(52, 211, 153, 0.75)'); // Lighter green at bottom
  
  // Red gradient (dark to light, top to bottom)
  const redGradient = ctx.createLinearGradient(0, 0, 0, chartHeight);
  redGradient.addColorStop(0, 'rgba(185, 28, 28, 0.9)');  // Darker red at top
  redGradient.addColorStop(1, 'rgba(248, 113, 113, 0.75)'); // Lighter red at bottom
  
  // Assign colors: green for revenue/profit, red for deductions/expenses
  const getColor = (label, data) => {
    const val = Array.isArray(data) ? data[1] - data[0] : data;
    // Revenue (green gradient)
    if (label === 'Revenue') return greenGradient;
    // All expense/deduction categories (red gradient)
    if (['Direct Labor', 'Materials', 'Subcontracts', 'Other Direct',
         'Indirect Labor', 'Other Indirect', 'Operating Exp'].includes(label)) {
      return redGradient;
    }
    // Profit subtotals (green if positive, red if negative)
    if (['Gross Profit', 'Op Income'].includes(label)) {
      return val >= 0 ? greenGradient : redGradient;
    }
    return greenGradient;
  };
  
  // Border colors (solid)
  const getBorderColor = (label, data) => {
    const val = Array.isArray(data) ? data[1] - data[0] : data;
    if (label === 'Revenue') return 'rgba(5, 150, 105, 1)';
    if (['Direct Labor', 'Materials', 'Subcontracts', 'Other Direct',
         'Indirect Labor', 'Other Indirect', 'Operating Exp'].includes(label)) {
      return 'rgba(185, 28, 28, 1)';
    }
    if (['Gross Profit', 'Op Income'].includes(label)) {
      return val >= 0 ? 'rgba(5, 150, 105, 1)' : 'rgba(185, 28, 28, 1)';
    }
    return 'rgba(5, 150, 105, 1)';
  };
  
  const backgroundColors = labels.map((label, i) => getColor(label, waterfallData[i]));
  const borderColors = labels.map((label, i) => getBorderColor(label, waterfallData[i]));
  
  const showDataLabels = document.getElementById('isWaterfallDataLabels')?.checked || false;
  
  isWaterfallChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        label: 'Amount',
        data: waterfallData,
        backgroundColor: backgroundColors,
        borderColor: borderColors,
        borderWidth: 1,
        borderRadius: 4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: function(context) {
              const data = context.raw;
              let value;
              if (Array.isArray(data)) {
                value = Math.abs(data[1] - data[0]);
              } else {
                value = Math.abs(data);
              }
              return '$' + value.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
          }
        },
        datalabels: {
          display: showDataLabels,
          color: textColor,
          anchor: 'end',
          align: 'top',
          offset: 2,
          font: { size: 10, weight: 'bold' },
          formatter: function(value) {
            let amount;
            if (Array.isArray(value)) {
              amount = Math.abs(value[1] - value[0]);
            } else {
              amount = Math.abs(value);
            }
            if (amount >= 1000000) {
              return '$' + (amount / 1000000).toFixed(1) + 'M';
            } else if (amount >= 1000) {
              return '$' + (amount / 1000).toFixed(0) + 'K';
            }
            return '$' + amount.toFixed(0);
          }
        }
      },
      scales: {
        x: {
          grid: { display: false },
          ticks: { color: textColor, font: { size: 10 } }
        },
        y: {
          grid: { color: gridColor },
          ticks: {
            color: textColor,
            callback: function(value) {
              if (Math.abs(value) >= 1000000) {
                return '$' + (value / 1000000).toFixed(1) + 'M';
              } else if (Math.abs(value) >= 1000) {
                return '$' + (value / 1000).toFixed(0) + 'K';
              }
              return '$' + value;
            }
          }
        }
      }
    },
    plugins: [ChartDataLabels]
  });
}

// ========================================
// REVENUE TO PROFIT WATERFALL CHART (JOB OVERVIEW)
// ========================================

let waterfallChart = null;

function renderWaterfallChart() {
  const canvas = document.getElementById('waterfallChart');
  if (!canvas || !joData || joData.length === 0) return;
  
  const ctx = canvas.getContext('2d');
  const groupBy = document.getElementById('waterfallGroupBy')?.value || 'portfolio';
  
  // Filter to active jobs only, excluding configured PMs
  const activeJobs = joData.filter(j => 
    j.job_status === 'A' && 
    j.project_manager_name && 
    !PM_EXCLUSION_CONFIG.isExcluded(j.project_manager_name) &&
    (j.revised_contract || 0) > 0
  );
  
  if (activeJobs.length === 0) return;
  
  const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
  const textColor = isDarkMode ? '#e2e8f0' : '#374151';
  const gridColor = isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.08)';
  
  let labels = [];
  let contractData = [];
  let costData = [];
  let profitData = [];
  
  if (groupBy === 'portfolio') {
    // Single waterfall for entire portfolio
    const totals = activeJobs.reduce((acc, job) => {
      acc.contract += job.contract || 0;
      acc.cost += job.revised_cost || 0;
      return acc;
    }, { contract: 0, cost: 0 });
    
    totals.profit = totals.contract - totals.cost;
    
    labels = ['Contract Value', 'Est. Cost', 'Gross Profit'];
    // For waterfall effect, we show: starting value, negative (deduction), final value
    contractData = [totals.contract, 0, 0];
    costData = [0, -totals.cost, 0];
    profitData = [0, 0, totals.profit];
  } else if (groupBy === 'pm') {
    // Aggregate by PM
    const pmStats = {};
    activeJobs.forEach(job => {
      const pm = job.project_manager_name;
      if (!pmStats[pm]) {
        pmStats[pm] = { contract: 0, cost: 0 };
      }
      pmStats[pm].contract += job.contract || 0;
      pmStats[pm].cost += job.revised_cost || 0;
    });
    
    // Sort by contract value descending, take top 8
    const sortedPMs = Object.entries(pmStats)
      .map(([name, stats]) => ({
        name,
        contract: stats.contract,
        cost: stats.cost,
        profit: stats.contract - stats.cost
      }))
      .sort((a, b) => b.contract - a.contract)
      .slice(0, 8);
    
    labels = sortedPMs.map(pm => pm.name);
    contractData = sortedPMs.map(pm => pm.contract);
    costData = sortedPMs.map(pm => pm.cost);
    profitData = sortedPMs.map(pm => pm.profit);
  } else if (groupBy === 'client') {
    // Aggregate by client
    const clientStats = {};
    activeJobs.forEach(job => {
      const client = job.customer_name || 'Unknown';
      if (!clientStats[client]) {
        clientStats[client] = { contract: 0, cost: 0 };
      }
      clientStats[client].contract += job.contract || 0;
      clientStats[client].cost += job.revised_cost || 0;
    });
    
    // Sort by contract value descending, take top 8
    const sortedClients = Object.entries(clientStats)
      .map(([name, stats]) => ({
        name,
        contract: stats.contract,
        cost: stats.cost,
        profit: stats.contract - stats.cost
      }))
      .sort((a, b) => b.contract - a.contract)
      .slice(0, 8);
    
    labels = sortedClients.map(c => c.name.length > 15 ? c.name.substring(0, 15) + '...' : c.name);
    contractData = sortedClients.map(c => c.contract);
    costData = sortedClients.map(c => c.cost);
    profitData = sortedClients.map(c => c.profit);
  }
  
  // Destroy existing chart
  if (waterfallChart) {
    waterfallChart.destroy();
  }
  
  if (groupBy === 'portfolio') {
    // Special waterfall visualization for portfolio
    const totals = activeJobs.reduce((acc, job) => {
      acc.contract += job.contract || 0;
      acc.cost += job.revised_cost || 0;
      return acc;
    }, { contract: 0, cost: 0 });
    totals.profit = totals.contract - totals.cost;
    
    // Waterfall: Contract full height, Cost shows deduction (floating bar), Profit is result
    // Using floating bars: [base, top] format for each bar
    waterfallChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: ['Contract Value', 'Est. Cost (Deduction)', 'Gross Profit'],
        datasets: [{
          label: 'Amount',
          data: [
            [0, totals.contract],  // Contract: full bar from 0 to contract value
            [totals.profit, totals.contract],  // Cost: floating bar from profit to contract (shows deduction)
            totals.profit >= 0 ? [0, totals.profit] : [totals.profit, 0]  // Profit: from 0 to profit (or negative)
          ],
          backgroundColor: [
            'rgba(99, 102, 241, 0.8)',  // Contract - blue
            'rgba(239, 68, 68, 0.8)',   // Cost - red
            totals.profit >= 0 ? 'rgba(16, 185, 129, 0.8)' : 'rgba(239, 68, 68, 0.8)'  // Profit - green/red
          ],
          borderColor: [
            'rgba(99, 102, 241, 1)',
            'rgba(239, 68, 68, 1)',
            totals.profit >= 0 ? 'rgba(16, 185, 129, 1)' : 'rgba(239, 68, 68, 1)'
          ],
          borderWidth: 1,
          borderRadius: 4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: function(context) {
                const idx = context.dataIndex;
                const values = [totals.contract, totals.cost, totals.profit];
                const labels = ['Contract Value', 'Est. Cost', 'Gross Profit'];
                const prefix = idx === 2 && totals.profit < 0 ? 'Loss: ' : '';
                return `${labels[idx]}: ${prefix}${formatCurrencyCompact(Math.abs(values[idx]))}`;
              }
            }
          }
        },
        scales: {
          x: {
            grid: { display: false },
            ticks: { color: textColor, font: { size: 11 } }
          },
          y: {
            grid: { color: gridColor },
            ticks: {
              color: textColor,
              callback: value => formatCurrencyCompact(value)
            }
          }
        }
      }
    });
  } else {
    // Grouped bar chart for PM/Client comparison
    waterfallChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [
          {
            label: 'Contract Value',
            data: contractData,
            backgroundColor: 'rgba(99, 102, 241, 0.7)',
            borderColor: 'rgba(99, 102, 241, 1)',
            borderWidth: 1
          },
          {
            label: 'Est. Cost',
            data: costData,
            backgroundColor: 'rgba(239, 68, 68, 0.7)',
            borderColor: 'rgba(239, 68, 68, 1)',
            borderWidth: 1
          },
          {
            label: 'Gross Profit',
            data: profitData,
            backgroundColor: profitData.map(p => p >= 0 ? 'rgba(16, 185, 129, 0.7)' : 'rgba(239, 68, 68, 0.7)'),
            borderColor: profitData.map(p => p >= 0 ? 'rgba(16, 185, 129, 1)' : 'rgba(239, 68, 68, 1)'),
            borderWidth: 1
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: true,
            position: 'top',
            labels: {
              color: textColor,
              usePointStyle: true,
              pointStyle: 'rect',
              padding: 15,
              font: { size: 11 }
            }
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                return `${context.dataset.label}: ${formatCurrencyCompact(context.raw)}`;
              }
            }
          }
        },
        scales: {
          x: {
            grid: { display: false },
            ticks: {
              color: textColor,
              font: { size: 10 },
              maxRotation: 45,
              minRotation: 0
            }
          },
          y: {
            grid: { color: gridColor },
            ticks: {
              color: textColor,
              callback: value => formatCurrencyCompact(value)
            }
          }
        }
      }
    });
  }
}

function getJobOverviewSubtitle() {
  const filters = [];
  const showActive = document.getElementById('joStatusActive')?.checked;
  const showInactive = document.getElementById('joStatusInactive')?.checked;
  const showClosed = document.getElementById('joStatusClosed')?.checked;
  const showOverhead = document.getElementById('joStatusOverhead')?.checked;
  
  const statusFilters = [];
  if (showActive) statusFilters.push('Active');
  if (showInactive) statusFilters.push('Inactive');
  if (showClosed) statusFilters.push('Closed');
  if (showOverhead) statusFilters.push('Overhead');
  if (statusFilters.length > 0 && statusFilters.length < 4) {
    filters.push(`Status: ${statusFilters.join(', ')}`);
  }
  
  const pm = document.getElementById('joPmFilter')?.value;
  if (pm) filters.push(`PM: ${pm}`);
  const client = document.getElementById('joCustomerFilter')?.value;
  if (client) filters.push(`Client: ${client}`);
  
  const total = joFiltered?.length || 0;
  let subtitle = `${total} Job${total !== 1 ? 's' : ''}`;
  if (filters.length > 0) subtitle += ` | ${filters.join(' | ')}`;
  return subtitle;
}

function getJobOverviewTableHtml() {
  if (!joFiltered || joFiltered.length === 0) {
    return "<p>No job data available</p>";
  }
  
  const totalJobs = joFiltered.length;
  const totalContract = joFiltered.reduce((sum, j) => sum + (j.revised_contract || 0), 0);
  const totalBilled = joFiltered.reduce((sum, j) => sum + (j.billed_revenue || 0), 0);
  const totalEarned = joFiltered.reduce((sum, j) => sum + (j.earned_revenue || 0), 0);
  const totalOverUnder = totalBilled - totalEarned;
  
  const jobsWithValidMargin = joFiltered.filter(j => j.revised_contract > 0 && j.revised_cost > 0);
  let avgProfitMargin = 0;
  if (jobsWithValidMargin.length > 0) {
    const totalContractForMargin = jobsWithValidMargin.reduce((sum, j) => sum + j.revised_contract, 0);
    const totalCostForMargin = jobsWithValidMargin.reduce((sum, j) => sum + j.revised_cost, 0);
    const totalProfitForMargin = totalContractForMargin - totalCostForMargin;
    avgProfitMargin = totalContractForMargin > 0 ? (totalProfitForMargin / totalContractForMargin) * 100 : 0;
  }
  
  const overUnderColor = totalOverUnder >= 0 ? '#10b981' : '#dc2626';
  const marginColor = avgProfitMargin >= 0 ? '#10b981' : '#dc2626';
  
  let html = `<div style="margin-bottom:20px;">
    <h3 style="margin:0 0 12px 0;font-size:14px;color:#374151;">Key Metrics</h3>
    <table style="border-collapse:collapse;font-size:12px;">
      <tr>
        <td style="padding:6px 16px 6px 0;color:#6b7280;">Total Jobs:</td>
        <td style="padding:6px 0;font-weight:600;">${totalJobs.toLocaleString()}</td>
      </tr>
      <tr>
        <td style="padding:6px 16px 6px 0;color:#6b7280;">Contract Value:</td>
        <td style="padding:6px 0;font-weight:600;">${formatCurrency(totalContract)}</td>
      </tr>
      <tr>
        <td style="padding:6px 16px 6px 0;color:#6b7280;">Billed Revenue:</td>
        <td style="padding:6px 0;font-weight:600;">${formatCurrency(totalBilled)}</td>
      </tr>
      <tr>
        <td style="padding:6px 16px 6px 0;color:#6b7280;">Over/(Under) Bill:</td>
        <td style="padding:6px 0;font-weight:600;color:${overUnderColor};">${formatCurrency(totalOverUnder)}</td>
      </tr>
      <tr>
        <td style="padding:6px 16px 6px 0;color:#6b7280;">Est. Profit Margin:</td>
        <td style="padding:6px 0;font-weight:600;color:${marginColor};">${avgProfitMargin.toFixed(1)}%</td>
      </tr>
    </table>
  </div>`;
  
  return html;
}

function getJobOverviewCsvData() {
  if (!joFiltered || joFiltered.length === 0) {
    return "";
  }
  
  let csv = "Job #,Description,Client,Status,Project Manager,Contract Value,Billed Revenue,Earned Revenue,Over/(Under) Bill,Est. Profit Margin %\n";
  
  joFiltered.forEach(job => {
    const status = getJobStatusLabel(job.job_status);
    const overUnder = (job.billed_revenue || 0) - (job.earned_revenue || 0);
    const margin = job.contract > 0 && job.revised_cost > 0 
      ? ((job.contract - job.revised_cost) / job.contract) * 100 
      : 0;
    
    csv += `"${job.job_no}","${(job.job_description || '').replace(/"/g, '""')}","${(job.customer_name || '').replace(/"/g, '""')}","${status.label}","${(job.project_manager_name || '').replace(/"/g, '""')}",${job.contract || 0},${job.billed_revenue || 0},${job.earned_revenue || 0},${overUnder},${margin.toFixed(1)}\n`;
  });
  
  return csv;
}

async function captureJobOverviewCharts() {
  try {
    const chartConfigs = [
      { chart: joPmJobsChart, title: '# of Jobs by PM' },
      { chart: joPmContractChart, title: 'Contract Value by PM' },
      { chart: joPmMarginChart, title: 'Profit Margin % by PM' },
      { chart: joClientJobsChart, title: '# of Jobs by Client' },
      { chart: joClientContractChart, title: 'Contract Value by Client' },
      { chart: joClientMarginChart, title: 'Profit Margin % by Client' }
    ];
    
    const loadImage = (src) => new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = src;
    });
    
    const chartImages = [];
    for (const cfg of chartConfigs) {
      if (cfg.chart) {
        try {
          const base64 = cfg.chart.toBase64Image("image/png", 1);
          const img = await loadImage(base64);
          if (img) chartImages.push({ img, title: cfg.title });
        } catch (e) {
          console.log("Error getting chart image:", cfg.title, e);
        }
      }
    }
    
    console.log("Captured", chartImages.length, "job overview chart images");
    
    if (chartImages.length === 0) {
      console.log("No chart images captured");
      return null;
    }
    
    const chartWidth = 350;
    const chartHeight = 200;
    const titleHeight = 25;
    const padding = 12;
    const tileHeight = titleHeight + chartHeight;
    
    const cols = 3;
    const rows = 2;
    
    const compositeCanvas = document.createElement("canvas");
    compositeCanvas.width = cols * chartWidth + (cols + 1) * padding;
    compositeCanvas.height = rows * tileHeight + (rows + 1) * padding;
    const ctx = compositeCanvas.getContext("2d");
    
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);
    
    for (let i = 0; i < chartImages.length; i++) {
      const { img, title } = chartImages[i];
      const col = i % cols;
      const row = Math.floor(i / cols);
      const x = padding + col * (chartWidth + padding);
      const y = padding + row * (tileHeight + padding);
      
      ctx.fillStyle = "#374151";
      ctx.font = "bold 13px Arial";
      ctx.textAlign = "left";
      ctx.fillText(title, x, y + 16);
      
      if (img) {
        ctx.drawImage(img, x, y + titleHeight, chartWidth, chartHeight);
      }
    }
    
    const dataUrl = compositeCanvas.toDataURL("image/jpeg", 0.85);
    const base64Data = dataUrl.split(",")[1];
    const sizeKB = Math.round(base64Data.length / 1024);
    console.log("Job Overview composite chart image size:", sizeKB, "KB");
    
    return base64Data;
  } catch (err) {
    console.error("Job Overview chart capture error:", err.message);
    return null;
  }
}

function updateJobOverviewCharts() {
  const isDarkMode = document.documentElement.getAttribute("data-theme") === "dark" || document.body.classList.contains('dark-mode');
  const textColor = isDarkMode ? '#e2e8f0' : '#374151';
  const gridColor = isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
  
  const pmFilteredJobs = joFiltered.filter(j => !PM_EXCLUSION_CONFIG.isExcluded(j.project_manager_name));
  const pmData = aggregateJobsByField(pmFilteredJobs, 'project_manager_name');
  const customerData = aggregateJobsByField(joFiltered, 'customer_name');
  
  renderJoPmJobsChart(pmData, textColor, gridColor, false);
  renderJoPmContractChart(pmData, textColor, gridColor, false);
  renderJoPmMarginChart(pmData, textColor, gridColor, false);
  renderJoClientJobsChart(customerData, textColor, gridColor, false);
  renderJoClientContractChart(customerData, textColor, gridColor, false);
  renderJoClientMarginChart(customerData, textColor, gridColor, false);
  
  updateJoChartStats(pmData, customerData);
}

function updateJoChartStats(pmData, clientData) {
  updateJoStatSet(pmData, 'joPm', 'jobCount', false);
  updateJoStatSet(pmData, 'joPm', 'contractValue', true);
  updateJoStatSet(pmData, 'joPm', 'profitMargin', false, true);
  updateJoStatSet(clientData, 'joClient', 'jobCount', false);
  updateJoStatSet(clientData, 'joClient', 'contractValue', true);
  updateJoStatSet(clientData, 'joClient', 'profitMargin', false, true);
}

function updateJoStatSet(data, prefix, field, isCurrency, isPercent) {
  const fieldSuffix = field === 'jobCount' ? 'Jobs' : field === 'contractValue' ? 'Contract' : 'Margin';
  
  if (!data || data.length === 0) {
    document.getElementById(`${prefix}${fieldSuffix}Avg`).textContent = '-';
    document.getElementById(`${prefix}${fieldSuffix}High`).textContent = '-';
    document.getElementById(`${prefix}${fieldSuffix}Low`).textContent = '-';
    document.getElementById(`${prefix}${fieldSuffix}HighName`).textContent = '';
    document.getElementById(`${prefix}${fieldSuffix}LowName`).textContent = '';
    return;
  }
  
  const values = data.map(d => d[field]);
  const avg = values.reduce((sum, v) => sum + v, 0) / values.length;
  const maxVal = Math.max(...values);
  const minVal = Math.min(...values);
  const maxItem = data.find(d => d[field] === maxVal);
  const minItem = data.find(d => d[field] === minVal);
  
  const avgEl = document.getElementById(`${prefix}${fieldSuffix}Avg`);
  const highEl = document.getElementById(`${prefix}${fieldSuffix}High`);
  const lowEl = document.getElementById(`${prefix}${fieldSuffix}Low`);
  const highNameEl = document.getElementById(`${prefix}${fieldSuffix}HighName`);
  const lowNameEl = document.getElementById(`${prefix}${fieldSuffix}LowName`);
  
  if (avgEl) {
    if (isCurrency) avgEl.textContent = formatCurrency(avg);
    else if (isPercent) avgEl.textContent = avg.toFixed(1) + '%';
    else avgEl.textContent = avg.toFixed(1);
  }
  if (highEl) {
    if (isCurrency) highEl.textContent = formatCurrency(maxVal);
    else if (isPercent) highEl.textContent = maxVal.toFixed(1) + '%';
    else highEl.textContent = maxVal;
  }
  if (lowEl) {
    if (isCurrency) lowEl.textContent = formatCurrency(minVal);
    else if (isPercent) lowEl.textContent = minVal.toFixed(1) + '%';
    else lowEl.textContent = minVal;
  }
  if (highNameEl) highNameEl.textContent = maxItem?.name || '';
  if (lowNameEl) lowNameEl.textContent = minItem?.name || '';
}

function aggregateJobsByField(jobs, field) {
  const groups = {};
  jobs.forEach(job => {
    const key = job[field] || 'Unknown';
    if (!groups[key]) {
      groups[key] = { 
        name: key, 
        jobCount: 0, 
        contractValue: 0, 
        revisedCost: 0,
        estimatedProfit: 0 
      };
    }
    groups[key].jobCount++;
    groups[key].contractValue += job.contract || 0;
    groups[key].revisedCost += job.revised_cost || 0;
    groups[key].estimatedProfit += job.profit || 0;
  });
  
  return Object.values(groups)
    .filter(g => g.contractValue > 0 || g.jobCount > 0)
    .map(g => ({
      ...g,
      profitMargin: g.contractValue > 0 && g.revisedCost > 0 
        ? ((g.contractValue - g.revisedCost) / g.contractValue) * 100 
        : 0
    }))
    .sort((a, b) => b.contractValue - a.contractValue)
    .slice(0, 15);
}

function createJoGradient(ctx, color1, color2) {
  const gradient = ctx.createLinearGradient(0, 0, 0, 300);
  gradient.addColorStop(0, color1);
  gradient.addColorStop(1, color2);
  return gradient;
}

function getJoBarColors(count) {
  const colors = [
    ['#1e40af', '#1e3a8a'],
    ['#047857', '#064e3b'],
    ['#7c3aed', '#5b21b6'],
    ['#0d9488', '#0f766e'],
    ['#dc2626', '#991b1b'],
    ['#ea580c', '#c2410c'],
    ['#4f46e5', '#3730a3'],
    ['#0891b2', '#0e7490'],
    ['#be185d', '#9d174d'],
    ['#65a30d', '#4d7c0f']
  ];
  const result = [];
  for (let i = 0; i < count; i++) {
    result.push(colors[i % colors.length]);
  }
  return result;
}

function renderJoPmJobsChart(data, textColor, gridColor, showDataLabels) {
  const ctx = document.getElementById('joPmJobsChart');
  if (!ctx) return;
  
  if (joPmJobsChart) joPmJobsChart.destroy();
  
  const sortedData = [...data].sort((a, b) => b.jobCount - a.jobCount);
  const context = ctx.getContext('2d');
  
  joPmJobsChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: sortedData.map(d => d.name.length > 12 ? d.name.substring(0, 12) + '...' : d.name),
      datasets: [{
        data: sortedData.map(d => d.jobCount),
        backgroundColor: ChartThemeManager.createGradient(context),
        borderRadius: 4,
        _useThemeGradient: true
      }]
    },
    plugins: showDataLabels ? [ChartDataLabels] : [],
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: { padding: { top: showDataLabels ? 20 : 0 } },
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: (ctx) => ctx.raw + ' jobs' } },
        datalabels: showDataLabels ? {
          display: true, anchor: 'end', align: 'top', offset: 2,
          font: { weight: 'bold', size: 10 },
          formatter: (val) => val
        } : { display: false }
      },
      scales: {
        x: { ticks: { maxRotation: 45, minRotation: 45 }, grid: { display: false } },
        y: { beginAtZero: true, ticks: { stepSize: 1 } }
      }
    }
  });
}

function renderJoPmContractChart(data, textColor, gridColor, showDataLabels) {
  const ctx = document.getElementById('joPmContractChart');
  if (!ctx) return;
  
  if (joPmContractChart) joPmContractChart.destroy();
  
  const context = ctx.getContext('2d');
  
  joPmContractChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: data.map(d => d.name.length > 12 ? d.name.substring(0, 12) + '...' : d.name),
      datasets: [{
        data: data.map(d => d.contractValue),
        backgroundColor: ChartThemeManager.createGradient(context),
        borderRadius: 4,
        _useThemeGradient: true
      }]
    },
    plugins: showDataLabels ? [ChartDataLabels] : [],
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: { padding: { top: showDataLabels ? 20 : 0 } },
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: (ctx) => '$' + (ctx.raw / 1000000).toFixed(1) + 'M' } },
        datalabels: showDataLabels ? {
          display: true, anchor: 'end', align: 'top', offset: 2,
          font: { weight: 'bold', size: 10 },
          formatter: (val) => '$' + (val / 1000000).toFixed(1) + 'M'
        } : { display: false }
      },
      scales: {
        x: { ticks: { maxRotation: 45, minRotation: 45 }, grid: { display: false } },
        y: { beginAtZero: true, ticks: { callback: (val) => '$' + (val / 1000000).toFixed(1) + 'M' } }
      }
    }
  });
}

function renderJoPmMarginChart(data, textColor, gridColor, showDataLabels) {
  const ctx = document.getElementById('joPmMarginChart');
  if (!ctx) return;
  
  if (joPmMarginChart) joPmMarginChart.destroy();
  
  const filteredData = data.filter(d => d.contractValue > 0 && d.revisedCost > 0);
  const sortedData = [...filteredData].sort((a, b) => b.profitMargin - a.profitMargin);
  const context = ctx.getContext('2d');
  
  joPmMarginChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: sortedData.map(d => d.name.length > 12 ? d.name.substring(0, 12) + '...' : d.name),
      datasets: [{
        data: sortedData.map(d => d.profitMargin),
        backgroundColor: ChartThemeManager.createGradient(context),
        borderRadius: 4,
        _useThemeGradient: true
      }]
    },
    plugins: showDataLabels ? [ChartDataLabels] : [],
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: { padding: { top: showDataLabels ? 20 : 0 } },
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: (ctx) => ctx.raw.toFixed(1) + '%' } },
        datalabels: showDataLabels ? {
          display: true, anchor: 'end', align: 'top', offset: 2,
          font: { weight: 'bold', size: 10 },
          formatter: (val) => val.toFixed(1) + '%'
        } : { display: false }
      },
      scales: {
        x: { ticks: { maxRotation: 45, minRotation: 45 }, grid: { display: false } },
        y: { beginAtZero: true, ticks: { callback: (val) => val + '%' } }
      }
    }
  });
}

function renderJoClientJobsChart(data, textColor, gridColor, showDataLabels) {
  const ctx = document.getElementById('joClientJobsChart');
  if (!ctx) return;
  
  if (joClientJobsChart) joClientJobsChart.destroy();
  
  let sortedData = [...data].sort((a, b) => b.jobCount - a.jobCount);
  
  // Limit to 10 items, with 10th being "All Others"
  if (sortedData.length > 10) {
    const top9 = sortedData.slice(0, 9);
    const others = sortedData.slice(9);
    const othersTotal = others.reduce((sum, d) => sum + d.jobCount, 0);
    const othersContract = others.reduce((sum, d) => sum + d.contractValue, 0);
    const othersCost = others.reduce((sum, d) => sum + d.revisedCost, 0);
    const othersMargin = othersCost > 0 ? ((othersContract - othersCost) / othersContract * 100) : 0;
    top9.push({ name: 'All Others', jobCount: othersTotal, contractValue: othersContract, revisedCost: othersCost, profitMargin: othersMargin });
    sortedData = top9;
  }
  
  const context = ctx.getContext('2d');
  
  joClientJobsChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: sortedData.map(d => d.name.length > 12 ? d.name.substring(0, 12) + '...' : d.name),
      datasets: [{
        data: sortedData.map(d => d.jobCount),
        backgroundColor: ChartThemeManager.createGradient(context),
        borderRadius: 4,
        _useThemeGradient: true
      }]
    },
    plugins: showDataLabels ? [ChartDataLabels] : [],
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: { padding: { top: showDataLabels ? 20 : 0 } },
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: (ctx) => ctx.raw + ' jobs' } },
        datalabels: showDataLabels ? {
          display: true, anchor: 'end', align: 'top', offset: 2,
          font: { weight: 'bold', size: 10 },
          formatter: (val) => val
        } : { display: false }
      },
      scales: {
        x: { ticks: { maxRotation: 45, minRotation: 45 }, grid: { display: false } },
        y: { beginAtZero: true, ticks: { stepSize: 1 } }
      }
    }
  });
}

function renderJoClientContractChart(data, textColor, gridColor, showDataLabels) {
  const ctx = document.getElementById('joClientContractChart');
  if (!ctx) return;
  
  if (joClientContractChart) joClientContractChart.destroy();
  
  let sortedData = [...data].sort((a, b) => b.contractValue - a.contractValue);
  
  if (sortedData.length > 10) {
    const top9 = sortedData.slice(0, 9);
    const others = sortedData.slice(9);
    const othersJobs = others.reduce((sum, d) => sum + d.jobCount, 0);
    const othersContract = others.reduce((sum, d) => sum + d.contractValue, 0);
    const othersCost = others.reduce((sum, d) => sum + d.revisedCost, 0);
    const othersMargin = othersCost > 0 ? ((othersContract - othersCost) / othersContract * 100) : 0;
    top9.push({ name: 'All Others', jobCount: othersJobs, contractValue: othersContract, revisedCost: othersCost, profitMargin: othersMargin });
    sortedData = top9;
  }
  
  const context = ctx.getContext('2d');
  
  joClientContractChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: sortedData.map(d => d.name.length > 12 ? d.name.substring(0, 12) + '...' : d.name),
      datasets: [{
        data: sortedData.map(d => d.contractValue),
        backgroundColor: ChartThemeManager.createGradient(context),
        borderRadius: 4,
        _useThemeGradient: true
      }]
    },
    plugins: showDataLabels ? [ChartDataLabels] : [],
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: { padding: { top: showDataLabels ? 20 : 0 } },
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: (ctx) => '$' + (ctx.raw / 1000000).toFixed(1) + 'M' } },
        datalabels: showDataLabels ? {
          display: true, anchor: 'end', align: 'top', offset: 2,
          font: { weight: 'bold', size: 10 },
          formatter: (val) => '$' + (val / 1000000).toFixed(1) + 'M'
        } : { display: false }
      },
      scales: {
        x: { ticks: { maxRotation: 45, minRotation: 45 }, grid: { display: false } },
        y: { beginAtZero: true, ticks: { callback: (val) => '$' + (val / 1000000).toFixed(1) + 'M' } }
      }
    }
  });
}

function renderJoClientMarginChart(data, textColor, gridColor, showDataLabels) {
  const ctx = document.getElementById('joClientMarginChart');
  if (!ctx) return;
  
  if (joClientMarginChart) joClientMarginChart.destroy();
  
  const filteredData = data.filter(d => d.contractValue > 0 && d.revisedCost > 0);
  let sortedData = [...filteredData].sort((a, b) => b.profitMargin - a.profitMargin);
  
  if (sortedData.length > 10) {
    const top9 = sortedData.slice(0, 9);
    const others = sortedData.slice(9);
    const othersJobs = others.reduce((sum, d) => sum + d.jobCount, 0);
    const othersContract = others.reduce((sum, d) => sum + d.contractValue, 0);
    const othersCost = others.reduce((sum, d) => sum + d.revisedCost, 0);
    const othersMargin = othersContract > 0 ? ((othersContract - othersCost) / othersContract * 100) : 0;
    top9.push({ name: 'All Others', jobCount: othersJobs, contractValue: othersContract, revisedCost: othersCost, profitMargin: othersMargin });
    sortedData = top9;
  }
  
  const context = ctx.getContext('2d');
  
  joClientMarginChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: sortedData.map(d => d.name.length > 12 ? d.name.substring(0, 12) + '...' : d.name),
      datasets: [{
        data: sortedData.map(d => d.profitMargin),
        backgroundColor: ChartThemeManager.createGradient(context),
        borderRadius: 4,
        _useThemeGradient: true
      }]
    },
    plugins: showDataLabels ? [ChartDataLabels] : [],
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: { padding: { top: showDataLabels ? 20 : 0 } },
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: (ctx) => ctx.raw.toFixed(1) + '%' } },
        datalabels: showDataLabels ? {
          display: true, anchor: 'end', align: 'top', offset: 2,
          font: { weight: 'bold', size: 10 },
          formatter: (val) => val.toFixed(1) + '%'
        } : { display: false }
      },
      scales: {
        x: { ticks: { maxRotation: 45, minRotation: 45 }, grid: { display: false } },
        y: { beginAtZero: true, ticks: { callback: (val) => val + '%' } }
      }
    }
  });
}

// ========================================
// JOB ACTUALS MODULE
// ========================================

let jobActualsData = [];
let jobActualsFiltered = [];
let jaCurrentPage = 1;
let jaPageSize = 25;
let jaSortColumn = 'actual_cost';
let jaSortDirection = 'desc';
let jaInitialized = false;
let jaPmDonutChart = null;
let jaCustomerDonutChart = null;
let jobActualsColumnFilters = {};

function initJobActuals() {
  if (jaInitialized && jobActualsData.length > 0) {
    renderJobActualsTable();
    return;
  }
  
  loadJobActualsData();
  setupJobActualsEventListeners();
  initActualsColumnPicker();
  jaInitialized = true;
}

function setupJobActualsEventListeners() {
  document.getElementById('jaStatusActive')?.addEventListener('change', filterJobActuals);
  document.getElementById('jaStatusInactive')?.addEventListener('change', filterJobActuals);
  document.getElementById('jaStatusClosed')?.addEventListener('change', filterJobActuals);
  document.getElementById('jaStatusOverhead')?.addEventListener('change', filterJobActuals);
  document.getElementById('jaPmFilter')?.addEventListener('change', filterJobActuals);
  
  // Individual search inputs with debounce
  let jaSearchTimeout;
  const jaJobNoSearch = document.getElementById('jaJobNoSearch');
  const jaDescriptionSearch = document.getElementById('jaDescriptionSearch');
  const jaClientSearch = document.getElementById('jaClientSearch');
  
  jaJobNoSearch?.addEventListener('input', () => {
    clearTimeout(jaSearchTimeout);
    jaSearchTimeout = setTimeout(filterJobActuals, 300);
  });
  jaDescriptionSearch?.addEventListener('input', () => {
    clearTimeout(jaSearchTimeout);
    jaSearchTimeout = setTimeout(filterJobActuals, 300);
  });
  jaClientSearch?.addEventListener('input', () => {
    clearTimeout(jaSearchTimeout);
    jaSearchTimeout = setTimeout(filterJobActuals, 300);
  });
  
  document.getElementById('jaPrevPage')?.addEventListener('click', () => {
    if (jaCurrentPage > 1) {
      jaCurrentPage--;
      renderJobActualsTable();
    }
  });
  
  document.getElementById('jaNextPage')?.addEventListener('click', () => {
    const totalPages = Math.ceil(jobActualsFiltered.length / jaPageSize);
    if (jaCurrentPage < totalPages) {
      jaCurrentPage++;
      renderJobActualsTable();
    }
  });
  
  document.getElementById('jaPageSize')?.addEventListener('change', (e) => {
    jaPageSize = parseInt(e.target.value);
    jaCurrentPage = 1;
    renderJobActualsTable();
  });
  
  document.querySelectorAll('#jobActualsTable th.ja-sortable').forEach(th => {
    th.addEventListener('click', () => {
      const col = th.dataset.sort;
      if (jaSortColumn === col) {
        jaSortDirection = jaSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        jaSortColumn = col;
        jaSortDirection = 'desc';
      }
      sortJobActuals();
      renderJobActualsTable();
    });
  });
  
  document.querySelectorAll('.ja-quick-sort').forEach(btn => {
    btn.addEventListener('click', () => {
      const sortCol = btn.dataset.sort;
      const sortDir = btn.dataset.dir;
      
      document.querySelectorAll('.ja-quick-sort').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      jaSortColumn = sortCol;
      jaSortDirection = sortDir;
      jaCurrentPage = 1;
      sortJobActuals();
      renderJobActualsTable();
    });
  });
  
  document.querySelectorAll('#jobActuals .breakdown-expand-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const targetId = btn.dataset.target;
      const tableWrapper = document.getElementById(targetId);
      const textSpan = btn.querySelector('.expand-text');
      
      if (tableWrapper) {
        const isCollapsed = tableWrapper.classList.contains('collapsed');
        tableWrapper.classList.toggle('collapsed');
        btn.classList.toggle('expanded');
        
        if (textSpan) {
          textSpan.textContent = isCollapsed ? 'Collapse' : 'Expand';
        }
      }
    });
  });
}

async function loadJobActualsData() {
  const loadingOverlay = document.getElementById('jobActualsLoadingOverlay');
  if (loadingOverlay) loadingOverlay.classList.remove('hidden');
  
  try {
    // Fetch pre-computed job metrics from the canonical metrics API
    const metricsData = await DataCache.getJobsMetrics();
    const jobs = metricsData.jobs || [];
    
    // Map metrics API response to expected format for the page
    jobActualsData = jobs.map(job => ({
      job_no: job.job_no,
      job_description: job.job_description,
      customer_name: job.customer_name,
      project_manager_name: job.project_manager,
      job_status: job.job_status,
      contract: job.contract,
      revised_contract: job.contract,
      revised_cost: job.budget_cost,
      actual_cost: job.actual_cost,
      billed: job.billed,
      billed_revenue: job.billed,
      earned_revenue: job.earned_revenue,
      percent_complete: job.percent_complete,
      backlog: job.backlog,
      over_under: job.over_under_billing,
      over_under_billing: job.over_under_billing,
      profit: job.profit,
      margin: job.margin,
      profit_margin: job.margin,
      has_budget: job.has_budget,
      valid_for_profit: job.valid_for_profit,
      profit_basis: job.profit_basis
    }));
    
    // Initialize column filter dropdowns
    initJobActualsColumnFilters();
    updateJobActualsSortIndicators();
    
    // Build PM tabs
    populateJaPmTabs();
    
    const dataAsOf = document.getElementById('jobActualsDataAsOf');
    if (dataAsOf && metricsData.generated_at) {
      dataAsOf.textContent = new Date(metricsData.generated_at).toLocaleDateString();
    }
    
    filterJobActuals();
  } catch (err) {
    console.error('Error loading job actuals:', err);
    document.getElementById('jobActualsTableBody').innerHTML = 
      '<tr><td colspan="10" class="loading-cell">Error loading job actuals data</td></tr>';
  } finally {
    if (loadingOverlay) loadingOverlay.classList.add('hidden');
  }
}
function initJobActualsColumnFilters() {
  const filterColumns = ['job_no', 'job_description', 'customer_name', 'job_status'];
  
  filterColumns.forEach(col => {
    const dropdown = document.querySelector(`#jobActualsTable .ja-filter-dropdown[data-filter="${col}"]`);
    const filterBtn = document.querySelector(`#jobActualsTable .ja-filter-btn[data-filter="${col}"]`);
    
    if (!dropdown || !filterBtn) return;
    
    // Get all unique values for this column (no limit)
    const allUniqueVals = [...new Set(jobActualsData.map(job => {
      if (col === 'job_status') return getJobStatusLabel(job[col]).label;
      return String(job[col] || '');
    }))].filter(Boolean).sort();
    
    // Build dropdown HTML
    dropdown.innerHTML = `
      <input type="text" class="filter-search-input ja-filter-search" placeholder="Search..." data-filter="${col}">
      <div class="filter-quick-links">
        <span class="filter-quick-link" data-action="select-all">Select All</span>
        <span class="filter-quick-link" data-action="clear-all">Clear All</span>
      </div>
      <div class="filter-options-list ja-filter-options" data-filter="${col}"></div>
      <div class="filter-actions">
        <button class="filter-ok-btn" data-filter="${col}">OK</button>
        <button class="filter-cancel-btn" data-filter="${col}">Cancel</button>
      </div>
    `;
    
    function renderFilteredOptions(searchTerm = '') {
      const optionsList = dropdown.querySelector('.filter-options-list');
      if (!optionsList) return;
      
      const searchVal = searchTerm.toLowerCase();
      const filteredValues = searchVal
        ? allUniqueVals.filter(val => String(val).toLowerCase().includes(searchVal))
        : allUniqueVals;
      
      const displayValues = filteredValues.slice(0, 200);
      const remaining = filteredValues.length - displayValues.length;
      
      optionsList.innerHTML = displayValues.map(val => `
        <label class="filter-option">
          <input type="checkbox" value="${val.replace(/"/g, '&quot;')}" checked>
          <span class="filter-option-text">${val}</span>
        </label>
      `).join('') + (remaining > 0 ? `<div class="filter-truncated-notice">${remaining} more values not shown. Use search to narrow down.</div>` : '');
    }
    
    renderFilteredOptions();
    
    // Filter button click handler
    filterBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      document.querySelectorAll('.ja-filter-dropdown.open').forEach(d => {
        if (d !== dropdown) {
          d.classList.remove('open');
          d.style.position = '';
          d.style.top = '';
          d.style.left = '';
        }
      });
      dropdown.classList.toggle('open');
      if (dropdown.classList.contains('open')) {
        positionFilterDropdown(filterBtn, dropdown);
      }
    });
    
    // Search within filter - now re-renders with filtered values
    const searchInput = dropdown.querySelector('.ja-filter-search');
    searchInput?.addEventListener('input', (e) => {
      renderFilteredOptions(e.target.value);
    });
    
    // Select All link
    dropdown.querySelector('.filter-quick-link[data-action="select-all"]')?.addEventListener('click', (e) => {
      e.stopPropagation();
      dropdown.querySelectorAll('.filter-option input[type="checkbox"]').forEach(cb => cb.checked = true);
    });
    
    // Clear All link
    dropdown.querySelector('.filter-quick-link[data-action="clear-all"]')?.addEventListener('click', (e) => {
      e.stopPropagation();
      dropdown.querySelectorAll('.filter-option input[type="checkbox"]').forEach(cb => cb.checked = false);
    });
    
    // OK button
    dropdown.querySelector('.filter-ok-btn')?.addEventListener('click', (e) => {
      e.stopPropagation();
      const checkedValues = new Set();
      dropdown.querySelectorAll('.filter-option input[type="checkbox"]:checked').forEach(cb => {
        checkedValues.add(cb.value);
      });
      
      const allCheckboxes = dropdown.querySelectorAll('.filter-option input[type="checkbox"]');
      if (checkedValues.size === allCheckboxes.length || checkedValues.size === 0) {
        delete jobActualsColumnFilters[col];
        filterBtn.classList.remove('has-filter');
      } else {
        jobActualsColumnFilters[col] = checkedValues;
        filterBtn.classList.add('has-filter');
      }
      
      dropdown.classList.remove('open');
      filterJobActuals();
    });
    
    // Cancel button
    dropdown.querySelector('.filter-cancel-btn')?.addEventListener('click', (e) => {
      e.stopPropagation();
      dropdown.classList.remove('open');
    });
  });
  
  // Sort buttons
  document.querySelectorAll('#jobActualsTable .ja-sort-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const sortCol = btn.dataset.sort;
      const sortDir = btn.dataset.dir;
      
      jaSortColumn = sortCol;
      jaSortDirection = sortDir;
      jaCurrentPage = 1;
      updateJobActualsSortIndicators();
      sortJobActuals();
      renderJobActualsTable();
    });
  });
  
  // Close dropdowns when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.ja-filter-dropdown') && !e.target.closest('.ja-filter-btn')) {
      document.querySelectorAll('.ja-filter-dropdown.open').forEach(d => d.classList.remove('open'));
    }
  });
}

function updateJobActualsSortIndicators() {
  document.querySelectorAll('#jobActualsTable .ja-sort-btn').forEach(btn => {
    btn.classList.remove('active');
    if (btn.dataset.sort === jaSortColumn && btn.dataset.dir === jaSortDirection) {
      btn.classList.add('active');
    }
  });
}

function filterJobActuals() {
  const showActive = document.getElementById('jaStatusActive')?.checked;
  const showInactive = document.getElementById('jaStatusInactive')?.checked;
  const showClosed = document.getElementById('jaStatusClosed')?.checked;
  const showOverhead = document.getElementById('jaStatusOverhead')?.checked;
  
  // Get PM from tabs instead of dropdown
  const pmFilter = getSelectedPmForPage('ja');
  
  const jobNoSearch = (document.getElementById('jaJobNoSearch')?.value || '').toLowerCase().trim();
  const descriptionSearch = (document.getElementById('jaDescriptionSearch')?.value || '').toLowerCase().trim();
  const clientSearch = (document.getElementById('jaClientSearch')?.value || '').toLowerCase().trim();
  
  const allowedStatuses = [];
  if (showActive) allowedStatuses.push('A');
  if (showInactive) allowedStatuses.push('I');
  if (showClosed) allowedStatuses.push('C');
  if (showOverhead) allowedStatuses.push('O');
  
  jobActualsFiltered = jobActualsData.filter(job => {
    // Status filter from tabs
    if (allowedStatuses.length > 0 && !allowedStatuses.includes(job.job_status)) return false;
    
    // PM filter from tabs
    if (pmFilter && job.project_manager_name !== pmFilter) return false;
    
    // Individual search filters
    if (jobNoSearch && !(job.job_no || '').toLowerCase().includes(jobNoSearch)) return false;
    if (descriptionSearch && !(job.job_description || '').toLowerCase().includes(descriptionSearch)) return false;
    if (clientSearch && !(job.customer_name || '').toLowerCase().includes(clientSearch)) return false;
    
    // Column filters (multi-select)
    for (const [col, allowedValues] of Object.entries(jobActualsColumnFilters)) {
      if (allowedValues && allowedValues.size > 0) {
        let jobVal = job[col];
        if (col === 'job_status') {
          jobVal = getJobStatusLabel(jobVal).label;
        }
        jobVal = String(jobVal || '');
        if (!allowedValues.has(jobVal)) return false;
      }
    }
    
    return true;
  });
  
  jaCurrentPage = 1;
  sortJobActuals();
  updateJobActualsSummaryMetrics();
  renderJobActualsTable();
}

function sortJobActuals() {
  const col = jaSortColumn;
  const dir = jaSortDirection === 'asc' ? 1 : -1;
  
  jobActualsFiltered.sort((a, b) => {
    let aVal = a[col];
    let bVal = b[col];
    
    if (['billed_revenue', 'earned_revenue', 'actual_cost', 'percent_complete'].includes(col)) {
      return ((aVal || 0) - (bVal || 0)) * dir;
    }
    
    if (col === 'over_under_bill') {
      const aOver = (a.billed_revenue || 0) - (a.earned_revenue || 0);
      const bOver = (b.billed_revenue || 0) - (b.earned_revenue || 0);
      return (aOver - bOver) * dir;
    }
    
    aVal = (aVal || '').toString().toLowerCase();
    bVal = (bVal || '').toString().toLowerCase();
    return aVal.localeCompare(bVal) * dir;
  });
}

function updateJobActualsSummaryMetrics() {
  // Use filtered data based on PM tabs and status checkboxes
  const jobs = jobActualsFiltered || [];
  const totalJobs = jobs.length;
  const totalActualCost = jobs.reduce((sum, j) => sum + (j.actual_cost || 0), 0);
  
  // For Over/Under calculation, only include jobs with valid budget data (contract > 0 and cost > 0)
  // This matches the Over/Under Billing page logic for consistency
  const jobsWithValidBudget = jobs.filter(j => (j.revised_contract || 0) > 0 && (j.revised_cost || 0) > 0);
  const totalBilledRevenue = jobsWithValidBudget.reduce((sum, j) => sum + (j.billed_revenue || 0), 0);
  const totalEarnedRevenue = jobsWithValidBudget.reduce((sum, j) => sum + (j.earned_revenue || 0), 0);
  const totalOverUnder = totalBilledRevenue - totalEarnedRevenue;
  
  document.getElementById('jaTotalCount').textContent = totalJobs.toLocaleString();
  document.getElementById('jaTotalBilledRevenue').textContent = formatCurrencyCompact(totalBilledRevenue);
  document.getElementById('jaTotalEarnedRevenue').textContent = formatCurrencyCompact(totalEarnedRevenue);
  document.getElementById('jaTotalActualCost').textContent = formatCurrencyCompact(totalActualCost);
  const overUnderEl = document.getElementById('jaTotalOverUnder');
  overUnderEl.textContent = formatCurrencyCompact(totalOverUnder);
  overUnderEl.style.color = totalOverUnder >= 0 ? '#10b981' : '#dc2626';
  
  const overUnderCard = document.getElementById('jaOverUnderCard');
  if (overUnderCard) {
    overUnderCard.style.backgroundColor = totalOverUnder >= 0 ? '#d1fae5' : '#fce7f3';
  }
  
  renderJobActualsBreakdowns();
}

function renderJobActualsBreakdowns() {
  // Donut charts removed per user request
}

async function populateJaPmTabs() {
  // Build PM tabs using async loader to ensure PMs are available
  await loadAndBuildPmTabs('jaPmTabs', 'ja', () => {
    filterJobActuals();
  });
}

function renderJaPmDonutChart() {
  const canvas = document.getElementById('jaPmDonutChart');
  if (!canvas) return;
  
  const pmMap = new Map();
  jobActualsFiltered.forEach(job => {
    const pm = job.project_manager_name || 'Unassigned';
    if (!pmMap.has(pm)) pmMap.set(pm, 0);
    pmMap.set(pm, pmMap.get(pm) + job.actual_cost);
  });
  
  const sorted = [...pmMap.entries()].sort((a, b) => b[1] - a[1]);
  const top10 = sorted.slice(0, 10);
  const otherTotal = sorted.slice(10).reduce((sum, [, val]) => sum + val, 0);
  
  const labels = top10.map(([name]) => name);
  const data = top10.map(([, val]) => val);
  
  if (otherTotal > 0) {
    labels.push('Other');
    data.push(otherTotal);
  }
  
  const isDarkMode = document.documentElement.getAttribute("data-theme") === "dark" || document.body.classList.contains('dark-mode');
  const isMobile = window.innerWidth <= 768;
  
  if (jaPmDonutChart) jaPmDonutChart.destroy();
  
  jaPmDonutChart = new Chart(canvas, {
    type: 'doughnut',
    data: {
      labels: labels,
      datasets: [{
        data: data,
        backgroundColor: chartColors.slice(0, labels.length),
        borderWidth: 2,
        borderColor: isDarkMode ? '#1e293b' : '#ffffff'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'bottom',
          align: 'center',
          labels: {
            color: isDarkMode ? '#e2e8f0' : '#374151',
            font: { size: 11 },
            boxWidth: 12,
            padding: 8,
            usePointStyle: true,
            pointStyle: 'rect'
          }
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              const value = context.raw;
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const pct = ((value / total) * 100).toFixed(1);
              return `${formatCurrencyCompact(value)} (${pct}%)`;
            }
          }
        }
      }
    }
  });
}

function renderJaCustomerDonutChart() {
  const canvas = document.getElementById('jaCustomerDonutChart');
  if (!canvas) return;
  
  const custMap = new Map();
  jobActualsFiltered.forEach(job => {
    const cust = job.customer_name || 'Unknown';
    if (!custMap.has(cust)) custMap.set(cust, 0);
    custMap.set(cust, custMap.get(cust) + job.actual_cost);
  });
  
  const sorted = [...custMap.entries()].sort((a, b) => b[1] - a[1]);
  const top10 = sorted.slice(0, 10);
  const otherTotal = sorted.slice(10).reduce((sum, [, val]) => sum + val, 0);
  
  const labels = top10.map(([name]) => name);
  const data = top10.map(([, val]) => val);
  
  if (otherTotal > 0) {
    labels.push('Other');
    data.push(otherTotal);
  }
  
  const isDarkMode = document.documentElement.getAttribute("data-theme") === "dark" || document.body.classList.contains('dark-mode');
  const isMobile = window.innerWidth <= 768;
  
  if (jaCustomerDonutChart) jaCustomerDonutChart.destroy();
  
  jaCustomerDonutChart = new Chart(canvas, {
    type: 'doughnut',
    data: {
      labels: labels,
      datasets: [{
        data: data,
        backgroundColor: chartColors.slice(0, labels.length),
        borderWidth: 2,
        borderColor: isDarkMode ? '#1e293b' : '#ffffff'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'bottom',
          align: 'center',
          labels: {
            color: isDarkMode ? '#e2e8f0' : '#374151',
            font: { size: 11 },
            boxWidth: 12,
            padding: 8,
            usePointStyle: true,
            pointStyle: 'rect'
          }
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              const value = context.raw;
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const pct = ((value / total) * 100).toFixed(1);
              return `${formatCurrencyCompact(value)} (${pct}%)`;
            }
          }
        }
      }
    }
  });
}

function renderJaPmBreakdownTable() {
  const tbody = document.getElementById('jaPmBreakdownBody');
  if (!tbody) return;
  
  const pmMap = new Map();
  jobActualsFiltered.forEach(job => {
    const pm = job.project_manager_name || 'Unassigned';
    if (!pmMap.has(pm)) {
      pmMap.set(pm, { jobs: 0, earnedRev: 0, actualCost: 0 });
    }
    const d = pmMap.get(pm);
    d.jobs++;
    d.earnedRev += job.earned_revenue;
    d.actualCost += job.actual_cost;
  });
  
  const sorted = [...pmMap.entries()]
    .map(([pm, d]) => ({ pm, ...d, profit: d.earnedRev - d.actualCost }))
    .sort((a, b) => b.actualCost - a.actualCost);
  
  tbody.innerHTML = sorted.map(row => {
    const margin = row.earnedRev > 0 ? (row.profit / row.earnedRev) * 100 : 0;
    const marginColor = getMarginColor(margin);
    const profitClass = row.profit >= 0 ? 'positive' : 'negative';
    return `<tr>
      <td>${row.pm}</td>
      <td class="number-col">${row.jobs}</td>
      <td class="number-col">${formatCurrency(row.earnedRev)}</td>
      <td class="number-col">${formatCurrency(row.actualCost)}</td>
      <td class="number-col ${profitClass}">${formatCurrency(row.profit)}</td>
      <td class="number-col" style="background-color: ${marginColor}">${margin.toFixed(1)}%</td>
    </tr>`;
  }).join('');
}

function renderJaCustomerBreakdownTable() {
  const tbody = document.getElementById('jaCustomerBreakdownBody');
  if (!tbody) return;
  
  const custMap = new Map();
  jobActualsFiltered.forEach(job => {
    const cust = job.customer_name || 'Unknown';
    if (!custMap.has(cust)) {
      custMap.set(cust, { jobs: 0, earnedRev: 0, actualCost: 0 });
    }
    const d = custMap.get(cust);
    d.jobs++;
    d.earnedRev += job.earned_revenue;
    d.actualCost += job.actual_cost;
  });
  
  const sorted = [...custMap.entries()]
    .map(([cust, d]) => ({ cust, ...d, profit: d.earnedRev - d.actualCost }))
    .sort((a, b) => b.actualCost - a.actualCost);
  
  tbody.innerHTML = sorted.map(row => {
    const margin = row.earnedRev > 0 ? (row.profit / row.earnedRev) * 100 : 0;
    const marginColor = getMarginColor(margin);
    const profitClass = row.profit >= 0 ? 'positive' : 'negative';
    return `<tr>
      <td>${row.cust}</td>
      <td class="number-col">${row.jobs}</td>
      <td class="number-col">${formatCurrency(row.earnedRev)}</td>
      <td class="number-col">${formatCurrency(row.actualCost)}</td>
      <td class="number-col ${profitClass}">${formatCurrency(row.profit)}</td>
      <td class="number-col" style="background-color: ${marginColor}">${margin.toFixed(1)}%</td>
    </tr>`;
  }).join('');
}

function renderJobActualsTable() {
  const tbody = document.getElementById('jobActualsTableBody');
  if (!tbody) return;
  
  const startIdx = (jaCurrentPage - 1) * jaPageSize;
  const endIdx = startIdx + jaPageSize;
  const pageData = jobActualsFiltered.slice(startIdx, endIdx);
  
  if (pageData.length === 0) {
    tbody.innerHTML = '<tr><td colspan="12" class="loading-cell">No jobs found matching filters</td></tr>';
    updateJaPagination(0);
    return;
  }
  
  // Calculate totals for ALL filtered data (not just current page)
  // Over/Under uses only ACTIVE jobs with budgets (matches Over/Under Billing page)
  const activeJobsWithBudget = jobActualsFiltered.filter(j => j.has_budget && j.job_status === 'A');
  const jobsValidForProfit = jobActualsFiltered.filter(j => j.valid_for_profit);
  
  const allTotals = {
    billedRevenue: jobActualsFiltered.reduce((sum, j) => sum + (j.billed_revenue || 0), 0),
    earnedRevenue: activeJobsWithBudget.reduce((sum, j) => sum + (j.earned_revenue || 0), 0),
    actualCost: jobActualsFiltered.reduce((sum, j) => sum + (j.actual_cost || 0), 0),
    overUnder: activeJobsWithBudget.reduce((sum, j) => sum + (j.over_under_billing || 0), 0),
    profit: jobsValidForProfit.reduce((sum, j) => sum + (j.profit || 0), 0)
  };
  const totalOverUnderTextColor = allTotals.overUnder >= 0 ? '#10b981' : '#ef4444';
  const totalProfitTextColor = allTotals.profit >= 0 ? '#10b981' : '#ef4444';
  const avgPctComplete = activeJobsWithBudget.length > 0 
    ? activeJobsWithBudget.reduce((sum, j) => sum + (j.percent_complete || 0), 0) / activeJobsWithBudget.length 
    : 0;
  // Weighted margin: total profit / total revenue (using profit_basis revenue)
  const totalProfitRevenue = jobsValidForProfit.reduce((sum, j) => {
    const rev = j.profit_basis === 'actual' ? (j.billed_revenue || 0) : (j.contract || 0);
    return sum + rev;
  }, 0);
  const weightedMargin = totalProfitRevenue > 0 ? (allTotals.profit / totalProfitRevenue) * 100 : 0;
  
  const totalsRowHtml = `<tr class="totals-row">
    <td colspan="5"><strong>Totals (${jobActualsFiltered.length} jobs)</strong></td>
    <td class="number-col"><strong>${formatCurrency(allTotals.billedRevenue)}</strong></td>
    <td class="number-col"><strong>${formatCurrency(allTotals.earnedRevenue)}</strong></td>
    <td class="number-col" style="color: ${totalOverUnderTextColor};"><strong>${formatCurrency(allTotals.overUnder)}</strong></td>
    <td class="number-col"><strong>${formatCurrency(allTotals.actualCost)}</strong></td>
    <td class="number-col"><strong>${Math.round(avgPctComplete)}%</strong></td>
    <td class="number-col" style="color: ${totalProfitTextColor};"><strong>${formatCurrency(allTotals.profit)}</strong></td>
    <td class="number-col"><strong>${weightedMargin.toFixed(1)}%</strong></td>
  </tr>`;
  
  const dataRowsHtml = pageData.map(job => {
    const status = getJobStatusLabel(job.job_status);
    const pctComplete = job.percent_complete || 0;
    const overUnderBill = job.over_under_billing || 0;
    const overUnderTextColor = overUnderBill >= 0 ? '#10b981' : '#ef4444';
    const profit = job.profit || 0;
    const profitTextColor = profit >= 0 ? '#10b981' : '#ef4444';
    const margin = job.margin || 0;
    
    return `<tr>
      <td>${job.job_no}</td>
      <td>${job.job_description || ''}</td>
      <td>${job.customer_name || ''}</td>
      <td><span class="job-status-badge ${status.class}">${status.label}</span></td>
      <td>${job.project_manager_name || ''}</td>
      <td class="number-col">${formatCurrency(job.billed_revenue || 0)}</td>
      <td class="number-col">${formatCurrency(job.earned_revenue || 0)}</td>
      <td class="number-col" style="color: ${overUnderTextColor};">${formatCurrency(overUnderBill)}</td>
      <td class="number-col">${formatCurrency(job.actual_cost || 0)}</td>
      <td class="number-col">${Math.round(pctComplete)}%</td>
      <td class="number-col" style="color: ${profitTextColor};">${formatCurrency(profit)}</td>
      <td class="number-col">${margin.toFixed(1)}%</td>
    </tr>`;
  }).join('');
  
  tbody.innerHTML = totalsRowHtml + dataRowsHtml;
  
  updateJaPagination(jobActualsFiltered.length);
  
  // Apply column visibility
  if (typeof applyActualsColumnVisibility === 'function') {
    applyActualsColumnVisibility();
  }
}

function updateJaPagination(total) {
  const totalPages = Math.max(1, Math.ceil(total / jaPageSize));
  
  document.getElementById('jaPageInfo').textContent = `Page ${jaCurrentPage} of ${totalPages}`;
  document.getElementById('jaPrevPage').disabled = jaCurrentPage <= 1;
  document.getElementById('jaNextPage').disabled = jaCurrentPage >= totalPages;
}

// ========================================
// JOB COSTS MODULE
// ========================================

let jobCostsData = [];
let jobCostsFiltered = [];
let jcCurrentPage = 1;
let jcPageSize = 25;
let jcSortColumn = 'job_no';
let jcSortDirection = 'asc';
let jcEventListenersSetup = false;

function initJobCosts() {
  if (!jcEventListenersSetup) {
    setupJobCostsEventListeners();
    jcEventListenersSetup = true;
  }
  loadJobCostsData();
}

function setupJobCostsEventListeners() {
  // Status checkboxes
  document.getElementById('ccStatusActive')?.addEventListener('change', filterCostCodes);
  document.getElementById('ccStatusInactive')?.addEventListener('change', filterCostCodes);
  document.getElementById('ccStatusClosed')?.addEventListener('change', filterCostCodes);
  document.getElementById('ccStatusOverhead')?.addEventListener('change', filterCostCodes);
  
  // Search inputs
  document.getElementById('ccJobSearchBar')?.addEventListener('input', filterCostCodes);
  document.getElementById('ccClientSearchBar')?.addEventListener('input', filterCostCodes);
  
  document.querySelectorAll('.jc-sortable').forEach(th => {
    th.addEventListener('click', () => {
      const col = th.dataset.sort;
      if (jcSortColumn === col) {
        jcSortDirection = jcSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        jcSortColumn = col;
        jcSortDirection = 'asc';
      }
      sortJobCosts();
      renderJobCostsTable();
    });
  });
  
  document.getElementById('jcPrevPage')?.addEventListener('click', () => {
    if (jcCurrentPage > 1) {
      jcCurrentPage--;
      renderJobCostsTable();
    }
  });
  
  document.getElementById('jcNextPage')?.addEventListener('click', () => {
    const totalPages = Math.ceil(jobCostsFiltered.length / jcPageSize);
    if (jcCurrentPage < totalPages) {
      jcCurrentPage++;
      renderJobCostsTable();
    }
  });
  
  document.getElementById('jcPageSize')?.addEventListener('change', (e) => {
    jcPageSize = parseInt(e.target.value);
    jcCurrentPage = 1;
    renderJobCostsTable();
  });
}

// EXCEPTION: Uses raw DataCache.getJobsData() - needs job_actuals line items with cost code detail
// Cannot use metrics API as it only provides job-level aggregates, not individual cost code breakdown
async function loadJobCostsData() {
  const loadingOverlay = document.getElementById('jobCostsLoadingOverlay');
  if (loadingOverlay) loadingOverlay.classList.remove('hidden');
  
  try {
    const data = await DataCache.getJobsData();
    
    const jobBudgets = data.job_budgets || [];
    const jobActualsRaw = data.job_actuals || [];
    
    const budgetMap = new Map();
    jobBudgets.forEach(job => {
      const originalCost = parseFloat(job.original_cost) || 0;
      const costAdjustments = parseFloat(job.cost_adjustments) || 0;
      budgetMap.set(job.job_no, {
        customer_name: job.customer_name,
        project_manager_name: job.project_manager_name,
        job_status: job.job_status,
        job_description: job.job_description,
        estimated_cost: originalCost + costAdjustments
      });
    });
    
    jobCostsData = jobActualsRaw.map(row => {
      const budget = budgetMap.get(row.job_no) || {};
      return {
        job_no: row.job_no,
        job_status: row.job_status || budget.job_status,
        job_description: row.job_description || budget.job_description,
        project_manager_name: row.project_manager_name || budget.project_manager_name,
        customer_name: budget.customer_name || '',
        cost_code_no: row.cost_code_no || '',
        cost_code_description: row.cost_code_description || '',
        estimated_cost: budget.estimated_cost || 0,
        actual_cost: parseFloat(row.actual_cost) || 0
      };
    });
    
    populateCostCodesTabs();
    
    const dataAsOf = document.getElementById('costCodesDataAsOf');
    if (dataAsOf && metricsData.generated_at) {
      dataAsOf.textContent = new Date(metricsData.generated_at).toLocaleDateString();
    }
    
    filterCostCodes();
  } catch (err) {
    console.error('Error loading job costs:', err);
    document.getElementById('jobCostsTableBody').innerHTML = 
      '<tr><td colspan="6" class="loading-cell">Error loading job costs data</td></tr>';
  } finally {
    if (loadingOverlay) loadingOverlay.classList.add('hidden');
  }
}

async function populateCostCodesTabs() {
  // Build PM tabs using async loader to ensure PMs are available
  await loadAndBuildPmTabs('ccPmTabs', 'cc', () => {
    filterCostCodes();
  });
}

function filterCostCodes() {
  const showActive = document.getElementById('ccStatusActive')?.checked;
  const showInactive = document.getElementById('ccStatusInactive')?.checked;
  const showClosed = document.getElementById('ccStatusClosed')?.checked;
  const showOverhead = document.getElementById('ccStatusOverhead')?.checked;
  
  // Get PM from tabs instead of dropdown
  const pmFilter = getSelectedPmForPage('cc');
  const searchTerm = (document.getElementById('ccJobSearchBar')?.value || '').toLowerCase().trim();
  const clientSearch = (document.getElementById('ccClientSearchBar')?.value || '').toLowerCase().trim();
  
  const allowedStatuses = [];
  if (showActive) allowedStatuses.push('A');
  if (showInactive) allowedStatuses.push('I');
  if (showClosed) allowedStatuses.push('C');
  if (showOverhead) allowedStatuses.push('O');
  
  jobCostsFiltered = jobCostsData.filter(row => {
    if (allowedStatuses.length > 0 && !allowedStatuses.includes(row.job_status)) return false;
    if (pmFilter && row.project_manager_name !== pmFilter) return false;
    
    if (clientSearch) {
      const customerName = (row.customer_name || '').toLowerCase();
      if (!customerName.includes(clientSearch)) return false;
    }
    
    if (searchTerm) {
      const searchStr = `${row.job_no} ${row.job_description} ${row.cost_code_no} ${row.cost_code_description}`.toLowerCase();
      if (!searchStr.includes(searchTerm)) return false;
    }
    
    return true;
  });
  
  jcCurrentPage = 1;
  sortJobCosts();
  renderJobCostsTable();
}

function sortJobCosts() {
  const col = jcSortColumn;
  const dir = jcSortDirection === 'asc' ? 1 : -1;
  
  jobCostsFiltered.sort((a, b) => {
    let aVal = a[col];
    let bVal = b[col];
    
    if (['estimated_cost', 'actual_cost'].includes(col)) {
      return ((aVal || 0) - (bVal || 0)) * dir;
    }
    
    aVal = (aVal || '').toString().toLowerCase();
    bVal = (bVal || '').toString().toLowerCase();
    return aVal.localeCompare(bVal) * dir;
  });
}

function renderJobCostsTable() {
  const tbody = document.getElementById('jobCostsTableBody');
  if (!tbody) return;
  
  const startIdx = (jcCurrentPage - 1) * jcPageSize;
  const endIdx = startIdx + jcPageSize;
  const pageData = jobCostsFiltered.slice(startIdx, endIdx);
  
  if (pageData.length === 0) {
    tbody.innerHTML = '<tr><td colspan="6" class="loading-cell">No costs found matching filters</td></tr>';
    updateJcPagination(0);
    return;
  }
  
  tbody.innerHTML = pageData.map(row => {
    return `<tr>
      <td>${row.job_no}</td>
      <td>${row.job_description || ''}</td>
      <td>${row.cost_code_no || ''}</td>
      <td>${row.cost_code_description || ''}</td>
      <td class="number-col">${formatCurrency(row.estimated_cost)}</td>
      <td class="number-col">${formatCurrency(row.actual_cost)}</td>
    </tr>`;
  }).join('');
  
  updateJcPagination(jobCostsFiltered.length);
}

function updateJcPagination(total) {
  const totalPages = Math.max(1, Math.ceil(total / jcPageSize));
  
  document.getElementById('jcPageInfo').textContent = `Page ${jcCurrentPage} of ${totalPages}`;
  document.getElementById('jcPrevPage').disabled = jcCurrentPage <= 1;
  document.getElementById('jcNextPage').disabled = jcCurrentPage >= totalPages;
}

// ========================================
// MISSING BUDGETS MODULE
// ========================================

let missingBudgetsFiltered = [];
let mbCurrentPage = 1;
let mbPageSize = 25;
let mbSortColumn = 'job_no';
let mbSortDirection = 'asc';
let mbActiveTab = 'noContract';
let mbEventListenersSetup = false;

function initMissingBudgets() {
  // Setup event listeners (only once)
  if (!mbEventListenersSetup) {
    setupMissingBudgetsEventListeners();
    mbEventListenersSetup = true;
  }
  
  // Load data exactly like Job Budgets does
  loadMissingBudgetsData();
}

async function loadMissingBudgetsData() {
  const tbody = document.getElementById('missingBudgetsTableBody');
  if (tbody) tbody.innerHTML = '<tr><td colspan="11" class="loading-cell">Loading job data...</td></tr>';
  
  try {
    // Fetch pre-computed job metrics from the canonical metrics API
    const metricsData = await DataCache.getJobsMetrics();
    const jobs = metricsData.jobs || [];
    
    // Map metrics API response to expected format
    jobBudgetsData = jobs.map(job => ({
      job_no: job.job_no,
      job_description: job.job_description,
      customer_name: job.customer_name,
      project_manager_name: job.project_manager,
      job_status: job.job_status,
      original_contract: job.original_contract || 0,
      tot_income_adj: job.tot_income_adj || 0,
      contract: job.contract,
      revised_contract: job.contract,
      original_cost: job.original_cost || 0,
      tot_cost_adj: job.tot_cost_adj || 0,
      revised_cost: job.budget_cost,
      profit: job.profit,
      margin: job.margin,
    }));
    
    populateMbFilters();
    
    const dateEl = document.getElementById("missingBudgetsDataAsOf");
    if (dateEl && metricsData.generated_at) {
      dateEl.textContent = new Date(metricsData.generated_at).toLocaleDateString();
    }
    
    filterMissingBudgets();
    
  } catch (err) {
    console.error('Error loading missing budgets:', err);
    if (tbody) tbody.innerHTML = '<tr><td colspan="11" class="loading-cell">Error loading data</td></tr>';
  }
}

function populateMbFilters() {
  // Only show PMs with active jobs
  const activePms = getActivePmsFromData(jobBudgetsData);
  const customers = [...new Set(jobBudgetsData.map(j => j.customer_name).filter(Boolean))].sort();
  
  const pmSelect = document.getElementById('mbPmFilter');
  if (pmSelect && pmSelect.options.length <= 1) {
    pmSelect.innerHTML = '<option value="">All Project Managers</option>' + 
      activePms.map(pm => `<option value="${pm}">${pm}</option>`).join('');
    
    // Apply My PM View filter if enabled (sync, after options exist)
    if (getMyPmViewEnabled() && isUserProjectManager()) {
      const pmName = getCurrentUserPmName();
      const option = Array.from(pmSelect.options).find(opt => opt.value === pmName);
      if (option) pmSelect.value = option.value;
    }
  }
  
  const custSelect = document.getElementById('mbCustomerFilter');
  if (custSelect && custSelect.options.length <= 1) {
    custSelect.innerHTML = '<option value="">All Clients</option>' + 
      customers.map(c => `<option value="${c}">${c}</option>`).join('');
  }
}

function setupMissingBudgetsEventListeners() {
  // Tab switching
  document.querySelectorAll('.mb-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.mb-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      mbActiveTab = tab.dataset.tab;
      mbCurrentPage = 1;
      filterMissingBudgets();
    });
  });
  
  // Status checkboxes
  ['mbStatusActive', 'mbStatusInactive', 'mbStatusClosed', 'mbStatusOverhead'].forEach(id => {
    document.getElementById(id)?.addEventListener('change', () => {
      mbCurrentPage = 1;
      filterMissingBudgets();
    });
  });
  
  // PM/Customer filters
  document.getElementById('mbPmFilter')?.addEventListener('change', () => {
    mbCurrentPage = 1;
    filterMissingBudgets();
  });
  document.getElementById('mbCustomerFilter')?.addEventListener('change', () => {
    mbCurrentPage = 1;
    filterMissingBudgets();
  });
  
  // Search
  document.getElementById('mbSearchInput')?.addEventListener('input', () => {
    mbCurrentPage = 1;
    filterMissingBudgets();
  });
  
  // Pagination
  document.getElementById('mbPrevPage')?.addEventListener('click', () => {
    if (mbCurrentPage > 1) {
      mbCurrentPage--;
      renderMissingBudgetsTable();
    }
  });
  
  document.getElementById('mbNextPage')?.addEventListener('click', () => {
    const totalPages = Math.ceil(missingBudgetsFiltered.length / mbPageSize);
    if (mbCurrentPage < totalPages) {
      mbCurrentPage++;
      renderMissingBudgetsTable();
    }
  });
  
  document.getElementById('mbPageSize')?.addEventListener('change', (e) => {
    mbPageSize = parseInt(e.target.value);
    mbCurrentPage = 1;
    renderMissingBudgetsTable();
  });
  
  // Sortable headers
  document.querySelectorAll('#missingBudgetsTable .sortable').forEach(th => {
    th.addEventListener('click', (e) => {
      if (e.target.classList.contains('expand-icon')) return;
      const col = th.dataset.sort;
      if (mbSortColumn === col) {
        mbSortDirection = mbSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        mbSortColumn = col;
        mbSortDirection = 'asc';
      }
      sortMissingBudgets();
    });
  });
  
  // Expandable column toggles for Missing Budgets table
  document.querySelectorAll('#missingBudgetsTable .expand-icon').forEach(icon => {
    icon.addEventListener('click', (e) => {
      e.stopPropagation();
      const type = icon.dataset.expand;
      const detailClass = type === 'mb-contract' ? 'contract-detail-col' : 'cost-detail-col';
      
      icon.classList.toggle('expanded');
      
      // Toggle visibility of detail columns in Missing Budgets table only
      document.querySelectorAll(`#missingBudgetsTable .${detailClass}`).forEach(el => {
        el.classList.toggle('hidden');
      });
    });
  });
}

function filterMissingBudgets() {
  const statusActive = document.getElementById('mbStatusActive')?.checked;
  const statusInactive = document.getElementById('mbStatusInactive')?.checked;
  const statusClosed = document.getElementById('mbStatusClosed')?.checked;
  const statusOverhead = document.getElementById('mbStatusOverhead')?.checked;
  
  const pmFilter = document.getElementById('mbPmFilter')?.value || '';
  const custFilter = document.getElementById('mbCustomerFilter')?.value || '';
  const search = (document.getElementById('mbSearchInput')?.value || '').toLowerCase();
  
  // Use shared jobBudgetsData from Job Budgets module
  missingBudgetsFiltered = jobBudgetsData.filter(job => {
    // Filter by tab - check if BOTH component values are zero (handle string values)
    if (mbActiveTab === 'noContract') {
      // No Contract Value: Original Contract = 0 AND Change Orders = 0
      const origContract = parseFloat(job.original_contract) || 0;
      const changeOrders = parseFloat(job.tot_income_adj) || 0;
      if (origContract !== 0 || changeOrders !== 0) return false;
    } else {
      // No Estimated Cost: Original Cost = 0 AND Cost Adjustments = 0
      const origCost = parseFloat(job.original_cost) || 0;
      const costAdj = parseFloat(job.tot_cost_adj) || 0;
      if (origCost !== 0 || costAdj !== 0) return false;
    }
    
    // Status filter
    const status = (job.job_status || '').toLowerCase();
    if (status === 'a' || status === 'active') {
      if (!statusActive) return false;
    } else if (status === 'i' || status === 'inactive') {
      if (!statusInactive) return false;
    } else if (status === 'c' || status === 'closed') {
      if (!statusClosed) return false;
    } else if (status === 'o' || status === 'overhead') {
      if (!statusOverhead) return false;
    }
    
    // PM filter
    if (pmFilter && job.project_manager_name !== pmFilter) return false;
    
    // Customer filter
    if (custFilter && job.customer_name !== custFilter) return false;
    
    // Search
    if (search) {
      const searchFields = [job.job_no, job.job_description, job.customer_name].join(' ').toLowerCase();
      if (!searchFields.includes(search)) return false;
    }
    
    return true;
  });
  
  sortMissingBudgets();
}

function sortMissingBudgets() {
  missingBudgetsFiltered.sort((a, b) => {
    let valA = a[mbSortColumn];
    let valB = b[mbSortColumn];
    
    if (typeof valA === 'string') valA = valA.toLowerCase();
    if (typeof valB === 'string') valB = valB.toLowerCase();
    
    if (valA < valB) return mbSortDirection === 'asc' ? -1 : 1;
    if (valA > valB) return mbSortDirection === 'asc' ? 1 : -1;
    return 0;
  });
  
  renderMissingBudgetsTable();
}

function renderMissingBudgetsTable() {
  const tbody = document.getElementById('missingBudgetsTableBody');
  if (!tbody) return;
  
  if (missingBudgetsFiltered.length === 0) {
    tbody.innerHTML = '<tr><td colspan="11" class="loading-cell">No jobs found with missing budget data</td></tr>';
    updateMbPagination(0);
    return;
  }
  
  const start = (mbCurrentPage - 1) * mbPageSize;
  const end = start + mbPageSize;
  const pageData = missingBudgetsFiltered.slice(start, end);
  
  tbody.innerHTML = pageData.map(job => {
    const status = getJobStatusLabel(job.job_status);
    return `<tr>
      <td>${job.job_no || ''}</td>
      <td>${job.job_description || ''}</td>
      <td>${job.customer_name || ''}</td>
      <td><span class="job-status-badge ${status.class}">${status.label}</span></td>
      <td>${job.project_manager_name || ''}</td>
      <td class="number-col contract-detail-col hidden">${formatCurrency(job.original_contract)}</td>
      <td class="number-col contract-detail-col hidden">${formatCurrency(job.tot_income_adj)}</td>
      <td class="number-col revised-contract-col">${formatCurrency(job.contract)}</td>
      <td class="number-col cost-detail-col hidden">${formatCurrency(job.original_cost)}</td>
      <td class="number-col cost-detail-col hidden">${formatCurrency(job.tot_cost_adj)}</td>
      <td class="number-col revised-cost-col">${formatCurrency(job.revised_cost)}</td>
    </tr>`;
  }).join('');
  
  updateMbPagination(missingBudgetsFiltered.length);
}

function updateMbPagination(total) {
  const totalPages = Math.max(1, Math.ceil(total / mbPageSize));
  
  document.getElementById('mbPageInfo').textContent = `Page ${mbCurrentPage} of ${totalPages}`;
  document.getElementById('mbPrevPage').disabled = mbCurrentPage <= 1;
  document.getElementById('mbNextPage').disabled = mbCurrentPage >= totalPages;
}

// ========================================
// PM REPORT MODULE
// ========================================

let pmrInitialized = false;
let pmrData = {
  jobs: [],
  overUnder: [],
  missingBudgets: [],
  clientSummary: []
};
let pmrSelectedPm = '__ALL__'; // Default to All PMs
let pmrSelectedStatus = 'A';
let pmrArInvoices = [];
let pmrCompareMode = false; // Comparison to company average
let pmrCompanyAvg = {}; // Cached company-wide averages

// Cache key for PM list
const PMR_CACHE_KEY = 'ftg_pm_list_cache';
let pmrDataLoaded = false;

// Fast PM list loader with caching - now builds tabs instead of dropdown
async function loadPmrTabsFast() {
  try {
    // Try cache first for instant load
    const cached = localStorage.getItem(PMR_CACHE_KEY);
    if (cached) {
      try {
        const cacheData = JSON.parse(cached);
        // Use cache if less than 1 hour old
        if (cacheData.timestamp && Date.now() - cacheData.timestamp < 3600000) {
          buildPmrTabs(cacheData.pms);
          if (cacheData.generated_at) {
            jobsDataAsOf = cacheData.generated_at;
            const dataAsOf = document.getElementById('pmrDataAsOf');
            if (dataAsOf) dataAsOf.textContent = jobsDataAsOf;
          }
          // Refresh in background
          refreshPmListInBackground();
          return;
        }
      } catch (e) {
        console.warn('PM cache parse error:', e);
      }
    }
    
    // Fetch from lightweight API
    const resp = await fetch('/api/pm-list');
    if (resp.ok) {
      const data = await resp.json();
      if (data.success && data.pms) {
        buildPmrTabs(data.pms);
        // Cache the result
        localStorage.setItem(PMR_CACHE_KEY, JSON.stringify({
          pms: data.pms,
          generated_at: data.generated_at,
          timestamp: Date.now()
        }));
        if (data.generated_at) {
          jobsDataAsOf = data.generated_at;
          const dataAsOf = document.getElementById('pmrDataAsOf');
          if (dataAsOf) dataAsOf.textContent = jobsDataAsOf;
        }
        return;
      }
    }
    
    // Fallback to loading from full data
    await loadPmrTabsFromFullData();
    
  } catch (e) {
    console.error('Failed to load PM list:', e);
    // Fallback to full data load
    await loadPmrTabsFromFullData();
  }
}

function buildPmrTabs(pms) {
  // Build PM tabs using the generic function
  buildPmTabs('pmrPmTabs', pms, 'pmr', async (selectedPm) => {
    pmrSelectedPm = selectedPm === '__ALL__' ? '__ALL__' : selectedPm;
    pmrCompanyAvg = {}; // Reset comparison cache when PM changes
    if (pmrSelectedPm) {
      showPmrLoadingState();
      await ensurePmrDataLoaded();
    }
    updatePmReport();
  });
  
  // Sync internal state with what buildPmTabs selected
  pmrSelectedPm = pmTabsState.pmr;
}

async function refreshPmListInBackground() {
  try {
    const resp = await fetch('/api/pm-list');
    if (resp.ok) {
      const data = await resp.json();
      if (data.success && data.pms) {
        localStorage.setItem(PMR_CACHE_KEY, JSON.stringify({
          pms: data.pms,
          generated_at: data.generated_at,
          timestamp: Date.now()
        }));
      }
    }
  } catch (e) {
    // Silent background refresh failure
  }
}

async function loadPmrTabsFromFullData() {
  // Fallback: load from full jobs data
  if (!jobBudgetsData || jobBudgetsData.length === 0) {
    try {
      const metricsData = await DataCache.getJobsMetrics();
      const jobs = metricsData.jobs || [];
      jobBudgetsData = jobs.map(job => ({
        job_no: job.job_no,
        job_description: job.job_description,
        customer_name: job.customer_name,
        project_manager_name: job.project_manager,
        job_status: job.job_status,
        original_contract: job.original_contract || 0,
        tot_income_adj: job.tot_income_adj || 0,
        contract: job.contract,
      revised_contract: job.contract,
        original_cost: job.original_cost || 0,
        tot_cost_adj: job.tot_cost_adj || 0,
        revised_cost: job.budget_cost
      }));
      if (metricsData.generated_at) jobsDataAsOf = metricsData.generated_at;
    } catch (e) {
      console.error("Failed to load job budgets:", e);
    }
  }
  // Extract PMs from data and build tabs
  const pms = getActivePmsFromData(jobBudgetsData);
  buildPmrTabs(pms);
}

// Show loading state in the PM Report
function showPmrLoadingState() {
  const metricsRow1 = document.querySelector('.pmr-metrics-row');
  const metricsRow2 = document.querySelector('.pmr-metrics-row-2');
  
  // Add pulse animation to metric values
  document.querySelectorAll('.pmr-metric-value').forEach(el => {
    el.textContent = '...';
    el.classList.add('loading-pulse');
  });
  
  // Show loading in tables
  const loadingRow = '<tr><td colspan="9" class="pmr-empty-state"><div class="pmr-empty-state-text">Loading data...</div></td></tr>';
  const overUnderBody = document.getElementById('pmrOverUnderTableBody');
  const clientBody = document.getElementById('pmrClientSummaryTableBody');
  const missingBody = document.getElementById('pmrMissingBudgetsTableBody');
  
  if (overUnderBody) overUnderBody.innerHTML = loadingRow;
  if (clientBody) clientBody.innerHTML = '<tr><td colspan="7" class="pmr-empty-state"><div class="pmr-empty-state-text">Loading data...</div></td></tr>';
  if (missingBody) missingBody.innerHTML = '<tr><td colspan="8" class="pmr-empty-state"><div class="pmr-empty-state-text">Loading data...</div></td></tr>';
}

// Load full data only when a PM is selected (lazy loading)
async function ensurePmrDataLoaded() {
  if (pmrDataLoaded) return;
  
  // Reset comparison cache when loading new data
  pmrCompanyAvg = {};
  
  // Load job actuals
  if (!jobActualsData || jobActualsData.length === 0) {
    try {
      await loadJobActualsData();
    } catch (e) {
      console.error('Failed to load job actuals for PM Report:', e);
    }
  }
  
  // Load job budgets if not already loaded
  if (!jobBudgetsData || jobBudgetsData.length === 0) {
    try {
      const metricsData = await DataCache.getJobsMetrics();
      const jobs = metricsData.jobs || [];
      jobBudgetsData = jobs.map(job => ({
        job_no: job.job_no,
        job_description: job.job_description,
        customer_name: job.customer_name,
        project_manager_name: job.project_manager,
        job_status: job.job_status,
        original_contract: job.original_contract || 0,
        tot_income_adj: job.tot_income_adj || 0,
        contract: job.contract,
      revised_contract: job.contract,
        original_cost: job.original_cost || 0,
        tot_cost_adj: job.tot_cost_adj || 0,
        revised_cost: job.budget_cost
      }));
    } catch (e) {
      console.error("Failed to load job budgets for PM Report:", e);
    }
  }
  
  // Load AR invoices
  if (pmrArInvoices.length === 0) {
    try {
      const arData = await DataCache.getARMetrics();
      pmrArInvoices = arData.invoices || [];
    } catch (e) {
      console.error("Failed to load AR invoices for PM Report:", e);
    }
  }
  
  pmrDataLoaded = true;
}

async function initPmReport() {
  // FAST PATH: Build PM tabs from cache or lightweight API
  await loadPmrTabsFast();
  
  // Set up event listeners (only once)
  if (!pmrInitialized) {
    setupPmrEventListeners();
    pmrInitialized = true;
  }
  
  // Set data as of date
  const dataAsOf = document.getElementById('pmrDataAsOf');
  if (dataAsOf && jobsDataAsOf) {
    dataAsOf.textContent = jobsDataAsOf;
  }
  
  // If PM already selected (including default "All PMs"), load data and refresh
  if (pmrSelectedPm) {
    // Show loading indicator and load data before updating
    showPmrLoadingState();
    await ensurePmrDataLoaded();
    updatePmReport();
  }
}

// Note: Old populatePmrPmSelect function removed - now using PM tabs via buildPmrTabs()

function setupPmrEventListeners() {
  // Status checkboxes event listeners
  const statusCheckboxIds = ['pmrStatusActive', 'pmrStatusInactive', 'pmrStatusClosed', 'pmrStatusOverhead'];
  statusCheckboxIds.forEach(id => {
    const checkbox = document.getElementById(id);
    checkbox?.addEventListener('change', () => {
      pmrCompanyAvg = {}; // Reset comparison cache when status changes
      updatePmReport();
    });
  });
  
  // AI Analysis toggle
  const aiHeader = document.getElementById('pmrAiAnalysisHeader');
  const aiBody = document.getElementById('pmrAiAnalysisBody');
  aiHeader?.addEventListener('click', (e) => {
    if (e.target.closest('.ai-run-btn')) return;
    aiBody?.classList.toggle('expanded');
    const icon = aiHeader.querySelector('.ai-analysis-toggle-icon');
    if (icon) icon.textContent = aiBody?.classList.contains('expanded') ? '▼' : '▶';
  });
  
  // AI Analysis button
  const aiBtn = document.getElementById('pmrAiAnalyzeBtn');
  aiBtn?.addEventListener('click', () => runPmrAiAnalysis());
  
  // Comparison toggle
  const compareToggle = document.getElementById('pmrCompareToggle');
  compareToggle?.addEventListener('change', (e) => {
    pmrCompareMode = e.target.checked;
    updatePmrMetrics();
  });
}

function updatePmReport() {
  // Remove loading state
  document.querySelectorAll('.pmr-metric-value').forEach(el => {
    el.classList.remove('loading-pulse');
  });
  
  if (!pmrSelectedPm) {
    clearPmrTables();
    return;
  }
  
  // Filter jobs for this PM (or all PMs if "__ALL__" selected)
  const isAllPms = pmrSelectedPm === '__ALL__';
  let pmJobs = isAllPms ? jobActualsData : jobActualsData.filter(job => job.project_manager_name === pmrSelectedPm);
  let pmBudgets = isAllPms ? jobBudgetsData : jobBudgetsData.filter(job => job.project_manager_name === pmrSelectedPm);
  
  // Create a map of budget data by job number for quick lookup
  const budgetMap = new Map();
  pmBudgets.forEach(b => budgetMap.set(String(b.job_no), b));
  
  // Build combined data with over/under calculations
  let allJobs = pmJobs.map(job => {
    const jobNo = String(job.job_no);
    const budget = budgetMap.get(jobNo) || {};
    const revisedContract = parseFloat(budget.revised_contract) || job.contract || 0;
    const revisedCost = parseFloat(budget.revised_cost) || job.revised_cost || 0;
    const actualCost = job.actual_cost || 0;
    const earnedRevenue = job.earned_revenue || 0;
    const billedRevenue = job.billed_revenue || 0;
    const overUnder = billedRevenue - earnedRevenue;
    
    return {
      ...job,
      revised_contract: revisedContract,
      revised_cost: revisedCost,
      actual_cost: actualCost,
      earned_revenue: earnedRevenue,
      billed_revenue: billedRevenue,
      over_under: overUnder,
      customer_name: budget.customer_name || job.customer_name || '',
      job_status: budget.job_status || job.job_status || ''
    };
  });
  
  // Apply status filter from checkboxes
  const pmrShowActive = document.getElementById('pmrStatusActive')?.checked;
  const pmrShowInactive = document.getElementById('pmrStatusInactive')?.checked;
  const pmrShowClosed = document.getElementById('pmrStatusClosed')?.checked;
  const pmrShowOverhead = document.getElementById('pmrStatusOverhead')?.checked;
  
  const pmrAllowedStatuses = [];
  if (pmrShowActive) pmrAllowedStatuses.push('A');
  if (pmrShowInactive) pmrAllowedStatuses.push('I');
  if (pmrShowClosed) pmrAllowedStatuses.push('C');
  if (pmrShowOverhead) pmrAllowedStatuses.push('O');
  
  if (pmrAllowedStatuses.length > 0) {
    pmrData.jobs = allJobs.filter(job => pmrAllowedStatuses.includes(job.job_status));
  } else {
    pmrData.jobs = allJobs;
  }
  
  // Update metrics
  updatePmrMetrics();
  
  // Render charts
  renderPmrCharts();
  
  // Render PM Performance Radar chart
  pmRadarData = null;
  renderPmRadarChart();
  
  // Render tables
  renderPmrOverUnderTable();
  renderPmrMissingBudgetsTable();
  renderPmrClientSummaryTable();
}

// Gradient color helper for conditional formatting (green -> yellow -> red)
function getGradientColor(value, lowThreshold, highThreshold, inverse = false) {
  // inverse: true means low is good (green), high is bad (red)
  // inverse: false means high is good (green), low is bad (red)
  let ratio;
  if (inverse) {
    // Low = green, High = red
    if (value <= lowThreshold) ratio = 1; // green
    else if (value >= highThreshold) ratio = 0; // red
    else ratio = 1 - (value - lowThreshold) / (highThreshold - lowThreshold);
  } else {
    // High = green, Low = red
    if (value >= highThreshold) ratio = 1; // green
    else if (value <= lowThreshold) ratio = 0; // red
    else ratio = (value - lowThreshold) / (highThreshold - lowThreshold);
  }
  
  // Interpolate: red(0) -> yellow(0.5) -> green(1)
  let r, g, b;
  if (ratio <= 0.5) {
    // Red to Yellow
    r = 220;
    g = Math.round(38 + (175 * ratio * 2)); // 38 to 213
    b = 38;
  } else {
    // Yellow to Green
    r = Math.round(220 - (204 * (ratio - 0.5) * 2)); // 220 to 16
    g = Math.round(213 - (28 * (ratio - 0.5) * 2)); // 213 to 185
    b = Math.round(38 + (91 * (ratio - 0.5) * 2)); // 38 to 129
  }
  return `rgb(${r}, ${g}, ${b})`;
}

function updatePmrMetrics() {
  const jobs = pmrData.jobs;
  const isAllPmsView = pmrSelectedPm === '__ALL__';
  
  // Active Jobs KPI - always count only jobs with status 'A', regardless of filter
  const activeJobs = jobs.filter(j => j.job_status === 'A');
  const activeJobCount = activeJobs.length;
  
  // For individual PM view, denominator shows total active jobs across ALL PMs
  // For All PMs view, denominator shows total jobs in current view
  let totalActiveJobsAllPMs = activeJobCount;
  if (!isAllPmsView && jobActualsData && jobActualsData.length > 0) {
    totalActiveJobsAllPMs = jobActualsData.filter(j => j.job_status === 'A').length;
  }
  const totalJobs = isAllPmsView ? jobs.length : totalActiveJobsAllPMs;
  
  const totalContract = jobs.reduce((sum, j) => sum + (j.revised_contract || 0), 0);
  const totalActualCost = jobs.reduce((sum, j) => sum + (j.actual_cost || 0), 0);
  const totalEarnedRevenue = jobs.reduce((sum, j) => sum + (j.earned_revenue || 0), 0);
  const totalBilledRevenue = jobs.reduce((sum, j) => sum + (j.billed_revenue || 0), 0);
  
  // For Over/Under calculation, only include ACTIVE jobs with valid budget data (contract > 0 and cost > 0)
  // This matches Job Overview and Job Actuals pages for consistency
  const activeJobsWithValidBudget = activeJobs.filter(j => (j.revised_contract || 0) > 0 && (j.revised_cost || 0) > 0);
  const netOverUnder = activeJobsWithValidBudget.reduce((sum, j) => sum + ((j.billed_revenue || 0) - (j.earned_revenue || 0)), 0);
  
  // Calculate backlog (remaining contract to earn = contract - earned revenue)
  const backlog = totalContract - totalEarnedRevenue;
  const backlogPct = totalContract > 0 ? (backlog / totalContract * 100) : 0;
  
  // Calculate ACTUAL gross margin (earned revenue - actual cost) for realized performance
  const actualProfit = totalEarnedRevenue - totalActualCost;
  const grossMarginPct = totalEarnedRevenue > 0 ? (actualProfit / totalEarnedRevenue * 100) : 0;
  
  // Calculate average % complete
  const jobsWithProgress = jobs.filter(j => j.revised_cost > 0);
  const avgPctComplete = jobsWithProgress.length > 0 
    ? jobsWithProgress.reduce((sum, j) => sum + (j.percent_complete || 0), 0) / jobsWithProgress.length 
    : 0;
  
  // Calculate AR exposure from ALL invoices for this PM using calculated_amount_due (matches AR Aging report)
  const isAllPms = pmrSelectedPm === '__ALL__';
  let arTotal = 0, arOver60 = 0;
  pmrArInvoices.forEach(inv => {
    if (!isAllPms && inv.project_manager_name !== pmrSelectedPm) return;
    // Use calculated_amount_due (same as AR Aging report) - skip if <= 0
    const amtDue = parseFloat(inv.calculated_amount_due) || 0;
    if (amtDue <= 0) return;
    arTotal += amtDue;
    const days = parseInt(inv.days_outstanding) || 0;
    if (days > 60) arOver60 += amtDue;
  });
  
  // Calculate last month billing from ALL AR invoices for this PM (no job filter - use invoice's PM directly)
  const now = new Date();
  const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
  const lastMonthStart = new Date(lastMonthEnd.getFullYear(), lastMonthEnd.getMonth(), 1);
  const excelEpoch = new Date(1899, 11, 30);
  let billedLastMonth = 0;
  
  pmrArInvoices.forEach(inv => {
    if (!isAllPms && inv.project_manager_name !== pmrSelectedPm) return;
    // Don't filter by job_no - invoice already has PM name, use all invoices for this PM
    const invoiceDateSerial = parseFloat(inv.invoice_date) || 0;
    const invoiceDate = new Date(excelEpoch.getTime() + invoiceDateSerial * 24 * 60 * 60 * 1000);
    if (invoiceDate >= lastMonthStart && invoiceDate <= lastMonthEnd) {
      billedLastMonth += parseFloat(inv.invoice_amount) || 0;
    }
  });
  
  // Update DOM elements with compact currency format
  document.getElementById('pmrTotalJobs').textContent = `${activeJobCount} / ${totalJobs}`;
  document.getElementById('pmrTotalContract').textContent = formatCurrencyCompact(totalContract);
  document.getElementById('pmrTotalActualCost').textContent = formatCurrencyCompact(totalActualCost);
  document.getElementById('pmrTotalEarnedRevenue').textContent = formatCurrencyCompact(totalEarnedRevenue);
  
  // Backlog - gradient: 20%+ remaining = green (healthy), 10-20% = yellow, <10% = red (low backlog)
  const backlogEl = document.getElementById('pmrBacklog');
  const backlogPctEl = document.getElementById('pmrBacklogPct');
  if (backlogEl) {
    backlogEl.textContent = formatCurrencyCompact(backlog);
    backlogEl.style.color = getGradientColor(backlogPct, 10, 30, false);
  }
  if (backlogPctEl) {
    backlogPctEl.textContent = `${backlogPct.toFixed(0)}%`;
    backlogPctEl.style.color = getGradientColor(backlogPct, 10, 30, false);
  }
  
  // Gross Margin (actual realized margin) - gradient color based on percentage
  const marginEl = document.getElementById('pmrGrossMargin');
  const marginAmtEl = document.getElementById('pmrGrossMarginAmt');
  if (marginEl) {
    marginEl.textContent = `${grossMarginPct.toFixed(1)}%`;
    // Gradient: <5% red, 5-20% yellow gradient, >20% green
    marginEl.style.color = getGradientColor(grossMarginPct, 5, 20, false);
  }
  if (marginAmtEl) {
    marginAmtEl.textContent = formatCurrencyCompact(actualProfit);
    marginAmtEl.style.color = getGradientColor(grossMarginPct, 5, 20, false);
  }
  
  // Avg % Complete - gradient progress bar color
  const avgPctEl = document.getElementById('pmrAvgPctComplete');
  const progressFill = document.getElementById('pmrProgressFill');
  if (avgPctEl) {
    avgPctEl.textContent = `${avgPctComplete.toFixed(0)}%`;
    // Color: 0-30% red, 30-60% yellow, 60%+ green
    avgPctEl.style.color = getGradientColor(avgPctComplete, 30, 70, false);
  }
  if (progressFill) {
    progressFill.style.width = `${Math.min(avgPctComplete, 100)}%`;
    progressFill.style.backgroundColor = getGradientColor(avgPctComplete, 30, 70, false);
  }
  
  // Billed Last Month
  const billedLastMonthEl = document.getElementById('pmrBilledLastMonth');
  if (billedLastMonthEl) billedLastMonthEl.textContent = formatCurrencyCompact(billedLastMonth);
  
  // AR Exposure - gradient based on % of AR that's over 60 days (high % = red)
  const arEl = document.getElementById('pmrArExposure');
  const arOver60El = document.getElementById('pmrArOver60');
  if (arEl) arEl.textContent = formatCurrencyCompact(arTotal);
  if (arOver60El) {
    arOver60El.textContent = arOver60 > 0 ? `${formatCurrencyCompact(arOver60)} >60d` : 'None';
    // Color based on % of AR that's over 60 days: 0% green, 10% yellow, 25%+ red
    const arOver60Pct = arTotal > 0 ? (arOver60 / arTotal * 100) : 0;
    arOver60El.style.color = arOver60 > 0 ? getGradientColor(arOver60Pct, 5, 25, true) : '';
  }
  
  // Net Over/Under - gradient: negative (under-billed) = red, 0 = yellow, positive (over-billed) = green
  const netEl = document.getElementById('pmrNetOverUnder');
  if (netEl) {
    netEl.textContent = formatCurrencyCompact(netOverUnder);
    // Use % of earned revenue for context (under-billed by >10% of earned is concerning)
    const overUnderPct = totalEarnedRevenue > 0 ? (netOverUnder / totalEarnedRevenue * 100) : 0;
    // Gradient: -10% (red) -> 0% (yellow) -> +10% (green)
    netEl.style.color = getGradientColor(overUnderPct, -10, 10, false);
  }
  
  // Store computed data for charts
  pmrData.metrics = { totalContract, totalActualCost, totalEarnedRevenue, backlog, grossMarginPct, avgPctComplete, billedLastMonth, arTotal, arOver60, netOverUnder };
  
  // Calculate billing trend (compare to 2 months ago)
  const twoMonthsAgoEnd = new Date(now.getFullYear(), now.getMonth() - 1, 0);
  const twoMonthsAgoStart = new Date(twoMonthsAgoEnd.getFullYear(), twoMonthsAgoEnd.getMonth(), 1);
  let billedTwoMonthsAgo = 0;
  pmrArInvoices.forEach(inv => {
    if (!isAllPms && inv.project_manager_name !== pmrSelectedPm) return;
    const invoiceDateSerial = parseFloat(inv.invoice_date) || 0;
    const invoiceDate = new Date(excelEpoch.getTime() + invoiceDateSerial * 24 * 60 * 60 * 1000);
    if (invoiceDate >= twoMonthsAgoStart && invoiceDate <= twoMonthsAgoEnd) {
      billedTwoMonthsAgo += parseFloat(inv.invoice_amount) || 0;
    }
  });
  
  // Display billing trend
  const billingTrendEl = document.getElementById('pmrBillingTrend');
  if (billingTrendEl) {
    if (billedTwoMonthsAgo > 0) {
      const change = ((billedLastMonth - billedTwoMonthsAgo) / billedTwoMonthsAgo * 100);
      const arrow = change > 0 ? '↑' : change < 0 ? '↓' : '→';
      const trendClass = change > 0 ? 'up' : change < 0 ? 'down' : 'neutral';
      billingTrendEl.innerHTML = `<span class="${trendClass}">${arrow} ${Math.abs(change).toFixed(0)}% vs prior mo.</span>`;
    } else {
      billingTrendEl.innerHTML = '';
    }
  }
  
  // PM Comparison Mode - show vs company average
  if (pmrCompareMode && pmrSelectedPm !== '__ALL__' && jobActualsData && jobActualsData.length > 0) {
    // Calculate company-wide averages (cache for performance)
    if (!pmrCompanyAvg.calculated) {
      const allJobs = jobActualsData;
      const allActiveJobs = allJobs.filter(j => j.job_status === 'A');
      const pmCount = new Set(allActiveJobs.map(j => j.project_manager_name)).size || 1;
      
      // Use active jobs for all calculations to be consistent with individual PM view
      const allTotalContract = allActiveJobs.reduce((sum, j) => sum + (j.revised_contract || 0), 0);
      const allTotalActualCost = allActiveJobs.reduce((sum, j) => sum + (j.actual_cost || 0), 0);
      const allTotalEarnedRevenue = allActiveJobs.reduce((sum, j) => sum + (j.earned_revenue || 0), 0);
      const allActualProfit = allTotalEarnedRevenue - allTotalActualCost;
      const allGrossMarginPct = allTotalEarnedRevenue > 0 ? (allActualProfit / allTotalEarnedRevenue * 100) : 0;
      
      pmrCompanyAvg = {
        calculated: true,
        avgJobsPerPm: allActiveJobs.length / pmCount,
        avgContractPerPm: allTotalContract / pmCount,
        avgMargin: allGrossMarginPct,
        avgCostPerPm: allTotalActualCost / pmCount,
        avgRevenuePerPm: allTotalEarnedRevenue / pmCount
      };
    }
    
    // Show comparison in trend elements
    updateComparisonTrend('pmrJobsTrend', activeJobCount, pmrCompanyAvg.avgJobsPerPm, 'jobs', true);
    updateComparisonTrend('pmrContractTrend', totalContract, pmrCompanyAvg.avgContractPerPm, 'currency', true);
    updateComparisonTrend('pmrMarginTrend', grossMarginPct, pmrCompanyAvg.avgMargin, 'percent', true);
    updateComparisonTrend('pmrCostTrend', totalActualCost, pmrCompanyAvg.avgCostPerPm, 'currency', false);
    updateComparisonTrend('pmrRevenueTrend', totalEarnedRevenue, pmrCompanyAvg.avgRevenuePerPm, 'currency', true);
  } else {
    // Clear comparison trends
    ['pmrJobsTrend', 'pmrContractTrend', 'pmrMarginTrend', 'pmrCostTrend', 'pmrRevenueTrend', 'pmrOverUnderTrend'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.innerHTML = '';
    });
  }
}

function updateComparisonTrend(elementId, value, avgValue, format, higherIsBetter) {
  const el = document.getElementById(elementId);
  if (!el || avgValue === 0) return;
  
  const diff = value - avgValue;
  const pctDiff = (diff / avgValue * 100);
  const isBetter = higherIsBetter ? diff > 0 : diff < 0;
  const isWorse = higherIsBetter ? diff < 0 : diff > 0;
  
  let displayDiff;
  if (format === 'currency') {
    displayDiff = formatCurrencyCompact(Math.abs(diff));
  } else if (format === 'percent') {
    displayDiff = `${Math.abs(pctDiff).toFixed(1)}%`;
  } else {
    displayDiff = Math.abs(diff).toFixed(0);
  }
  
  const arrow = isBetter ? '↑' : isWorse ? '↓' : '→';
  const colorClass = isBetter ? 'compare better' : isWorse ? 'compare worse' : 'compare';
  el.innerHTML = `<span class="${colorClass}">${arrow} ${displayDiff} vs avg</span>`;
}

// PM Report Charts
let pmrStatusChart = null;
let pmrMarginChart = null;
let pmrBillingChart = null;
let pmrBudgetActualChart = null;
let pmrArAgingChart = null;

function renderPmrCharts() {
  renderPmrMarginChart();
  renderPmrBudgetActualChart();
  renderPmrBillingChart();
  renderPmrArAgingChart();
}

function renderPmrStatusChart() {
  const canvas = document.getElementById('pmrStatusChart');
  if (!canvas) return;
  
  const jobs = pmrData.jobs;
  
  // Count jobs by status
  const statusCounts = { A: 0, C: 0, I: 0, O: 0 };
  jobs.forEach(j => {
    const status = j.job_status || 'A';
    if (statusCounts[status] !== undefined) statusCounts[status]++;
  });
  
  const labels = ['Active', 'Closed', 'Inactive', 'Overhead'];
  const data = [statusCounts.A, statusCounts.C, statusCounts.I, statusCounts.O];
  const colors = ['#10b981', '#6b7280', '#f59e0b', '#8b5cf6'];
  
  // Destroy existing chart
  if (pmrStatusChart) {
    pmrStatusChart.destroy();
    pmrStatusChart = null;
  }
  
  const ctx = canvas.getContext('2d');
  pmrStatusChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: labels,
      datasets: [{
        data: data,
        backgroundColor: colors,
        borderWidth: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      cutout: '60%',
      plugins: {
        legend: { display: false }
      }
    }
  });
  
  // Build custom legend
  const legendEl = document.getElementById('pmrStatusLegend');
  if (legendEl) {
    legendEl.innerHTML = labels.map((label, i) => data[i] > 0 ? 
      `<span class="pmr-legend-item"><span class="pmr-legend-dot" style="background:${colors[i]}"></span>${label}: ${data[i]}</span>` : ''
    ).join('');
  }
}

function renderPmrMarginChart() {
  const canvas = document.getElementById('pmrMarginChart');
  if (!canvas) return;
  
  if (!pmrData.jobs || pmrData.jobs.length === 0) {
    if (pmrMarginChart) {
      pmrMarginChart.destroy();
      pmrMarginChart = null;
    }
    return;
  }
  
  const jobs = pmrData.jobs.filter(j => j.revised_contract > 0);
  
  // Group jobs by margin range
  const ranges = { low: 0, medium: 0, high: 0 };
  jobs.forEach(j => {
    const margin = ((j.revised_contract - j.revised_cost) / j.revised_contract) * 100;
    if (margin < 10) ranges.low++;
    else if (margin < 20) ranges.medium++;
    else ranges.high++;
  });
  
  // Destroy existing chart
  if (pmrMarginChart) {
    pmrMarginChart.destroy();
    pmrMarginChart = null;
  }
  
  // Theme-adaptive colors - must use static values for Chart.js scales
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#ffffff' : '#1f2937';
  const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)';
  
  const ctx = canvas.getContext('2d');
  pmrMarginChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: ['<10%', '10-20%', '>20%'],
      datasets: [{
        label: 'Jobs',
        data: [ranges.low, ranges.medium, ranges.high],
        backgroundColor: ['#dc2626', '#f59e0b', '#10b981'],
        borderRadius: 4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        datalabels: {
          anchor: 'end',
          align: 'end',
          color: textColor,
          font: { weight: 'bold', size: window.innerWidth <= 768 ? 10 : 12 },
          formatter: (value) => value > 0 ? value : ''
        }
      },
      scales: {
        y: { 
          beginAtZero: true,
          max: Math.ceil(Math.max(ranges.low, ranges.medium, ranges.high) * 1.2) || 1,
          ticks: { stepSize: 1, color: textColor },
          grid: { color: gridColor }
        },
        x: {
          ticks: { color: textColor },
          grid: { display: false }
        }
      }
    },
    plugins: [ChartDataLabels]
  });
}

function renderPmrBudgetActualChart() {
  const canvas = document.getElementById('pmrBudgetActualChart');
  if (!canvas) return;
  
  const jobs = pmrData.jobs || [];
  if (jobs.length === 0) {
    // Clear chart if no data
    if (pmrBudgetActualChart) {
      pmrBudgetActualChart.destroy();
      pmrBudgetActualChart = null;
    }
    return;
  }
  
  // Calculate totals for Budget vs Actual
  const totalBudgetedCost = jobs.reduce((sum, j) => sum + (j.revised_cost || 0), 0);
  const totalActualCost = jobs.reduce((sum, j) => sum + (j.actual_cost || 0), 0);
  const totalBudgetedRevenue = jobs.reduce((sum, j) => sum + (j.revised_contract || 0), 0);
  const totalEarnedRevenue = jobs.reduce((sum, j) => sum + (j.earned_revenue || 0), 0);
  
  // Destroy existing chart
  if (pmrBudgetActualChart) {
    pmrBudgetActualChart.destroy();
    pmrBudgetActualChart = null;
  }
  
  // Theme-adaptive colors
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#ffffff' : '#1f2937';
  const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)';
  
  const ctx = canvas.getContext('2d');
  pmrBudgetActualChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: ['Cost', 'Revenue'],
      datasets: [
        {
          label: 'Budget',
          data: [totalBudgetedCost, totalBudgetedRevenue],
          backgroundColor: '#6b7280',
          borderRadius: 4
        },
        {
          label: 'Actual',
          data: [totalActualCost, totalEarnedRevenue],
          backgroundColor: ['#3b82f6', '#10b981'],
          borderRadius: 4
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { 
          display: true,
          position: 'top',
          labels: { boxWidth: 12, padding: 8, font: { size: 10 }, color: textColor }
        },
        datalabels: {
          anchor: 'end',
          align: 'end',
          color: textColor,
          font: { weight: 'bold', size: 9 },
          formatter: (value) => value > 0 ? formatCurrencyCompact(value) : ''
        }
      },
      scales: {
        y: { 
          beginAtZero: true, 
          ticks: { callback: (v) => formatCurrencyShort(v), color: textColor, font: { size: 10 } },
          grid: { color: gridColor }
        },
        x: {
          ticks: { color: textColor },
          grid: { display: false }
        }
      }
    },
    plugins: [ChartDataLabels]
  });
}

function renderPmrBillingChart() {
  const canvas = document.getElementById('pmrBillingChart');
  if (!canvas) return;
  
  if (!pmrData.jobs || pmrData.jobs.length === 0) {
    if (pmrBillingChart) {
      pmrBillingChart.destroy();
      pmrBillingChart = null;
    }
    return;
  }
  
  // Use ALL PM jobs, not just active ones
  const pmJobNos = new Set(pmrData.jobs.map(j => String(j.job_no)));
  const excelEpoch = new Date(1899, 11, 30);
  
  // Get last 6 months of billing
  const now = new Date();
  const months = [];
  const billingByMonth = {};
  
  for (let i = 5; i >= 0; i--) {
    const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
    const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
    months.push(key);
    billingByMonth[key] = 0;
  }
  
  const isAllPms = pmrSelectedPm === '__ALL__';
  pmrArInvoices.forEach(inv => {
    if (!isAllPms && inv.project_manager_name !== pmrSelectedPm) return;
    if (!pmJobNos.has(String(inv.job_no))) return;
    
    const invoiceDateSerial = parseFloat(inv.invoice_date) || 0;
    const invoiceDate = new Date(excelEpoch.getTime() + invoiceDateSerial * 24 * 60 * 60 * 1000);
    const key = `${invoiceDate.getFullYear()}-${String(invoiceDate.getMonth() + 1).padStart(2, '0')}`;
    
    if (billingByMonth[key] !== undefined) {
      billingByMonth[key] += parseFloat(inv.invoice_amount) || 0;
    }
  });
  
  const labels = months.map(m => {
    const [y, mo] = m.split('-');
    return new Date(y, parseInt(mo) - 1, 1).toLocaleDateString('en-US', { month: 'short' });
  });
  // Keep full dollar amounts for proper display
  const data = months.map(m => billingByMonth[m]);
  
  // Destroy existing chart
  if (pmrBillingChart) {
    pmrBillingChart.destroy();
    pmrBillingChart = null;
  }
  
  // Theme-adaptive colors
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#ffffff' : '#1f2937';
  const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)';
  
  const ctx = canvas.getContext('2d');
  pmrBillingChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [{
        label: 'Billing ($K)',
        data: data,
        borderColor: '#3b82f6',
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        fill: true,
        tension: 0.3,
        pointRadius: 4,
        pointBackgroundColor: '#3b82f6'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: { callback: (v) => formatCurrencyShort(v), color: textColor },
          grid: { color: gridColor }
        },
        x: {
          ticks: { color: textColor },
          grid: { display: false }
        }
      }
    }
  });
}

// Helper function for short currency format on chart axes
function formatCurrencyShort(value) {
  if (Math.abs(value) >= 1000000) {
    return '$' + (value / 1000000).toFixed(1) + 'M';
  } else if (Math.abs(value) >= 1000) {
    return '$' + (value / 1000).toFixed(0) + 'K';
  }
  return '$' + value.toFixed(0);
}

function renderPmrArAgingChart() {
  const canvas = document.getElementById('pmrArAgingChart');
  if (!canvas) return;
  
  const isAllPms = pmrSelectedPm === '__ALL__';
  
  // Use same data source as AR Aging page - fetch from API
  const params = new URLSearchParams({
    sortColumn: 'days_90_plus',
    sortDirection: 'desc'
  });
  
  // If specific PM selected, filter by PM name
  if (!isAllPms && pmrSelectedPm) {
    params.set('pm', pmrSelectedPm);
  }
  
  fetch(`/api/ar-aging?${params.toString()}`)
    .then(r => r.json())
    .then(data => {
      if (data.success && data.totals) {
        const totals = data.totals;
        const aging = {
          current: totals.current || 0,
          days31_60: totals.days_31_60 || 0,
          days61_90: totals.days_61_90 || 0,
          days90Plus: totals.days_90_plus || 0
        };
        renderPmrArAgingChartWithData(canvas, aging);
      } else {
        // Fallback to empty chart
        renderPmrArAgingChartWithData(canvas, { current: 0, days31_60: 0, days61_90: 0, days90Plus: 0 });
      }
    })
    .catch(err => {
      console.error('Error loading AR aging for PM Report:', err);
      renderPmrArAgingChartWithData(canvas, { current: 0, days31_60: 0, days61_90: 0, days90Plus: 0 });
    });
}

function renderPmrArAgingChartWithData(canvas, aging) {
  // Destroy existing chart
  if (pmrArAgingChart) {
    pmrArAgingChart.destroy();
    pmrArAgingChart = null;
  }
  
  // Theme-adaptive colors
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#ffffff' : '#1f2937';
  const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)';
  
  const ctx = canvas.getContext('2d');
  pmrArAgingChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: ['0-30', '31-60', '61-90', '90+'],
      datasets: [{
        label: 'AR Aging',
        data: [aging.current, aging.days31_60, aging.days61_90, aging.days90Plus],
        backgroundColor: ['#22c55e', '#eab308', '#f97316', '#ef4444'],
        borderRadius: 4
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: function(context) {
              return formatCurrency(context.raw);
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: { callback: (v) => formatCurrencyShort(v), color: textColor, font: { size: 10 } },
          grid: { color: gridColor }
        },
        x: {
          ticks: { color: textColor, font: { size: 10 } },
          grid: { display: false }
        }
      }
    }
  });
}

// Track collapse state for Over/Under section (now controls columns, not rows)
let pmrOverUnderExpanded = false;
let pmrMissingBudgetsExpanded = false;
let pmrMissingBudgetsRowsExpanded = false; // Collapsed by default - only show subtotal
let pmrClientSummaryRowsExpanded = false; // Collapsed by default - only show subtotal

function renderPmrOverUnderTable() {
  const tbody = document.getElementById('pmrOverUnderTableBody');
  if (!tbody) return;
  
  // Filter to show only jobs with non-zero variance
  const overUnderJobs = pmrData.jobs.filter(j => Math.abs(j.over_under) > 0.01)
    .sort((a, b) => a.over_under - b.over_under); // Under-billed first
  
  pmrData.overUnder = overUnderJobs;
  
  if (overUnderJobs.length === 0) {
    tbody.innerHTML = '<tr><td colspan="4" class="pmr-empty-state"><div class="pmr-empty-state-text">No jobs with billing variance</div></td></tr>';
    document.getElementById('pmrOverUnderCount').textContent = '0 jobs';
    document.getElementById('pmrOverUnderToggle').style.display = 'none';
    return;
  }
  
  // Calculate totals for subtotal row
  const totals = overUnderJobs.reduce((acc, j) => ({
    contract: acc.contract + (j.revised_contract || 0),
    actualCost: acc.actualCost + (j.actual_cost || 0),
    earnedRev: acc.earnedRev + (j.earned_revenue || 0),
    billedRev: acc.billedRev + (j.billed_revenue || 0),
    overUnder: acc.overUnder + (j.over_under || 0)
  }), { contract: 0, actualCost: 0, earnedRev: 0, billedRev: 0, overUnder: 0 });
  
  const avgPctComplete = overUnderJobs.length > 0 
    ? overUnderJobs.reduce((sum, j) => sum + (j.percent_complete || 0), 0) / overUnderJobs.length 
    : 0;
  
  const overUnderClass = totals.overUnder >= 0 ? 'over-billed' : 'under-billed';
  
  // Subtotal row first
  const subtotalRow = `<tr class="pmr-subtotal-row">
    <td colspan="3"><strong>TOTAL (${overUnderJobs.length} jobs)</strong></td>
    <td class="text-right pmr-expandable-col">${formatCurrencyCompact(totals.contract)}</td>
    <td class="text-right pmr-expandable-col">${formatCurrencyCompact(totals.actualCost)}</td>
    <td class="text-right pmr-expandable-col">${avgPctComplete.toFixed(1)}%</td>
    <td class="text-right pmr-expandable-col">${formatCurrencyCompact(totals.earnedRev)}</td>
    <td class="text-right pmr-expandable-col">${formatCurrencyCompact(totals.billedRev)}</td>
    <td class="text-right ${overUnderClass}">${formatCurrencyCompact(totals.overUnder)}</td>
  </tr>`;
  
  // Detail rows - hidden by default, shown when expanded
  const detailRows = overUnderJobs.map(job => {
    const pctComplete = job.percent_complete || 0;
    const jobOverUnderClass = job.over_under >= 0 ? 'over-billed' : 'under-billed';
    return `<tr class="pmr-ou-detail-row">
      <td>${job.job_no || ''}</td>
      <td>${job.job_description || ''}</td>
      <td>${job.customer_name || ''}</td>
      <td class="text-right pmr-expandable-col">${formatCurrencyCompact(job.contract)}</td>
      <td class="text-right pmr-expandable-col">${formatCurrencyCompact(job.actual_cost)}</td>
      <td class="text-right pmr-expandable-col">${pctComplete.toFixed(1)}%</td>
      <td class="text-right pmr-expandable-col">${formatCurrencyCompact(job.earned_revenue)}</td>
      <td class="text-right pmr-expandable-col">${formatCurrencyCompact(job.billed_revenue)}</td>
      <td class="text-right ${jobOverUnderClass}">${formatCurrencyCompact(job.over_under)}</td>
    </tr>`;
  }).join('');
  
  tbody.innerHTML = subtotalRow + detailRows;
  
  // Update toggle button state and apply column visibility
  const toggleBtn = document.getElementById('pmrOverUnderToggle');
  if (toggleBtn) {
    toggleBtn.textContent = pmrOverUnderExpanded ? 'Collapse' : 'Expand';
    toggleBtn.style.display = 'inline-block';
  }
  
  // Apply current column visibility state
  applyOverUnderColumnVisibility();
  
  document.getElementById('pmrOverUnderCount').textContent = `${overUnderJobs.length} job${overUnderJobs.length !== 1 ? 's' : ''}`;
}

function applyOverUnderColumnVisibility() {
  const table = document.getElementById('pmrOverUnderTable');
  if (!table) return;
  
  // Toggle expandable columns visibility
  const expandableCols = table.querySelectorAll('.pmr-expandable-col');
  expandableCols.forEach(col => {
    col.style.display = pmrOverUnderExpanded ? '' : 'none';
  });
  
  // Toggle detail rows visibility (rows below subtotal)
  const detailRows = table.querySelectorAll('.pmr-ou-detail-row');
  detailRows.forEach(row => {
    row.style.display = pmrOverUnderExpanded ? '' : 'none';
  });
}

function togglePmrOverUnderDetail() {
  pmrOverUnderExpanded = !pmrOverUnderExpanded;
  
  // Toggle column visibility
  applyOverUnderColumnVisibility();
  
  // Update button text
  const toggleBtn = document.getElementById('pmrOverUnderToggle');
  if (toggleBtn) {
    toggleBtn.textContent = pmrOverUnderExpanded ? 'Collapse' : 'Expand';
  }
}

function applyMissingBudgetsColumnVisibility() {
  const table = document.getElementById('pmrMissingBudgetsTable');
  if (!table) return;
  
  const expandableCols = table.querySelectorAll('.pmr-mb-expandable-col');
  expandableCols.forEach(col => {
    col.style.display = pmrMissingBudgetsExpanded ? '' : 'none';
  });
}

function togglePmrMissingBudgetsDetail() {
  pmrMissingBudgetsRowsExpanded = !pmrMissingBudgetsRowsExpanded;
  
  // Toggle row visibility
  const table = document.getElementById('pmrMissingBudgetsTable');
  if (table) {
    const dataRows = table.querySelectorAll('.pmr-mb-data-row');
    dataRows.forEach(row => {
      row.style.display = pmrMissingBudgetsRowsExpanded ? '' : 'none';
    });
  }
  
  // Update button text
  const toggleBtn = document.getElementById('pmrMissingBudgetsToggle');
  if (toggleBtn) {
    toggleBtn.textContent = pmrMissingBudgetsRowsExpanded ? 'Collapse' : 'Expand';
  }
}

function togglePmrClientSummaryDetail() {
  pmrClientSummaryRowsExpanded = !pmrClientSummaryRowsExpanded;
  
  // Toggle row visibility
  const table = document.getElementById('pmrClientSummaryTable');
  if (table) {
    const dataRows = table.querySelectorAll('.pmr-client-data-row');
    dataRows.forEach(row => {
      row.style.display = pmrClientSummaryRowsExpanded ? '' : 'none';
    });
  }
  
  // Update button text
  const toggleBtn = document.getElementById('pmrClientSummaryToggle');
  if (toggleBtn) {
    toggleBtn.textContent = pmrClientSummaryRowsExpanded ? 'Collapse' : 'Expand';
  }
}

function renderPmrMissingBudgetsTable() {
  const tbody = document.getElementById('pmrMissingBudgetsTableBody');
  if (!tbody) return;
  
  // Get jobs with >$2,500 actual cost but missing budget data
  const threshold = 2500;
  
  // Build map of actuals by job
  const isAllPms = pmrSelectedPm === '__ALL__';
  const actualsMap = new Map();
  jobActualsData.forEach(j => {
    if (isAllPms || j.project_manager_name === pmrSelectedPm) {
      actualsMap.set(String(j.job_no), j);
    }
  });
  
  // Build map of budgets by job
  const budgetMap = new Map();
  jobBudgetsData.forEach(b => {
    budgetMap.set(String(b.job_no), b);
  });
  
  // Find jobs with actual cost > threshold but missing budget revenue or cost
  // Only show ACTIVE jobs (status 'A')
  const missingBudgets = [];
  
  actualsMap.forEach((actual, jobNo) => {
    const actualCost = actual.actual_cost || 0;
    if (actualCost < threshold) return;
    
    const budget = budgetMap.get(jobNo) || {};
    const jobStatus = budget.job_status || actual.job_status || '';
    
    // Only include active jobs
    if (jobStatus !== 'A') return;
    
    const revisedContract = parseFloat(budget.revised_contract) || 0;
    const revisedCost = parseFloat(budget.revised_cost) || 0;
    
    if (revisedContract === 0 || revisedCost === 0) {
      let issue = '';
      let issueClass = '';
      if (revisedContract === 0 && revisedCost === 0) {
        issue = 'No Budget';
        issueClass = 'no-both';
      } else if (revisedContract === 0) {
        issue = 'No Revenue';
        issueClass = 'no-revenue';
      } else {
        issue = 'No Cost';
        issueClass = 'no-cost';
      }
      
      missingBudgets.push({
        job_no: jobNo,
        job_description: actual.job_description || budget.job_description || '',
        customer_name: actual.customer_name || budget.customer_name || '',
        job_status: jobStatus,
        actual_cost: actualCost,
        revised_contract: revisedContract,
        revised_cost: revisedCost,
        issue: issue,
        issueClass: issueClass
      });
    }
  });
  
  pmrData.missingBudgets = missingBudgets.sort((a, b) => b.actual_cost - a.actual_cost);
  
  if (missingBudgets.length === 0) {
    tbody.innerHTML = '<tr><td colspan="8" class="pmr-empty-state"><div class="pmr-empty-state-text">No jobs with missing budgets above $2,500</div></td></tr>';
    document.getElementById('pmrMissingBudgetsCount').textContent = '0 jobs';
    return;
  }
  
  // Calculate total actual cost
  const totalActualCost = missingBudgets.reduce((sum, job) => sum + (job.actual_cost || 0), 0);
  
  // Build subtotal row first, then data rows
  const subtotalRow = `<tr class="pmr-subtotal-row">
    <td colspan="4"><strong>Total (${missingBudgets.length} jobs)</strong></td>
    <td class="text-right"><strong>${formatCurrency(totalActualCost)}</strong></td>
    <td colspan="3"></td>
  </tr>`;
  
  const rowDisplayStyle = pmrMissingBudgetsRowsExpanded ? '' : 'display:none;';
  const dataRows = missingBudgets.map(job => {
    const status = getJobStatusLabel(job.job_status);
    return `<tr class="pmr-mb-data-row" style="${rowDisplayStyle}">
      <td>${job.job_no || ''}</td>
      <td>${job.job_description || ''}</td>
      <td class="pmr-mb-expandable-col">${job.customer_name || ''}</td>
      <td class="pmr-mb-expandable-col"><span class="job-status-badge ${status.class}">${status.label}</span></td>
      <td class="text-right">${formatCurrency(job.actual_cost)}</td>
      <td class="text-right">${formatCurrency(job.contract)}</td>
      <td class="text-right">${formatCurrency(job.revised_cost)}</td>
      <td><span class="pmr-issue-badge ${job.issueClass}">${job.issue}</span></td>
    </tr>`;
  }).join('');
  
  tbody.innerHTML = subtotalRow + dataRows;
  
  // Update toggle button text for rows
  const toggleBtn = document.getElementById('pmrMissingBudgetsToggle');
  if (toggleBtn) {
    toggleBtn.textContent = pmrMissingBudgetsRowsExpanded ? 'Collapse' : 'Expand';
  }
  applyMissingBudgetsColumnVisibility();
  
  document.getElementById('pmrMissingBudgetsCount').textContent = `${missingBudgets.length} job${missingBudgets.length !== 1 ? 's' : ''}`;
}

function renderPmrClientSummaryTable() {
  const tbody = document.getElementById('pmrClientSummaryTableBody');
  if (!tbody) return;
  
  // Get active jobs for this PM
  const activeJobs = pmrData.jobs.filter(job => job.job_status === 'A');
  const activeJobNos = new Set(activeJobs.map(j => String(j.job_no)));
  
  // Calculate last complete month date range
  const now = new Date();
  const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0); // Last day of previous month
  const lastMonthStart = new Date(lastMonthEnd.getFullYear(), lastMonthEnd.getMonth(), 1); // First day of previous month
  
  // Excel serial date base (January 1, 1900 = 1, but Excel has a leap year bug so we use Dec 30, 1899)
  const excelEpoch = new Date(1899, 11, 30);
  
  // Calculate last month billing from AR invoices for this PM's active jobs
  const lastMonthBillingByClient = new Map();
  
  const isAllPms = pmrSelectedPm === '__ALL__';
  pmrArInvoices.forEach(inv => {
    // Check if invoice is for this PM and an active job
    if (!isAllPms && inv.project_manager_name !== pmrSelectedPm) return;
    if (!activeJobNos.has(String(inv.job_no))) return;
    
    // Convert Excel serial date to JS Date
    const invoiceDateSerial = parseFloat(inv.invoice_date) || 0;
    const invoiceDate = new Date(excelEpoch.getTime() + invoiceDateSerial * 24 * 60 * 60 * 1000);
    
    // Check if in last complete month
    if (invoiceDate >= lastMonthStart && invoiceDate <= lastMonthEnd) {
      const client = inv.customer_name || 'Unknown';
      const amount = parseFloat(inv.invoice_amount) || 0;
      lastMonthBillingByClient.set(client, (lastMonthBillingByClient.get(client) || 0) + amount);
    }
  });
  
  // Aggregate by client - only include ACTIVE jobs (status 'A')
  const clientMap = new Map();
  
  activeJobs.forEach(job => {
    const client = job.customer_name || 'Unknown';
    if (!clientMap.has(client)) {
      clientMap.set(client, {
        customer_name: client,
        est_contract: 0,
        est_cost: 0,
        billed_last_month: lastMonthBillingByClient.get(client) || 0,
        billed_to_date: 0,
        cost_to_date: 0
      });
    }
    
    const c = clientMap.get(client);
    c.est_contract += job.contract || 0;
    c.est_cost += job.revised_cost || 0;
    c.billed_to_date += job.billed_revenue || 0;
    c.cost_to_date += job.actual_cost || 0;
  });
  
  // Sort by contract value - show all clients with active jobs
  const clients = [...clientMap.values()]
    .map(c => {
      const estProfit = c.est_contract - c.est_cost;
      const marginPct = c.est_contract > 0 ? (estProfit / c.est_contract * 100) : 0;
      return {
        ...c,
        est_profit: estProfit,
        margin_pct: marginPct
      };
    })
    .sort((a, b) => b.est_contract - a.est_contract);
  
  pmrData.clientSummary = clients;
  
  if (clients.length === 0) {
    tbody.innerHTML = '<tr><td colspan="8" class="pmr-empty-state"><div class="pmr-empty-state-text">No client data available</div></td></tr>';
    document.getElementById('pmrClientSummaryCount').textContent = '0 clients';
    return;
  }
  
  // Calculate totals for subtotal row
  const totals = clients.reduce((acc, c) => ({
    est_contract: acc.est_contract + c.est_contract,
    est_cost: acc.est_cost + c.est_cost,
    est_profit: acc.est_profit + c.est_profit,
    billed_last_month: acc.billed_last_month + c.billed_last_month,
    billed_to_date: acc.billed_to_date + c.billed_to_date,
    cost_to_date: acc.cost_to_date + c.cost_to_date
  }), { est_contract: 0, est_cost: 0, est_profit: 0, billed_last_month: 0, billed_to_date: 0, cost_to_date: 0 });
  
  const totalMarginPct = totals.est_contract > 0 ? (totals.est_profit / totals.est_contract * 100) : 0;
  
  // Subtotal row first, then detail rows
  // Margin color: green >= 20%, red < 10%, neutral uses CSS class for dark/light mode
  const totalMarginClass = totalMarginPct >= 20 ? 'margin-good' : totalMarginPct < 10 ? 'margin-bad' : 'margin-neutral';
  const subtotalRow = `<tr class="pmr-subtotal-row">
    <td><strong>TOTAL (${clients.length} clients)</strong></td>
    <td class="text-right">${formatCurrencyCompact(totals.est_contract)}</td>
    <td class="text-right">${formatCurrencyCompact(totals.est_cost)}</td>
    <td class="text-right">${formatCurrencyCompact(totals.est_profit)}</td>
    <td class="text-right ${totalMarginClass}">${totalMarginPct.toFixed(1)}%</td>
    <td class="text-right">${formatCurrencyCompact(totals.billed_last_month)}</td>
    <td class="text-right">${formatCurrencyCompact(totals.billed_to_date)}</td>
    <td class="text-right">${formatCurrencyCompact(totals.cost_to_date)}</td>
  </tr>`;
  
  const clientRowDisplayStyle = pmrClientSummaryRowsExpanded ? '' : 'display:none;';
  const detailRows = clients.map(c => {
    // Margin color classes: green >= 20%, red < 10%, neutral adapts to dark/light mode
    const marginClass = c.margin_pct >= 20 ? 'margin-good' : c.margin_pct < 10 ? 'margin-bad' : 'margin-neutral';
    return `<tr class="pmr-client-data-row" style="${clientRowDisplayStyle}">
      <td>${c.customer_name}</td>
      <td class="text-right">${formatCurrencyCompact(c.est_contract)}</td>
      <td class="text-right">${formatCurrencyCompact(c.est_cost)}</td>
      <td class="text-right">${formatCurrencyCompact(c.est_profit)}</td>
      <td class="text-right ${marginClass}">${c.margin_pct.toFixed(1)}%</td>
      <td class="text-right">${formatCurrencyCompact(c.billed_last_month)}</td>
      <td class="text-right">${formatCurrencyCompact(c.billed_to_date)}</td>
      <td class="text-right">${formatCurrencyCompact(c.cost_to_date)}</td>
    </tr>`;
  }).join('');
  
  tbody.innerHTML = subtotalRow + detailRows;
  
  // Update toggle button text for client summary rows
  const clientToggleBtn = document.getElementById('pmrClientSummaryToggle');
  if (clientToggleBtn) {
    clientToggleBtn.textContent = pmrClientSummaryRowsExpanded ? 'Collapse' : 'Expand';
  }
  
  document.getElementById('pmrClientSummaryCount').textContent = `${clients.length} client${clients.length !== 1 ? 's' : ''}`;
}

function clearPmrTables() {
  // Row 1 metrics
  document.getElementById('pmrTotalJobs').textContent = '-';
  document.getElementById('pmrTotalContract').textContent = '-';
  document.getElementById('pmrBacklog').textContent = '-';
  document.getElementById('pmrBacklogPct').textContent = '-';
  document.getElementById('pmrGrossMargin').textContent = '-';
  document.getElementById('pmrGrossMarginAmt').textContent = '-';
  document.getElementById('pmrNetOverUnder').textContent = '-';
  document.getElementById('pmrNetOverUnder').classList.remove('positive', 'negative');
  
  // Row 2 metrics
  document.getElementById('pmrAvgPctComplete').textContent = '-';
  document.getElementById('pmrProgressFill').style.width = '0%';
  document.getElementById('pmrBilledLastMonth').textContent = '-';
  document.getElementById('pmrArExposure').textContent = '-';
  document.getElementById('pmrArOver60').textContent = '-';
  document.getElementById('pmrTotalActualCost').textContent = '-';
  document.getElementById('pmrTotalEarnedRevenue').textContent = '-';
  
  // Clear charts
  if (pmrMarginChart) { pmrMarginChart.destroy(); pmrMarginChart = null; }
  if (pmrBudgetActualChart) { pmrBudgetActualChart.destroy(); pmrBudgetActualChart = null; }
  if (pmrBillingChart) { pmrBillingChart.destroy(); pmrBillingChart = null; }
  if (pmrArAgingChart) { pmrArAgingChart.destroy(); pmrArAgingChart = null; }
  
  const emptyRow = '<tr><td colspan="9" class="pmr-empty-state"><div class="pmr-empty-state-icon">👤</div><div class="pmr-empty-state-text">Select a Project Manager to view their report</div></td></tr>';
  
  document.getElementById('pmrOverUnderTableBody').innerHTML = emptyRow;
  document.getElementById('pmrMissingBudgetsTableBody').innerHTML = '<tr><td colspan="8" class="pmr-empty-state"><div class="pmr-empty-state-text">Select a Project Manager to view their report</div></td></tr>';
  document.getElementById('pmrClientSummaryTableBody').innerHTML = '<tr><td colspan="7" class="pmr-empty-state"><div class="pmr-empty-state-text">Select a Project Manager to view their report</div></td></tr>';
  
  document.getElementById('pmrOverUnderCount').textContent = '0 jobs';
  document.getElementById('pmrMissingBudgetsCount').textContent = '0 jobs';
  document.getElementById('pmrClientSummaryCount').textContent = '0 clients';
}

async function runPmrAiAnalysis() {
  const btn = document.getElementById('pmrAiAnalyzeBtn');
  const panel = document.getElementById('pmrAiAnalysisPanel');
  const content = document.getElementById('pmrAiAnalysisContent');
  
  if (!btn || !panel || !content) return;
  
  if (!pmrSelectedPm) {
    showNotification('Please select a Project Manager first', 'warning');
    return;
  }
  
  btn.disabled = true;
  btn.textContent = 'Analyzing...';
  panel.classList.remove('collapsed');
  content.innerHTML = '<div class="ai-analysis-loading"><div class="ai-spinner"></div>Analyzing PM performance...</div>';
  
  try {
    const statementData = extractPmReportData();
    const response = await fetch('/api/analyze-pm-report', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({statementData, periodInfo: 'PM Report Analysis'})
    });
    const result = await response.json();
    if (result.success) {
      content.innerHTML = formatMarkdown(result.analysis);
      panel.classList.add('has-analysis');
    } else {
      content.innerHTML = `<div style="color: #dc2626;">Error: ${result.error}</div>`;
    }
  } catch (e) {
    content.innerHTML = `<div style="color: #dc2626;">Error: ${e.message}</div>`;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Run Analysis';
  }
}

function extractPmReportData() {
  let text = "PM Report Analysis:\n\n";
  
  // Get selected PM
  const pmLabel = pmrSelectedPm === '__ALL__' ? 'All Project Managers (Company-Wide)' : pmrSelectedPm;
  text += `Project Manager: ${pmLabel}\n\n`;
  
  // Get key metrics from the page
  text += "Key Metrics:\n";
  const metricIds = [
    {id: 'pmrTotalJobs', label: 'Active Jobs'},
    {id: 'pmrTotalContract', label: 'Contract Value'},
    {id: 'pmrBacklog', label: 'Backlog'},
    {id: 'pmrGrossMargin', label: 'Gross Margin'},
    {id: 'pmrNetOverUnder', label: 'Net Over/(Under)'},
    {id: 'pmrAvgPctComplete', label: 'Avg % Complete'},
    {id: 'pmrBilledLastMonth', label: 'Billed Last Month'},
    {id: 'pmrArExposure', label: 'AR Exposure'},
    {id: 'pmrTotalActualCost', label: 'Actual Cost'},
    {id: 'pmrTotalEarnedRevenue', label: 'Earned Revenue'}
  ];
  
  metricIds.forEach(m => {
    const el = document.getElementById(m.id);
    if (el) {
      text += `- ${m.label}: ${el.textContent || '-'}\n`;
    }
  });
  
  // Get data from pmrData if available
  const jobs = pmrData.jobs || [];
  const overUnder = pmrData.overUnder || [];
  const missingBudgets = pmrData.missingBudgets || [];
  const clients = pmrData.clientSummary || [];
  
  text += `\nTotal Jobs in Dataset: ${jobs.length}\n`;
  
  if (overUnder.length > 0) {
    text += `\nOver/Under Billing Issues (${overUnder.length} jobs):\n`;
    overUnder.slice(0, 5).forEach(j => {
      text += `- ${j.job_no}: ${j.job_description} - ${formatCurrency(j.over_under)} (${j.over_under < 0 ? 'Under' : 'Over'})\n`;
    });
  }
  
  if (missingBudgets.length > 0) {
    text += `\nMissing Budgets (${missingBudgets.length} jobs):\n`;
    missingBudgets.slice(0, 5).forEach(j => {
      text += `- ${j.job_no}: ${j.job_description} - ${j.issue} - Cost: ${formatCurrency(j.actual_cost)}\n`;
    });
  }
  
  if (clients.length > 0) {
    text += `\nTop Clients by Contract Value:\n`;
    clients.slice(0, 10).forEach(c => {
      text += `- ${c.customer_name}: Contract ${formatCurrency(c.est_contract)}, Cost ${formatCurrency(c.cost_to_date)}, Profit ${formatCurrency(c.est_profit)}\n`;
    });
  }
  
  return text || "No PM report data available";
}

// ========================================
// AI INSIGHTS MODULE - Comprehensive Analysis
// ========================================

let aiInsightsInitialized = false;

function initAiInsights() {
  if (aiInsightsInitialized) return;
  
  const runBtn = document.getElementById('aiInsightsRunBtn');
  const retryBtn = document.getElementById('aiInsightsRetryBtn');
  
  runBtn?.addEventListener('click', runFullAiAnalysis);
  retryBtn?.addEventListener('click', runFullAiAnalysis);
  
  // Initialize AI Q&A Chat
  initAiQaChat();
  
  aiInsightsInitialized = true;
}

// AI Q&A Chat functionality
function initAiQaChat() {
  const input = document.getElementById('aiQaInput');
  const submitBtn = document.getElementById('aiQaSubmitBtn');
  const exampleBtns = document.querySelectorAll('.ai-qa-example-btn');
  const suggestionBtns = document.querySelectorAll('.ai-suggestion-btn');
  
  // Submit on button click
  submitBtn?.addEventListener('click', submitAiQaQuestion);
  
  // Submit on Enter key
  input?.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      submitAiQaQuestion();
    }
  });
  
  // Example button clicks (legacy)
  exampleBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const question = btn.dataset.question;
      if (question && input) {
        input.value = question;
        submitAiQaQuestion();
      }
    });
  });
  
  // New suggestion button clicks (chat interface)
  suggestionBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const question = btn.dataset.question;
      if (question && input) {
        input.value = question;
        submitAiQaQuestion();
      }
    });
  });
}

async function submitAiQaQuestion() {
  const input = document.getElementById('aiQaInput');
  const submitBtn = document.getElementById('aiQaSubmitBtn');
  const conversation = document.getElementById('aiQaConversation');
  const welcome = document.querySelector('.ai-chat-welcome');
  const fullAnalysisResults = document.getElementById('aiInsightsResults');

  const question = input?.value?.trim();
  if (!question) return;
  
  // Disable input while processing
  input.disabled = true;
  submitBtn.disabled = true;
  
  // Hide welcome screen when conversation starts
  if (welcome) welcome.classList.add('hidden');

  // Hide full analysis results when user asks a new question
  if (fullAnalysisResults) fullAnalysisResults.classList.add('hidden');
  
  // Show conversation container
  conversation.classList.remove('hidden');

  
  // Add user message
  const userMsg = document.createElement('div');
  userMsg.className = 'ai-chat-message user';
  userMsg.innerHTML = `<div class="message-content">${escapeHtml(question)}</div>`;
  conversation.appendChild(userMsg);
  
  // Add loading message
  const loadingMsg = document.createElement('div');
  loadingMsg.className = 'ai-chat-message assistant loading';
  loadingMsg.innerHTML = `
    <div class="message-content">
      <div class="ai-qa-loading-dots">
        <span></span><span></span><span></span>
      </div>
      Thinking...
    </div>
  `;
  conversation.appendChild(loadingMsg);
  
  // Scroll to bottom
  const chatMessages = document.getElementById('aiChatMessages');
  if (chatMessages) chatMessages.scrollTop = chatMessages.scrollHeight;
  
  // Clear input
  input.value = '';
  
  try {
    const response = await fetch('/api/nlq', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ question })
    });
    
    const result = await response.json();
    
    // Remove loading message
    loadingMsg.remove();
    
    // Add assistant response
    const assistantMsg = document.createElement('div');
    assistantMsg.className = 'ai-chat-message assistant';
    
    if (result.success) {
      assistantMsg.innerHTML = `<div class="message-content">${formatAiQaResponse(result.answer)}</div>`;
    } else {
      assistantMsg.innerHTML = `<div class="message-content" style="color: var(--error-color);">Sorry, I couldn't process that question. ${result.error || 'Please try again.'}</div>`;
    }
    
    conversation.appendChild(assistantMsg);
    const chatMessages = document.getElementById('aiChatMessages');
  if (chatMessages) chatMessages.scrollTop = chatMessages.scrollHeight;
    
  } catch (err) {
    console.error('AI Q&A error:', err);
    loadingMsg.remove();
    
    const errorMsg = document.createElement('div');
    errorMsg.className = 'ai-chat-message assistant';
    errorMsg.innerHTML = `<div class="message-content" style="color: var(--error-color);">Sorry, there was an error processing your question. Please try again.</div>`;
    conversation.appendChild(errorMsg);
  } finally {
    // Re-enable input
    input.disabled = false;
    submitBtn.disabled = false;
    submitBtn.querySelector('.btn-text').textContent = 'Ask';
    input.focus();
  }
}

function formatAiQaResponse(text) {
  // Convert markdown-style formatting to HTML
  let html = escapeHtml(text);
  
  // Bold text
  html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  
  // Line breaks
  html = html.replace(/\n/g, '<br>');
  
  // Format currency values for emphasis
  html = html.replace(/\$[\d,]+(?:\.\d{1,2})?[MKB]?/g, '<strong>$&</strong>');
  
  return html;
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

async function runFullAiAnalysis() {
  const runBtn = document.getElementById('aiInsightsRunBtn');
  const progress = document.getElementById('aiInsightsProgress');
  const progressFill = document.getElementById('aiInsightsProgressFill');
  const progressText = document.getElementById('aiInsightsProgressText');
  const results = document.getElementById('aiInsightsResults');
  const errorDiv = document.getElementById('aiInsightsError');
  
  // Reset states
  runBtn.disabled = true;
  runBtn.querySelector('.btn-text').textContent = 'Analyzing...';
  progress.classList.remove('hidden');
  results.classList.add('hidden');
  errorDiv.classList.add('hidden');
  progressFill.style.width = '0%';
  
  try {
    // Step 1: Load and aggregate all data
    progressText.textContent = 'Loading financial data...';
    progressFill.style.width = '10%';
    
    const statementData = await extractAiInsightsData();
    
    progressText.textContent = 'Sending to AI for analysis...';
    progressFill.style.width = '40%';
    
    // Step 2: Call AI API - use same pattern as overview
    progressText.textContent = 'Generating insights...';
    progressFill.style.width = '60%';
    
    console.log('AI Insights data being sent:', statementData);
    
    const response = await fetch('/api/analyze-ai-insights', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({statementData, periodInfo: 'Comprehensive Business Analysis'})
    });
    
    const result = await response.json();
    
    progressText.textContent = 'Formatting results...';
    progressFill.style.width = '90%';
    
    if (result.success) {
      // Step 3: Parse and display results
      displayAiInsightsResults(result.analysis);
      
      progressFill.style.width = '100%';
      progressText.textContent = 'Analysis complete!';
      
      setTimeout(() => {
        progress.classList.add('hidden');
        results.classList.remove('hidden');
      }, 500);
    } else {
      throw new Error(result.error || 'Analysis failed');
    }
    
  } catch (err) {
    console.error('AI Insights error:', err);
    progress.classList.add('hidden');
    errorDiv.classList.remove('hidden');
    const errorMsgEl = document.getElementById('aiInsightsErrorMsg');
    if (errorMsgEl) {
      errorMsgEl.textContent = `Unable to complete analysis: ${err.message}`;
    }
  } finally {
    runBtn.disabled = false;
    runBtn.querySelector('.btn-text').textContent = 'Run Full Analysis';
  }
}

async function extractAiInsightsData() {
  let text = "FTG Builders Financial Dashboard - Comprehensive Business Analysis\n\n";
  text += "NOTE: All dollar values below are in USD and represent real business data.\n\n";
  
  try {
    // Load ALL data sources for comprehensive analysis
    // Load ALL data sources for comprehensive analysis - use metrics API where available
    const [metricsData, arMetrics, apMetrics, glData, cashData] = await Promise.all([
      DataCache.getJobsMetrics().catch(e => { console.warn("Jobs metrics load failed:", e); return null; }),
      DataCache.getARMetrics().catch(e => { console.warn("AR metrics load failed:", e); return null; }),
      DataCache.getAPMetrics().catch(e => { console.warn("AP metrics load failed:", e); return null; }),
      DataCache.getGLData().catch(e => { console.warn("GL data load failed:", e); return null; }),
      fetch("/api/cash-data").then(r => r.ok ? r.json() : null).catch(e => { console.warn("Cash data load failed:", e); return null; })
    ]);
    
    // Map metrics to expected format for backward compatibility
    const jobsData = metricsData ? { job_budgets: metricsData.jobs } : null;
    const arData = arMetrics ? { invoices: arMetrics.invoices } : null;
    const apData = apMetrics ? { invoices: apMetrics.invoices } : null;
    
    // FINANCIAL PERFORMANCE from GL Data
    if (glData && glData.gl_history_all) {
      text += "=== FINANCIAL PERFORMANCE ===\n";
      const glHistoryAll = glData.gl_history_all;
      const currentYear = new Date().getFullYear();
      const lastYear = currentYear - 1;
      const currentMonth = new Date().getMonth() + 1;
      
      // Build list of months for current year and prior year
      const currentYearMonths = [];
      const lastYearMonths = [];
      for (let m = 1; m <= 12; m++) {
        const monthStr = String(m).padStart(2, '0');
        if (m <= currentMonth) {
          currentYearMonths.push(`${currentYear}-${monthStr}`);
        }
        lastYearMonths.push(`${lastYear}-${monthStr}`);
      }
      
      let revenueCurrentYear = 0, revenueLastYear = 0;
      let directCostsCurrent = 0, indirectCostsCurrent = 0, sgaCurrent = 0;
      
      glHistoryAll.forEach(entry => {
        const acct = parseInt(entry.Account_Num) || 0;
        
        // Sum amounts for each month
        const sumMonths = (months) => {
          return months.reduce((sum, month) => {
            return sum + (parseFloat(entry[month]) || 0);
          }, 0);
        };
        
        if (acct >= 4000 && acct < 5000) {
          revenueCurrentYear += sumMonths(currentYearMonths);
          revenueLastYear += sumMonths(lastYearMonths);
        } else if (acct >= 5000 && acct < 6000) {
          directCostsCurrent += sumMonths(currentYearMonths);
        } else if (acct >= 6000 && acct < 7000) {
          indirectCostsCurrent += sumMonths(currentYearMonths);
        } else if (acct >= 7000 && acct < 8000) {
          sgaCurrent += sumMonths(currentYearMonths);
        }
      });
      
      const normalizedRevCurrent = Math.abs(revenueCurrentYear);
      const normalizedRevLast = Math.abs(revenueLastYear);
      const grossProfit = normalizedRevCurrent - Math.abs(directCostsCurrent) - Math.abs(indirectCostsCurrent);
      const operatingIncome = grossProfit - Math.abs(sgaCurrent);
      const revenueGrowth = normalizedRevLast > 0 ? ((normalizedRevCurrent - normalizedRevLast) / normalizedRevLast * 100) : 0;
      
      text += `Revenue YTD (${currentYear}): $${normalizedRevCurrent.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Revenue Prior Year (${lastYear}): $${normalizedRevLast.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `YoY Revenue Growth: ${revenueGrowth.toFixed(1)}%\n`;
      text += `Gross Profit YTD: $${grossProfit.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Gross Margin: ${normalizedRevCurrent > 0 ? (grossProfit / normalizedRevCurrent * 100).toFixed(1) : 0}%\n`;
      text += `Operating Income YTD: $${operatingIncome.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Operating Margin: ${normalizedRevCurrent > 0 ? (operatingIncome / normalizedRevCurrent * 100).toFixed(1) : 0}%\n\n`;
    }
    
    // CASH POSITION - use API endpoint (same as Cash Report page)
    // Cash data from API has: accounts[] with {name, balance, lastUpdate}
    if (cashData && cashData.success && cashData.accounts) {
      text += "=== CASH POSITION ===\n";
      const accounts = cashData.accounts;
      
      // Filter FTG Builders accounts by name containing account suffixes
      const FTG_SUFFIXES = ['1883', '2469', '7554'];
      const ftgAccounts = accounts.filter(a => FTG_SUFFIXES.some(suffix => (a.name || '').includes(suffix)));
      const totalCash = ftgAccounts.reduce((sum, a) => sum + (parseFloat(a.balance) || 0), 0);
      
      // Also show all accounts for context
      const allAccountsTotal = accounts.reduce((sum, a) => sum + (parseFloat(a.balance) || 0), 0);
      
      text += `Current Cash Balance (FTG Builders): $${totalCash.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Total Cash (All Accounts): $${allAccountsTotal.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      
      // List individual FTG accounts
      if (ftgAccounts.length > 0) {
        text += "FTG Builders Account Breakdown:\n";
        ftgAccounts.forEach(a => {
          text += `  - ${a.name}: $${(parseFloat(a.balance) || 0).toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
        });
      }
      text += "\n";
    }
    
    // Jobs Summary - use pre-computed metrics
    if (metricsData && metricsData.jobs) {
      text += "=== JOB PORTFOLIO ===\n";
      const jobs = metricsData.jobs || [];
      
      // Exclude configured PMs from analysis
      const activeJobs = jobs.filter(j => j.job_status === 'A' && !PM_EXCLUSION_CONFIG.isExcluded(j.project_manager));
      
      const totalContract = activeJobs.reduce((s, j) => s + (j.contract || 0), 0);
      const totalCost = activeJobs.reduce((s, j) => s + (j.budget_cost || 0), 0);
      const totalActualCost = activeJobs.reduce((s, j) => s + (j.actual_cost || 0), 0);
      const estProfit = totalContract - totalCost;
      const margin = totalContract > 0 ? (estProfit / totalContract * 100) : 0;
      
      text += `Total Active Jobs: ${activeJobs.length}\n`;
      text += `Total Contract Value: $${totalContract.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}\n`;
      text += `Total Budgeted Cost: $${totalCost.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}\n`;
      text += `Total Actual Cost to Date: $${totalActualCost.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}\n`;
      text += `Estimated Profit: $${estProfit.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}\n`;
      text += `Estimated Margin: ${margin.toFixed(1)}%\n\n`;
      
      // Over/Under Billing Summary - use pre-computed metrics
      const totalBilled = activeJobs.reduce((s, j) => s + (j.billed || 0), 0);
      const totalEarned = activeJobs.reduce((s, j) => s + (j.earned_revenue || 0), 0);
      const netOverUnder = activeJobs.reduce((s, j) => s + (j.over_under_billing || 0), 0);
      const overBilledCount = activeJobs.filter(j => (j.over_under_billing || 0) > 0).length;
      const underBilledCount = activeJobs.filter(j => (j.over_under_billing || 0) < 0).length;
      
      text += `Total Billed to Date: $${totalBilled.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Total Earned Revenue: $${totalEarned.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Net Over/(Under) Billing: $${netOverUnder.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Jobs Over-Billed: ${overBilledCount} | Jobs Under-Billed: ${underBilledCount}\n\n`;
      
      // PM Summary - use pre-computed metrics, exclude configured PMs
      const pmStats = {};
      activeJobs.forEach(j => {
        const pm = j.project_manager || 'Unassigned';
        if (PM_EXCLUSION_CONFIG.isExcluded(pm)) return;
        if (!pmStats[pm]) pmStats[pm] = {jobs: 0, contract: 0, cost: 0, billed: 0, earned: 0, overUnder: 0};
        pmStats[pm].jobs++;
        pmStats[pm].contract += j.contract || 0;
        pmStats[pm].cost += j.budget_cost || 0;
        pmStats[pm].billed += j.billed || 0;
        pmStats[pm].earned += j.earned_revenue || 0;
        pmStats[pm].overUnder += j.over_under_billing || 0;
      });
      text += "Project Managers (Active Jobs):\n";
      Object.entries(pmStats).sort((a, b) => b[1].contract - a[1].contract).forEach(([pm, stats]) => {
        const pmMargin = stats.contract > 0 ? ((stats.contract - stats.cost) / stats.contract * 100).toFixed(1) : 0;
        text += `- ${pm}: ${stats.jobs} jobs, $${stats.contract.toLocaleString('en-US', {maximumFractionDigits: 0})} contract, ${pmMargin}% margin, O/U: $${stats.overUnder.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      });
      text += "\n";
    }
    
    
    // AR Summary - use correct field names (invoices, amount_due)
    if (arData && arData.invoices) {
      text += "=== ACCOUNTS RECEIVABLE ===\n";
      const invoices = arData.invoices;
      // Use calculated_amount_due (actual remaining balance after payments) - this matches AR Aging page
      const getCollectible = (inv) => {
        const calcDue = parseFloat(inv.calculated_amount_due) || 0;
        const retainage = parseFloat(inv.retainage_amount) || 0;
        return Math.max(0, calcDue - retainage); // Collectible amount excluding retainage
      };
      const getRetainage = (inv) => parseFloat(inv.retainage_amount) || 0;
      
      const totalCollectible = invoices.reduce((s, i) => s + getCollectible(i), 0);
      const totalRetainage = invoices.reduce((s, i) => s + getRetainage(i), 0);
      const totalAR = totalCollectible + totalRetainage;
      
      const current = invoices.filter(i => (parseInt(i.days_outstanding) || 0) <= 30).reduce((s, i) => s + getCollectible(i), 0);
      const over30 = invoices.filter(i => (parseInt(i.days_outstanding) || 0) > 30 && (parseInt(i.days_outstanding) || 0) <= 60).reduce((s, i) => s + getCollectible(i), 0);
      const over60 = invoices.filter(i => (parseInt(i.days_outstanding) || 0) > 60 && (parseInt(i.days_outstanding) || 0) <= 90).reduce((s, i) => s + getCollectible(i), 0);
      const over90 = invoices.filter(i => (parseInt(i.days_outstanding) || 0) > 90).reduce((s, i) => s + getCollectible(i), 0);
      
      text += `Total AR Outstanding: $${totalAR.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Collectible (excl. Retainage): $${totalCollectible.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Retainage Held: $${totalRetainage.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Current (0-30 days): $${current.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `31-60 Days: $${over30.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `61-90 Days: $${over60.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Over 90 Days: $${over90.toLocaleString('en-US', {maximumFractionDigits: 0})}\n\n`;
    }
    
    // AP Summary - use correct field names (invoices, remaining_balance)
    if (apData && apData.invoices) {
      text += "=== ACCOUNTS PAYABLE ===\n";
      const invoices = apData.invoices;
      const totalAP = invoices.reduce((s, i) => s + (parseFloat(i.remaining_balance) || 0), 0);
      const current = invoices.filter(i => (i.days_outstanding || 0) <= 30).reduce((s, i) => s + (parseFloat(i.remaining_balance) || 0), 0);
      const over30 = invoices.filter(i => (i.days_outstanding || 0) > 30).reduce((s, i) => s + (parseFloat(i.remaining_balance) || 0), 0);
      
      text += `Total AP Outstanding: $${totalAP.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Current (0-30 days): $${current.toLocaleString('en-US', {maximumFractionDigits: 0})}\n`;
      text += `Over 30 Days: $${over30.toLocaleString('en-US', {maximumFractionDigits: 0})}\n\n`;
    }
    
  } catch (e) {
    console.error('Error extracting AI insights data:', e);
    text += "Error loading some data sources.\n";
  }
  
  return text || "No data available for analysis";
}

async function aggregateAllBusinessData() {
  const data = {
    financial: {},
    jobs: {},
    ar: {},
    ap: {},
    pms: [],
    clients: [],
    vendors: [],
    loadErrors: []
  };
  
  // Load all data sources in parallel using cache
  // Load all data sources in parallel using cache - use metrics API where available
  const [glData, metricsData, arMetrics, apMetrics] = await Promise.all([
    DataCache.getGLData().catch(e => { data.loadErrors.push("GL Data"); return null; }),
    DataCache.getJobsMetrics().catch(e => { data.loadErrors.push("Jobs Data"); return null; }),
    DataCache.getARMetrics().catch(e => { data.loadErrors.push("AR Data"); return null; }),
    DataCache.getAPMetrics().catch(e => { data.loadErrors.push("AP Data"); return null; })
  ]);
  
  // Map metrics to expected format for backward compatibility
  const jobsData = metricsData ? { job_budgets: metricsData.jobs } : null;
  const arData = arMetrics ? { invoices: arMetrics.invoices } : null;
  const apData = apMetrics ? { invoices: apMetrics.invoices } : null;
  
  // Aggregate Financial Data - use gl_history_all with monthly columns
  if (glData && glData.gl_history_all) {
    const glHistoryAll = glData.gl_history_all;
    const currentYear = new Date().getFullYear();
    const lastYear = currentYear - 1;
    const currentMonth = new Date().getMonth() + 1;
    
    // Build list of months for current year and prior year
    const currentYearMonths = [];
    const lastYearMonths = [];
    for (let m = 1; m <= 12; m++) {
      const monthStr = String(m).padStart(2, '0');
      if (m <= currentMonth) {
        currentYearMonths.push(`${currentYear}-${monthStr}`);
      }
      lastYearMonths.push(`${lastYear}-${monthStr}`);
    }
    
    let revenueCurrentYear = 0, revenueLastYear = 0;
    let expenseCurrentYear = 0, expenseLastYear = 0;
    
    glHistoryAll.forEach(entry => {
      const acct = parseInt(entry.Account_Num) || 0;
      
      // Sum amounts for each month
      const sumMonths = (months) => {
        return months.reduce((sum, month) => {
          return sum + (parseFloat(entry[month]) || 0);
        }, 0);
      };
      
      if (acct >= 4000 && acct < 5000) {
        revenueCurrentYear += sumMonths(currentYearMonths);
        revenueLastYear += sumMonths(lastYearMonths);
      } else if (acct >= 5000 && acct < 9000) {
        expenseCurrentYear += sumMonths(currentYearMonths);
        expenseLastYear += sumMonths(lastYearMonths);
      }
    });
    
    // Normalize signs: revenue is typically credit (negative in some GL systems), expenses are debit (positive)
    const normalizedRevCurrent = Math.abs(revenueCurrentYear);
    const normalizedRevLast = Math.abs(revenueLastYear);
    const normalizedExpCurrent = Math.abs(expenseCurrentYear);
    const normalizedExpLast = Math.abs(expenseLastYear);
    
    data.financial = {
      revenueCurrentYear: normalizedRevCurrent,
      revenueLastYear: normalizedRevLast,
      revenueGrowth: normalizedRevLast ? ((normalizedRevCurrent - normalizedRevLast) / normalizedRevLast * 100) : 0,
      expenseCurrentYear: normalizedExpCurrent,
      expenseLastYear: normalizedExpLast,
      profitCurrentYear: normalizedRevCurrent - normalizedExpCurrent,
      profitLastYear: normalizedRevLast - normalizedExpLast,
      profitMarginCurrent: normalizedRevCurrent ? ((normalizedRevCurrent - normalizedExpCurrent) / normalizedRevCurrent * 100) : 0
    };
  }
  
  // Aggregate Jobs Data - use pre-computed metrics values
  if (metricsData && metricsData.jobs) {
    const jobs = metricsData.jobs || [];
    
    let totalContract = 0, totalCost = 0, totalActualCost = 0, totalBilled = 0;
    let activeJobCount = 0;
    let totalOverUnder = 0;
    let totalEarnedRevenue = 0;
    const pmStats = new Map();
    const clientStats = new Map();
    const missingBudgetJobs = [];
    
    // Filter to active jobs only for totals
    const activeJobsList = jobs.filter(j => (j.job_status || '').toUpperCase() === 'A');
    
    activeJobsList.forEach(job => {
      const contract = parseFloat(job.contract) || 0;
      const budgetCost = parseFloat(job.budget_cost) || 0;
      const actualCost = parseFloat(job.actual_cost) || 0;
      const billed = parseFloat(job.billed) || 0;
      const earnedRev = parseFloat(job.earned_revenue) || 0;
      const overUnder = parseFloat(job.over_under_billing) || 0;
      const pm = job.project_manager || 'Unassigned';
      const client = job.customer_name || 'Unknown';
      
      totalContract += contract;
      totalCost += budgetCost;
      totalActualCost += actualCost;
      totalBilled += billed;
      totalEarnedRevenue += earnedRev;
      totalOverUnder += overUnder;
      
      activeJobCount++;
      
      // PM stats
      if (!pmStats.has(pm)) {
        pmStats.set(pm, { jobs: 0, contract: 0, actualCost: 0, overUnder: 0 });
      }
      const pmStat = pmStats.get(pm);
      pmStat.jobs++;
      pmStat.contract += contract;
      pmStat.actualCost += actualCost;
      pmStat.overUnder += overUnder;
      
      // Client stats
      if (!clientStats.has(client)) {
        clientStats.set(client, { jobs: 0, contract: 0, billed: 0 });
      }
      const clientStat = clientStats.get(client);
      clientStat.jobs++;
      clientStat.contract += contract;
      clientStat.billed += billed;
      
      // Check for missing budgets
      if (actualCost > 2500 && !job.has_budget) {
        missingBudgetJobs.push({ jobNo: job.job_no, actualCost, issue: 'No Budget' });
      }
    });
    
    data.jobs = {
      totalJobs: jobs.length,
      activeJobs: activeJobCount,
      closedJobs: jobs.filter(j => (j.job_status || '').toUpperCase() === 'C').length,
      totalContract,
      totalCost,
      totalActualCost,
      totalBilled,
      totalEarnedRevenue,
      totalOverUnder,
      avgProfitMargin: totalContract ? ((totalContract - totalCost) / totalContract * 100) : 0,
      missingBudgetCount: missingBudgetJobs.length
    };
    
    // Top 5 PMs by contract value
    data.pms = [...pmStats.entries()]
      .map(([name, stats]) => ({ name, ...stats }))
      .sort((a, b) => b.contract - a.contract)
      .slice(0, 5);
    
    // Top 5 clients
    data.clients = [...clientStats.entries()]
      .map(([name, stats]) => ({ name, ...stats }))
      .sort((a, b) => b.contract - a.contract)
      .slice(0, 5);
  }
  
  // Aggregate AR Data - use calculated_amount_due (actual balance after payments) matching AR Aging page
  if (arData && arData.invoices) {
    const invoices = arData.invoices;
    let totalCollectible = 0, totalRetainage = 0, current = 0, over30 = 0, over60 = 0, over90 = 0;
    const customerAR = new Map();
    
    invoices.forEach(inv => {
      const calcDue = parseFloat(inv.calculated_amount_due) || 0;
      const retainage = parseFloat(inv.retainage_amount) || 0;
      const collectible = Math.max(0, calcDue - retainage);
      const daysOut = parseInt(inv.days_outstanding) || 0;
      const customer = inv.customer_name || 'Unknown';
      
      totalCollectible += collectible;
      totalRetainage += retainage;
      if (daysOut <= 30) current += collectible;
      else if (daysOut <= 60) over30 += collectible;
      else if (daysOut <= 90) over60 += collectible;
      else over90 += collectible;
      
      customerAR.set(customer, (customerAR.get(customer) || 0) + collectible);
    });
    
    const totalAR = totalCollectible + totalRetainage;
    data.ar = {
      totalOutstanding: totalAR,
      totalCollectible,
      totalRetainage,
      current,
      over30,
      over60,
      over90,
      topCustomers: [...customerAR.entries()]
        .map(([name, amount]) => ({ name, amount }))
        .sort((a, b) => b.amount - a.amount)
        .slice(0, 5)
    };
  }
  
  // Aggregate AP Data - use correct field names (invoices, remaining_balance, days_outstanding)
  if (apData && apData.invoices) {
    const invoices = apData.invoices;
    let totalAP = 0, current = 0, over30 = 0, over60 = 0, over90 = 0;
    const vendorAP = new Map();
    
    invoices.forEach(inv => {
      const amtDue = parseFloat(inv.remaining_balance) || 0;
      const daysOut = parseInt(inv.days_outstanding) || 0;
      const vendor = inv.vendor_name || 'Unknown';
      
      totalAP += amtDue;
      if (daysOut <= 30) current += amtDue;
      else if (daysOut <= 60) over30 += amtDue;
      else if (daysOut <= 90) over60 += amtDue;
      else over90 += amtDue;
      
      vendorAP.set(vendor, (vendorAP.get(vendor) || 0) + amtDue);
    });
    
    data.ap = {
      totalOutstanding: totalAP,
      current,
      over30,
      over60,
      over90,
      topVendors: [...vendorAP.entries()]
        .map(([name, amount]) => ({ name, amount }))
        .sort((a, b) => b.amount - a.amount)
        .slice(0, 5)
    };
  }
  
  return data;
}

function buildComprehensiveAiPrompt(data) {
  const f = data.financial;
  const j = data.jobs;
  const ar = data.ar;
  const ap = data.ap;
  const pms = data.pms;
  const clients = data.clients;
  
  return `You are a business analyst for a construction company. Analyze this comprehensive business data and provide strategic insights.

=== FINANCIAL PERFORMANCE ===
Current Year Revenue: ${formatCurrency(f.revenueCurrentYear || 0)}
Prior Year Revenue: ${formatCurrency(f.revenueLastYear || 0)}
Revenue Growth: ${(f.revenueGrowth || 0).toFixed(1)}%
Current Year Expenses: ${formatCurrency(f.expenseCurrentYear || 0)}
Current Year Profit: ${formatCurrency(f.profitCurrentYear || 0)}
Profit Margin: ${(f.profitMarginCurrent || 0).toFixed(1)}%

=== JOB PORTFOLIO ===
Total Jobs: ${j.totalJobs || 0}
Active Jobs: ${j.activeJobs || 0}
Closed Jobs: ${j.closedJobs || 0}
Total Contract Value: ${formatCurrency(j.totalContract || 0)}
Total Estimated Cost: ${formatCurrency(j.totalCost || 0)}
Total Actual Cost: ${formatCurrency(j.totalActualCost || 0)}
Total Billed: ${formatCurrency(j.totalBilled || 0)}
Net Over/(Under) Billing: ${formatCurrency(j.totalOverUnder || 0)}
Jobs Missing Budgets (>$2.5k cost): ${j.missingBudgetCount || 0}

=== TOP PROJECT MANAGERS (by Contract Value) ===
${(pms || []).map(pm => `${pm.name}: ${pm.jobs} jobs, ${formatCurrency(pm.contract)} contract, O/U: ${formatCurrency(pm.overUnder)}`).join('\n')}

=== TOP CLIENTS (by Contract Value) ===
${(clients || []).map(c => `${c.name}: ${c.jobs} jobs, ${formatCurrency(c.contract)} contract, ${formatCurrency(c.billed)} billed`).join('\n')}

=== ACCOUNTS RECEIVABLE ===
Total Outstanding: ${formatCurrency(ar.totalOutstanding || 0)}
Current (0-30 days): ${formatCurrency(ar.current || 0)}
31-60 days: ${formatCurrency(ar.over30 || 0)}
61-90 days: ${formatCurrency(ar.over60 || 0)}
Over 90 days: ${formatCurrency(ar.over90 || 0)}
Top Customers with Outstanding AR:
${(ar.topCustomers || []).map(c => `- ${c.name}: ${formatCurrency(c.amount)}`).join('\n')}

=== ACCOUNTS PAYABLE ===
Total Outstanding: ${formatCurrency(ap.totalOutstanding || 0)}
Current (0-30 days): ${formatCurrency(ap.current || 0)}
31-60 days: ${formatCurrency(ap.over30 || 0)}
61-90 days: ${formatCurrency(ap.over60 || 0)}
Over 90 days: ${formatCurrency(ap.over90 || 0)}
Top Vendors with Outstanding AP:
${(ap.topVendors || []).map(v => `- ${v.name}: ${formatCurrency(v.amount)}`).join('\n')}

${PM_EXCLUSION_CONFIG.getAIPromptExclusion()}

Please provide a comprehensive analysis with the following sections (use markdown formatting):

## EXECUTIVE SUMMARY
A 2-3 sentence overview of the company's current financial health and key takeaways.

## FINANCIAL HEALTH
Analysis of revenue trends, profitability, and expense management.

## JOB PERFORMANCE
Analysis of job portfolio, billing status, and project execution.

## CASH FLOW & RECEIVABLES/PAYABLES
Analysis of AR aging, AP management, and cash position.

## PROJECT MANAGER PERFORMANCE
Comparison of PM performance and any concerns${PM_EXCLUSION_CONFIG.excludedPMs.length ? ` (excluding ${PM_EXCLUSION_CONFIG.excludedPMs.join(', ')})` : ''}.

## STRATEGIC RECOMMENDATIONS
Top 3-5 actionable recommendations prioritized by impact.`;
}

function displayAiInsightsResults(response) {
  const contentEl = document.getElementById('aiInsightsContent');
  if (!response) {
    contentEl.innerHTML = '<p>No analysis available.</p>';
    return;
  }
  
  // Display full analysis in single section
  contentEl.innerHTML = formatMarkdown(response);
}

// ========================================
// OVER/(UNDER) BILLING MODULE
// ========================================

let oubData = [];
let oubFiltered = [];
let oubCurrentPage = 1;
let oubPageSize = 25;
let oubSortField = 'over_under';
let oubSortDir = 'asc';
let oubInitialized = false;
let oubBilledRevenueMap = new Map();
let oubOverbilledChart = null;
let oubUnderbilledChart = null;

async function initOverUnderBilling() {
  if (oubInitialized && oubData.length > 0) {
    updateOverUnderBilling();
    return;
  }
  
  try {
    // Fetch pre-computed job metrics from the canonical metrics API
    const metricsData = await DataCache.getJobsMetrics();
    const jobs = metricsData.jobs || [];
    
    // Build OUB data directly from metrics (already has all calculated values)
    oubData = jobs
      .filter(job => job.job_status === 'A' && job.contract > 0 && job.budget_cost > 0)
      .map(job => ({
        job_no: job.job_no,
        job_description: job.job_description || '',
        project_manager_name: job.project_manager || '',
        job_status: job.job_status || '',
        contract_value: job.contract,
        est_cost: job.budget_cost,
        est_profit: job.profit,
        actual_cost: job.actual_cost,
        pct_complete: job.percent_complete,
        billed: job.billed,
      billed_revenue: job.billed,
        earned_revenue: job.earned_revenue,
        over_under: job.over_under_billing,
      over_under_billing: job.over_under_billing,
        has_budget: job.has_budget,
      valid_for_profit: job.valid_for_profit,
      profit_basis: job.profit_basis
      }));
    
    if (metricsData.generated_at) {
      jobsDataAsOf = new Date(metricsData.generated_at).toLocaleDateString();
    }
    
    populateOubPmTabs();
    setupOubEventListeners();
    updateOverUnderBilling();
    oubInitialized = true;
    
    const dataAsOf = document.getElementById('oubDataAsOf');
    if (dataAsOf && jobsDataAsOf) {
      dataAsOf.textContent = jobsDataAsOf;
    }
  } catch (err) {
    console.error('Error initializing Over/(Under) Billing:', err);
    document.getElementById('oubTableBody').innerHTML = '<tr><td colspan="10" class="error-cell">Error loading data</td></tr>';
  }
}

async function populateOubPmTabs() {
  // Build PM tabs using async loader to ensure PMs are available
  await loadAndBuildPmTabs('oubPmTabs', 'oub', () => {
    oubCurrentPage = 1;
    updateOverUnderBilling();
  });
}

function setupOubEventListeners() {
  // Job search
  const jobSearch = document.getElementById('oubJobSearch');
  if (jobSearch) {
    let searchTimeout;
    jobSearch.addEventListener('input', () => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        oubCurrentPage = 1;
        updateOverUnderBilling();
      }, 300);
    });
  }
  
  // Sort buttons
  document.querySelectorAll('.oub-sort-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const col = btn.dataset.sort;
      const dir = btn.dataset.dir;
      oubSortField = col;
      oubSortDir = dir;
      updateOubSortIndicators();
      updateOverUnderBilling();
    });
  });
  
  // Pagination
  document.getElementById('oubPrevPage')?.addEventListener('click', () => {
    if (oubCurrentPage > 1) {
      oubCurrentPage--;
      renderOubTable();
    }
  });
  
  document.getElementById('oubNextPage')?.addEventListener('click', () => {
    const totalPages = Math.ceil(oubFiltered.length / oubPageSize);
    if (oubCurrentPage < totalPages) {
      oubCurrentPage++;
      renderOubTable();
    }
  });
  
  document.getElementById('oubPageSize')?.addEventListener('change', (e) => {
    oubPageSize = parseInt(e.target.value);
    oubCurrentPage = 1;
    renderOubTable();
  });
}

function updateOubSortIndicators() {
  document.querySelectorAll('.oub-sort-btn').forEach(btn => {
    const isActive = btn.dataset.sort === oubSortField && btn.dataset.dir === oubSortDir;
    btn.classList.toggle('active', isActive);
  });
}

function updateOverUnderBilling() {
  // Apply filters
  const pmFilter = getSelectedPmForPage('oub');
  const jobSearch = (document.getElementById('oubJobSearch')?.value || '').toLowerCase().trim();
  
  oubFiltered = oubData.filter(job => {
    // PM filter
    if (pmFilter && job.project_manager_name !== pmFilter) return false;
    
    // Job search
    if (jobSearch && !job.job_no.toLowerCase().includes(jobSearch)) return false;
    
    return true;
  });
  
  // Sort
  oubFiltered.sort((a, b) => {
    const col = oubSortField;
    let aVal = a[col];
    let bVal = b[col];
    
    // Numeric columns
    if (['contract_value', 'est_cost', 'est_profit', 'actual_cost', 'pct_complete', 'billed_revenue', 'earned_revenue', 'over_under'].includes(col)) {
      aVal = parseFloat(aVal) || 0;
      bVal = parseFloat(bVal) || 0;
    }
    
    if (aVal < bVal) return oubSortDir === 'asc' ? -1 : 1;
    if (aVal > bVal) return oubSortDir === 'asc' ? 1 : -1;
    return 0;
  });
  
  oubCurrentPage = 1;
  renderOubTable();
  updateOubMetrics();
}

function renderOubTable() {
  const tbody = document.getElementById('oubTableBody');
  if (!tbody) return;
  
  const start = (oubCurrentPage - 1) * oubPageSize;
  const end = start + oubPageSize;
  const pageData = oubFiltered.slice(start, end);
  
  if (pageData.length === 0) {
    tbody.innerHTML = '<tr><td colspan="10" class="empty-cell">No jobs found</td></tr>';
    updateOubPagination();
    updateOubTableFooter([]);
    return;
  }
  
  // Calculate totals for the totals row
  const totals = oubFiltered.reduce((acc, job) => {
    acc.contract += job.contract_value;
    acc.estCost += job.est_cost;
    acc.estProfit += job.est_profit;
    acc.actualCost += job.actual_cost;
    acc.billed += job.billed_revenue;
    acc.earned += job.earned_revenue;
    acc.overUnder += job.over_under;
    return acc;
  }, { contract: 0, estCost: 0, estProfit: 0, actualCost: 0, billed: 0, earned: 0, overUnder: 0 });
  
  const totalPctComplete = totals.estCost > 0 ? (totals.actualCost / totals.estCost) * 100 : 0;
  const totalsOverUnderClass = totals.overUnder >= 0 ? 'oub-positive' : 'oub-negative';
  
  // Build totals row first
  const totalsRow = `<tr class="totals-row oub-totals-row">
    <td colspan="2"><strong>Totals (${oubFiltered.length.toLocaleString()} jobs)</strong></td>
    <td class="number-col"><strong>${formatCurrency(totals.contract)}</strong></td>
    <td class="number-col"><strong>${formatCurrency(totals.estCost)}</strong></td>
    <td class="number-col shaded-col"><strong>${formatCurrency(totals.estProfit)}</strong></td>
    <td class="number-col"><strong>${formatCurrency(totals.actualCost)}</strong></td>
    <td class="number-col shaded-col"><strong>${totalPctComplete.toFixed(1)}%</strong></td>
    <td class="number-col"><strong>${formatCurrency(totals.billed)}</strong></td>
    <td class="number-col"><strong>${formatCurrency(totals.earned)}</strong></td>
    <td class="number-col ${totalsOverUnderClass}"><strong>${formatCurrency(totals.overUnder)}</strong></td>
  </tr>`;
  
  // Build data rows
  const dataRows = pageData.map(job => {
    const overUnderClass = job.over_under >= 0 ? 'oub-positive' : 'oub-negative';
    
    return `<tr>
      <td>${job.job_no}</td>
      <td class="desc-col">${job.job_description}</td>
      <td class="number-col">${formatCurrency(job.contract_value)}</td>
      <td class="number-col">${formatCurrency(job.est_cost)}</td>
      <td class="number-col shaded-col">${formatCurrency(job.est_profit)}</td>
      <td class="number-col">${formatCurrency(job.actual_cost)}</td>
      <td class="number-col shaded-col">${job.pct_complete.toFixed(1)}%</td>
      <td class="number-col">${formatCurrency(job.billed_revenue)}</td>
      <td class="number-col">${formatCurrency(job.earned_revenue)}</td>
      <td class="number-col ${overUnderClass}">${formatCurrency(job.over_under)}</td>
    </tr>`;
  }).join('');
  
  tbody.innerHTML = totalsRow + dataRows;
  
  updateOubPagination();
  updateOubTableFooter(oubFiltered);
}

function updateOubPagination() {
  const totalPages = Math.max(1, Math.ceil(oubFiltered.length / oubPageSize));
  
  const pageInfo = document.getElementById('oubPageInfo');
  const prevBtn = document.getElementById('oubPrevPage');
  const nextBtn = document.getElementById('oubNextPage');
  
  if (pageInfo) pageInfo.textContent = `Page ${oubCurrentPage} of ${totalPages}`;
  if (prevBtn) prevBtn.disabled = oubCurrentPage <= 1;
  if (nextBtn) nextBtn.disabled = oubCurrentPage >= totalPages;
}

function updateOubTableFooter(data) {
  const totals = data.reduce((acc, job) => {
    acc.contract += job.contract_value;
    acc.estCost += job.est_cost;
    acc.estProfit += job.est_profit;
    acc.actualCost += job.actual_cost;
    acc.billed += job.billed_revenue;
    acc.earned += job.earned_revenue;
    acc.overUnder += job.over_under;
    return acc;
  }, { contract: 0, estCost: 0, estProfit: 0, actualCost: 0, billed: 0, earned: 0, overUnder: 0 });
  
  // Calculate overall % complete
  const pctComplete = totals.estCost > 0 ? (totals.actualCost / totals.estCost) * 100 : 0;
  
  const footContract = document.getElementById('oubFootContract');
  const footEstCost = document.getElementById('oubFootEstCost');
  const footEstProfit = document.getElementById('oubFootEstProfit');
  const footActualCost = document.getElementById('oubFootActualCost');
  const footPctComplete = document.getElementById('oubFootPctComplete');
  const footBilled = document.getElementById('oubFootBilled');
  const footEarned = document.getElementById('oubFootEarned');
  const footOverUnder = document.getElementById('oubFootOverUnder');
  
  if (footContract) footContract.textContent = formatCurrency(totals.contract);
  if (footEstCost) footEstCost.textContent = formatCurrency(totals.estCost);
  if (footEstProfit) footEstProfit.textContent = formatCurrency(totals.estProfit);
  if (footActualCost) footActualCost.textContent = formatCurrency(totals.actualCost);
  if (footPctComplete) footPctComplete.textContent = pctComplete.toFixed(1) + '%';
  if (footBilled) footBilled.textContent = formatCurrency(totals.billed);
  if (footEarned) footEarned.textContent = formatCurrency(totals.earned);
  if (footOverUnder) {
    footOverUnder.textContent = formatCurrency(totals.overUnder);
    footOverUnder.className = 'number-col ' + (totals.overUnder >= 0 ? 'oub-positive' : 'oub-negative');
  }
}

function updateOubMetrics() {
  const totalJobs = oubFiltered.length;
  const totalContract = oubFiltered.reduce((sum, j) => sum + j.contract_value, 0);
  const totalBilled = oubFiltered.reduce((sum, j) => sum + j.billed_revenue, 0);
  const totalEarned = oubFiltered.reduce((sum, j) => sum + j.earned_revenue, 0);
  const netOverUnder = oubFiltered.reduce((sum, j) => sum + j.over_under, 0);
  
  const elTotalJobs = document.getElementById('oubTotalJobs');
  const elTotalContract = document.getElementById('oubTotalContract');
  const elTotalBilled = document.getElementById('oubTotalBilled');
  const elTotalEarned = document.getElementById('oubTotalEarned');
  const elNetOverUnder = document.getElementById('oubTotalOverUnder');
  const oubOverUnderCard = document.getElementById('oubOverUnderCard');
  
  if (elTotalJobs) elTotalJobs.textContent = totalJobs.toLocaleString();
  if (elTotalContract) elTotalContract.textContent = formatCurrencyCompact(totalContract);
  if (elTotalBilled) elTotalBilled.textContent = formatCurrencyCompact(totalBilled);
  if (elTotalEarned) elTotalEarned.textContent = formatCurrencyCompact(totalEarned);
  if (elNetOverUnder) {
    elNetOverUnder.textContent = formatCurrencyCompact(netOverUnder);
    elNetOverUnder.classList.remove('positive', 'negative');
    elNetOverUnder.classList.add(netOverUnder >= 0 ? 'positive' : 'negative');
  }
  
  // Apply conditional styling to Over/Under card
  if (oubOverUnderCard) {
    oubOverUnderCard.classList.remove('positive', 'negative');
    oubOverUnderCard.classList.add(netOverUnder >= 0 ? 'positive' : 'negative');
  }
  
  // Render the over/under charts
  renderOubCharts();
}

function renderOubCharts() {
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#ffffff' : '#374151';
  const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
  const isMobile = window.innerWidth <= 768;
  const showDataLabels = !isMobile;
  
  // Get top 10 overbilled jobs (over_under > 0, sorted descending)
  const overbilled = oubFiltered
    .filter(j => j.over_under > 0)
    .sort((a, b) => b.over_under - a.over_under)
    .slice(0, 10);
  
  // Get top 10 underbilled jobs (over_under < 0, sorted by most underbilled)
  const underbilled = oubFiltered
    .filter(j => j.over_under < 0)
    .sort((a, b) => a.over_under - b.over_under)
    .slice(0, 10);
  
  console.log('[OUB] Rendering charts - overbilled:', overbilled.length, 'underbilled:', underbilled.length);
  
  // Render overbilled chart
  const overbilledCanvas = document.getElementById('oubOverbilledChart');
  if (overbilledCanvas) {
    if (oubOverbilledChart) oubOverbilledChart.destroy();
    
    const ctx = overbilledCanvas.getContext('2d');
    oubOverbilledChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: overbilled.map(j => j.job_no),
        datasets: [{
          label: 'Overbilled Amount',
          data: overbilled.map(j => j.over_under),
          backgroundColor: function(context) {
            const chart = context.chart;
            const { ctx: canvasCtx, chartArea } = chart;
            if (!chartArea) return 'rgba(5, 150, 105, 0.9)';
            // Green gradient (dark to light) matching waterfall chart
            const gradient = canvasCtx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
            gradient.addColorStop(0, 'rgba(5, 150, 105, 0.9)');
            gradient.addColorStop(1, 'rgba(52, 211, 153, 0.75)');
            return gradient;
          },
          borderRadius: 4,
          barPercentage: 0.8,
          jobData: overbilled
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        indexAxis: 'x',
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              title: (items) => {
                const idx = items[0].dataIndex;
                const job = overbilled[idx];
                return job ? `Job #${job.job_no}` : '';
              },
              label: (ctx) => {
                const job = overbilled[ctx.dataIndex];
                return [
                  job ? job.job_description : '',
                  formatCurrency(ctx.raw)
                ];
              }
            }
          },
          datalabels: {
            display: showDataLabels,
            anchor: 'end',
            align: 'top',
            color: textColor,
            font: { size: 9, weight: 'bold' },
            formatter: (val) => formatCurrencyCompact(val)
          }
        },
        scales: {
          x: {
            ticks: { color: textColor, font: { size: 10 } },
            grid: { display: false }
          },
          y: {
            ticks: {
              color: textColor,
              font: { size: 10 },
              callback: (val) => formatCurrencyCompact(val)
            },
            grid: { color: gridColor }
          }
        }
      },
      plugins: [ChartDataLabels]
    });
  }
  
  // Render underbilled chart (show absolute values, red bars)
  const underbilledCanvas = document.getElementById('oubUnderbilledChart');
  if (underbilledCanvas) {
    if (oubUnderbilledChart) oubUnderbilledChart.destroy();
    
    const ctx = underbilledCanvas.getContext('2d');
    oubUnderbilledChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: underbilled.map(j => j.job_no),
        datasets: [{
          label: 'Underbilled Amount',
          data: underbilled.map(j => Math.abs(j.over_under)),
          backgroundColor: function(context) {
            const chart = context.chart;
            const { ctx: canvasCtx, chartArea } = chart;
            if (!chartArea) return 'rgba(185, 28, 28, 0.9)';
            // Red gradient (dark to light) matching waterfall chart
            const gradient = canvasCtx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
            gradient.addColorStop(0, 'rgba(185, 28, 28, 0.9)');
            gradient.addColorStop(1, 'rgba(248, 113, 113, 0.75)');
            return gradient;
          },
          borderRadius: 4,
          barPercentage: 0.8,
          jobData: underbilled
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        indexAxis: 'x',
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              title: (items) => {
                const idx = items[0].dataIndex;
                const job = underbilled[idx];
                return job ? `Job #${job.job_no}` : '';
              },
              label: (ctx) => {
                const job = underbilled[ctx.dataIndex];
                return [
                  job ? job.job_description : '',
                  formatCurrency(ctx.raw)
                ];
              }
            }
          },
          datalabels: {
            display: showDataLabels,
            anchor: 'end',
            align: 'top',
            color: textColor,
            font: { size: 9, weight: 'bold' },
            formatter: (val) => formatCurrencyCompact(val)
          }
        },
        scales: {
          x: {
            ticks: { color: textColor, font: { size: 10 } },
            grid: { display: false }
          },
          y: {
            ticks: {
              color: textColor,
              font: { size: 10 },
              callback: (val) => formatCurrencyCompact(val)
            },
            grid: { color: gridColor }
          }
        }
      },
      plugins: [ChartDataLabels]
    });
  }
}

// ========================================
// COST CODE ANALYSIS MODULE
// ========================================

let costCodeData = [];
let costCodeFiltered = [];
let ccCurrentPage = 1;
let ccPageSize = 25;
let ccSortField = 'total_cost';
let ccSortDir = 'desc';
let ccMainChart = null;
let ccTopCategoriesChart = null;
let ccTrendChart = null;
let ccQuickFilter = 'all';
let ccFilteredActualsCache = [];
let ccJobActualsRaw = [];

async function initCostCodes() {
  console.log('[CostCodes] Initializing...');
  try {
    // Clear budget lookup cache to ensure fresh data
    ccBudgetLookupCache = null;
    
    // EXCEPTION: Uses raw DataCache.getJobsData() - needs job_actuals line items for cost code breakdown
    // Cannot use metrics API as it only provides job-level aggregates, not cost code detail
    // Always load fresh job data to avoid stale/incomplete data issues
    const data = await DataCache.getJobsData();
    console.log('[CostCodes] Data loaded:', data.job_budgets?.length || 0, 'budgets,', data.job_actuals?.length || 0, 'actuals');
    
    if (data.job_budgets) {
      jobBudgetsData = (data.job_budgets || []).map(job => ({
        ...job,
        original_contract: parseFloat(job.original_contract) || 0,
        tot_income_adj: parseFloat(job.tot_income_adj) || 0,
        revised_contract: parseFloat(job.revised_contract) || parseFloat(job.contract) || 0,
        contract: parseFloat(job.revised_contract) || parseFloat(job.contract) || 0,
        original_cost: parseFloat(job.original_cost) || 0,
        tot_cost_adj: parseFloat(job.tot_cost_adj) || 0,
        revised_cost: parseFloat(job.revised_cost) || parseFloat(job.budget_cost) || 0,
        budget_cost: parseFloat(job.revised_cost) || parseFloat(job.budget_cost) || 0,
        billed: parseFloat(job.billed) || 0,
        billed_revenue: parseFloat(job.billed) || 0,
        actual_cost: parseFloat(job.actual_cost) || 0,
        earned_revenue: parseFloat(job.earned_revenue) || 0,
        has_budget: (parseFloat(job.revised_cost) || parseFloat(job.budget_cost) || 0) > 0,
        profit: (parseFloat(job.revised_contract) || parseFloat(job.contract) || 0) - (parseFloat(job.revised_cost) || parseFloat(job.budget_cost) || 0)
      }));
    }
    
    if (data.job_actuals) {
      // Normalize field names from JSON format to expected format (preserve all original fields)
      // Use ccJobActualsRaw for cost code module (raw line items per cost code)
      // Don't overwrite jobActualsData which is used by PM Report (aggregated job-level data)
      ccJobActualsRaw = (data.job_actuals || []).map(a => ({
        ...a,
        job_no: a.Job_No || a.job_no,
        job_description: a.Job_Description || a.job_description,
        project_manager: a.Project_Manager || a.project_manager,
        cost_code_no: a.Cost_Code_No || a.cost_code_no,
        cost_code_description: a.Cost_Code_Description || a.cost_code_description,
        actual_cost: parseFloat(a.Value || a.actual_cost) || 0
      }));
    }
    
    if (data.generated_at) {
      jobsDataAsOf = new Date(data.generated_at).toLocaleDateString();
    }
    
    // Build PM tabs for Cost Codes page
    await loadAndBuildPmTabs('ccPmTabs', 'cc', () => {
      updateCostCodes();
    });
    
    populateCCFilters();
    setupCCEventListeners();
    updateCostCodes();
  } catch (err) {
    console.error('Error initializing cost codes:', err);
  }
}

// Store available options for CC search filters
let ccCustomerOptions = [];
let ccJobOptions = [];

function populateCCFilters() {
  if (!jobBudgetsData || !Array.isArray(jobBudgetsData)) return;
  
  const pms = [...new Set(jobBudgetsData.map(j => j.project_manager_name).filter(Boolean))].sort();
  ccCustomerOptions = [...new Set(jobBudgetsData.map(j => j.customer_name).filter(Boolean))].sort();
  ccJobOptions = [...new Set(jobBudgetsData.map(j => j.job_no).filter(Boolean))].sort((a, b) => {
    const numA = parseInt(a) || 0;
    const numB = parseInt(b) || 0;
    return numB - numA;
  });
  
  // PM tabs are now used instead of dropdowns, no need to populate PM selects
  
  // Setup search-based filters for Customer and Job in config panel
  setupCCSearchFilter('ccCustomerSearch', 'ccCustomerFilter', 'ccCustomerSuggestions', ccCustomerOptions, 'client');
  setupCCSearchFilter('ccJobSearch', 'ccJobFilter', 'ccJobSuggestions', ccJobOptions, 'job');
}

function setupCCSearchFilter(searchId, hiddenId, suggestionsId, options, type) {
  const searchInput = document.getElementById(searchId);
  const hiddenInput = document.getElementById(hiddenId);
  const suggestionsDiv = document.getElementById(suggestionsId);
  
  if (!searchInput || !hiddenInput || !suggestionsDiv) return;
  
  searchInput.addEventListener('input', debounce(() => {
    const query = searchInput.value.toLowerCase().trim();
    
    if (!query) {
      suggestionsDiv.classList.remove('open');
      return;
    }
    
    let filtered = options.filter(opt => opt.toLowerCase().includes(query)).slice(0, 20);
    
    if (filtered.length === 0) {
      suggestionsDiv.innerHTML = '<div class="search-suggestion-item" style="color:#999;">No matches found</div>';
      suggestionsDiv.classList.add('open');
      return;
    }
    
    let html = '<div class="search-suggestion-item clear-filter" data-value="">Clear filter</div>';
    
    if (type === 'job') {
      html += filtered.map(opt => {
        const budget = jobBudgetsData.find(b => b.job_no === opt);
        const desc = budget ? budget.job_description : '';
        return `<div class="search-suggestion-item" data-value="${opt}">${opt}${desc ? ' - ' + desc.substring(0, 35) : ''}</div>`;
      }).join('');
    } else {
      html += filtered.map(opt => `<div class="search-suggestion-item" data-value="${opt}">${opt}</div>`).join('');
    }
    
    suggestionsDiv.innerHTML = html;
    suggestionsDiv.classList.add('open');
    
    // Add click handlers
    suggestionsDiv.querySelectorAll('.search-suggestion-item').forEach(item => {
      item.addEventListener('click', () => {
        const value = item.dataset.value;
        hiddenInput.value = value;
        searchInput.value = value || '';
        suggestionsDiv.classList.remove('open');
        updateCostCodes();
      });
    });
  }, 200));
  
  // Show suggestions on focus if there's text
  searchInput.addEventListener('focus', () => {
    if (searchInput.value.trim()) {
      searchInput.dispatchEvent(new Event('input'));
    }
  });
  
  // Hide suggestions on blur (with delay for click handling)
  searchInput.addEventListener('blur', () => {
    setTimeout(() => suggestionsDiv.classList.remove('open'), 200);
  });
  
  // Handle Enter key to select first suggestion
  searchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      const firstItem = suggestionsDiv.querySelector('.search-suggestion-item:not(.clear-filter)');
      if (firstItem) {
        hiddenInput.value = firstItem.dataset.value;
        searchInput.value = firstItem.dataset.value;
        suggestionsDiv.classList.remove('open');
        updateCostCodes();
      }
    } else if (e.key === 'Escape') {
      suggestionsDiv.classList.remove('open');
    }
  });
}

function setupCCEventListeners() {
  ['ccStatusActive', 'ccStatusInactive', 'ccStatusClosed', 'ccStatusOverhead'].forEach(id => {
    document.getElementById(id)?.addEventListener('change', updateCostCodes);
  });
  
  // Filter bar Job # search (above table) - updates both chart and table
  document.getElementById('ccJobSearchBar')?.addEventListener('input', debounce(updateCostCodes, 300));
  
  // Filter bar Client search (above table) - updates both chart and table
  document.getElementById('ccClientSearchBar')?.addEventListener('input', debounce(updateCostCodes, 300));
  
  document.querySelectorAll('.cc-sort-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      ccSortField = btn.dataset.sort;
      ccSortDir = btn.dataset.dir;
      updateCCSortIndicators();
      filterAndRenderCC();
    });
  });
  
  document.getElementById('ccPrevPage')?.addEventListener('click', () => {
    if (ccCurrentPage > 1) {
      ccCurrentPage--;
      renderCCTable();
    }
  });
  
  document.getElementById('ccNextPage')?.addEventListener('click', () => {
    const totalPages = ccPageSize === 'all' ? 1 : Math.ceil(costCodeFiltered.length / ccPageSize);
    if (ccCurrentPage < totalPages) {
      ccCurrentPage++;
      renderCCTable();
    }
  });
  
  document.getElementById('ccPageSize')?.addEventListener('change', (e) => {
    ccPageSize = e.target.value === 'all' ? 'all' : parseInt(e.target.value);
    ccCurrentPage = 1;
    renderCCTable();
  });
  
  // Export buttons
  document.getElementById('ccExportCsv')?.addEventListener('click', exportCostCodesCsv);
  document.getElementById('ccExportPdf')?.addEventListener('click', exportCostCodesPdf);
}

function updateCCSortIndicators() {
  document.querySelectorAll('.cc-sort-btn').forEach(btn => {
    btn.classList.remove('active');
    if (btn.dataset.sort === ccSortField && btn.dataset.dir === ccSortDir) {
      btn.classList.add('active');
    }
  });
}

let ccTotalEarnedRevenue = 0;
let ccJobCostCodeData = []; // Job + cost code level data for the table
let ccBudgetLookupCache = null; // Cache for budget lookup
let ccIsProcessing = false;

function updateCostCodes() {
  // Prevent multiple simultaneous updates
  if (ccIsProcessing) return;
  ccIsProcessing = true;
  
  // Show loading state immediately
  const tbody = document.getElementById('costCodesTableBody');
  if (tbody) {
    tbody.innerHTML = '<tr><td colspan="8" class="loading-cell">Processing cost code data...</td></tr>';
  }
  
  // Use requestAnimationFrame to allow UI to update before heavy processing
  requestAnimationFrame(() => {
    setTimeout(() => {
      try {
        updateCostCodesSync();
      } finally {
        ccIsProcessing = false;
      }
    }, 10);
  });
}

function updateCostCodesSync() {
  try {
    if (!ccJobActualsRaw || !Array.isArray(ccJobActualsRaw)) {
      console.log('Cost codes: No actuals data available');
      return;
    }
    
    const dateEl = document.getElementById('costCodesDataAsOf');
    if (dateEl && jobsDataAsOf) {
      dateEl.textContent = jobsDataAsOf;
    }
    
    const statusActive = document.getElementById('ccStatusActive')?.checked;
    const statusInactive = document.getElementById('ccStatusInactive')?.checked;
    const statusClosed = document.getElementById('ccStatusClosed')?.checked;
    const statusOverhead = document.getElementById('ccStatusOverhead')?.checked;
    // Use PM tabs selection instead of dropdown
    const pmFilter = getSelectedPmForPage('cc') || '';
    const customerFilter = (document.getElementById('ccClientSearchBar')?.value || '').trim();
    const jobFilter = (document.getElementById('ccJobSearchBar')?.value || '').trim();
    
    // Build budget lookup once and cache it
    if (!ccBudgetLookupCache && jobBudgetsData) {
      ccBudgetLookupCache = {};
      for (let i = 0; i < jobBudgetsData.length; i++) {
        const b = jobBudgetsData[i];
        ccBudgetLookupCache[b.job_no] = b;
      }
    }
    const budgetLookup = ccBudgetLookupCache || {};
    
    // Pre-compute allowed statuses for faster checking
    const allowedStatuses = new Set();
    if (statusActive) allowedStatuses.add('A');
    if (statusInactive) allowedStatuses.add('I');
    if (statusClosed) allowedStatuses.add('C');
    if (statusOverhead) allowedStatuses.add('O');
    
    // Filter actuals in a single pass with optimized checks
    const filteredActuals = [];
    const jobCosts = {};
    
    for (let i = 0; i < ccJobActualsRaw.length; i++) {
      const a = ccJobActualsRaw[i];
      const budget = budgetLookup[a.job_no];
      if (!budget) continue;
      
      const status = budget.job_status || a.job_status || '';
      if (!allowedStatuses.has(status)) continue;
      if (pmFilter && budget.project_manager_name !== pmFilter) continue;
      // Customer and job filters use partial matching (case-insensitive search)
      if (customerFilter && !(budget.customer_name || '').toLowerCase().includes(customerFilter.toLowerCase())) continue;
      if (jobFilter && !a.job_no.toLowerCase().includes(jobFilter.toLowerCase())) continue;
      
      filteredActuals.push(a);
      
      // Accumulate job costs in same loop
      const cost = parseFloat(a.actual_cost) || 0;
      if (!jobCosts[a.job_no]) jobCosts[a.job_no] = 0;
      jobCosts[a.job_no] += cost;
    }
    
    // Calculate earned revenue
    ccTotalEarnedRevenue = 0;
    const jobEarnedRevenue = {};
    const jobNos = Object.keys(jobCosts);
    for (let i = 0; i < jobNos.length; i++) {
      const jobNo = jobNos[i];
      const budget = budgetLookup[jobNo];
      if (budget && budget.revised_cost > 0 && budget.revised_contract > 0) {
        const pctComplete = jobCosts[jobNo] / budget.revised_cost;
        const earnedRev = pctComplete * budget.revised_contract;
        ccTotalEarnedRevenue += earnedRev;
        jobEarnedRevenue[jobNo] = earnedRev;
      }
    }
    
    // Aggregate by job + cost code for the table (single pass)
    const jobCostCodeMap = {};
    const costCodeMap = {};
    let totalCost = 0;
    
    for (let i = 0; i < filteredActuals.length; i++) {
      const a = filteredActuals[i];
      const jobNo = a.job_no;
      const code = a.cost_code_no || 'Unknown';
      const desc = a.cost_code_description || 'Uncategorized';
      const cost = parseFloat(a.actual_cost) || 0;
      const budget = budgetLookup[jobNo];
      const key = `${jobNo}|${code}`;
      
      // Job + cost code aggregation
      if (!jobCostCodeMap[key]) {
        jobCostCodeMap[key] = {
          job_no: jobNo,
          job_description: budget?.job_description || a.job_description || '',
          project_manager: budget?.project_manager_name || '',
          cost_code: code,
          description: desc,
          total_cost: 0,
          job_earned_revenue: jobEarnedRevenue[jobNo] || 0
        };
      }
      jobCostCodeMap[key].total_cost += cost;
      
      // Cost code aggregation for chart
      if (!costCodeMap[code]) {
        costCodeMap[code] = { cost_code: code, description: desc, total_cost: 0 };
      }
      costCodeMap[code].total_cost += cost;
      
      totalCost += cost;
    }
    
    // Convert to array and calculate percentages
    ccJobCostCodeData = Object.values(jobCostCodeMap);
    for (let i = 0; i < ccJobCostCodeData.length; i++) {
      const item = ccJobCostCodeData[i];
      item.pct_of_revenue = item.job_earned_revenue > 0 ? (item.total_cost / item.job_earned_revenue) * 100 : 0;
    }
    ccJobCostCodeData.sort((a, b) => b.total_cost - a.total_cost);
    
    // Build cost code data for chart
    costCodeData = Object.values(costCodeMap);
    for (let i = 0; i < costCodeData.length; i++) {
      costCodeData[i].pct_of_revenue = ccTotalEarnedRevenue > 0 ? (costCodeData[i].total_cost / ccTotalEarnedRevenue) * 100 : 0;
    }
    costCodeData.sort((a, b) => b.total_cost - a.total_cost);
    
    // Cache filtered actuals
    ccFilteredActualsCache = filteredActuals;
    
    // Update footer total
    const totalCostCell = document.getElementById('ccTotalCostCell');
    if (totalCostCell) totalCostCell.textContent = formatCurrency(totalCost);
    
    renderCCRevenueChart();
    filterAndRenderCC();
    
  } catch (err) {
    console.error('Error updating cost codes:', err);
  }
}

let ccRevenueChart = null;

function renderCCRevenueChart() {
  const ctx = document.getElementById('ccRevenueChart')?.getContext('2d');
  if (!ctx) {
    console.log('[CostCodes] Chart canvas not found');
    return;
  }
  
  console.log('[CostCodes] Rendering chart with', costCodeData.length, 'cost codes, earned revenue:', ccTotalEarnedRevenue);
  
  if (ccRevenueChart) ccRevenueChart.destroy();
  
  // Theme-adaptive colors
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#ffffff' : '#374151';
  const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
  
  const top10 = costCodeData.slice(0, 10);
  const labels = top10.map(cc => cc.description.length > 30 ? cc.description.substring(0, 28) + '...' : cc.description);
  const values = top10.map(cc => cc.pct_of_revenue);
  
  const canvas = document.getElementById('ccRevenueChart');
  const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
  gradient.addColorStop(0, '#1e3a8a');
  gradient.addColorStop(1, '#3b82f6');
  
  ccRevenueChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        label: '% of Revenue',
        data: values,
        backgroundColor: gradient,
        borderRadius: 4,
        maxBarThickness: 50
      }]
    },
    options: {
      indexAxis: 'y',
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: function(context) {
              const cc = top10[context.dataIndex];
              return [`${context.raw.toFixed(1)}% of revenue`, `Cost: ${formatCurrency(cc.total_cost)}`];
            }
          }
        }
      },
      scales: {
        x: {
          beginAtZero: true,
          title: { display: true, text: '% of Revenue', color: textColor },
          ticks: { callback: value => value + '%', color: textColor },
          grid: { color: gridColor }
        },
        y: {
          ticks: { font: { size: 11 }, color: textColor },
          grid: { display: false }
        }
      }
    }
  });
}

function renderCCCharts() {
  const chartType = document.getElementById('ccChartType')?.value || 'bar';
  const top10 = costCodeData.slice(0, 10);
  const labels = top10.map(cc => cc.description.length > 25 ? cc.description.substring(0, 23) + '...' : cc.description);
  const values = top10.map(cc => cc.total_cost);
  const pcts = top10.map(cc => cc.pct_of_total);
  
  // Theme-adaptive colors
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#ffffff' : '#374151';
  const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
  
  const colors = [
    '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6',
    '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1'
  ];
  
  const mainCtx = document.getElementById('ccMainChart')?.getContext('2d');
  if (mainCtx) {
    if (ccMainChart) ccMainChart.destroy();
    
    if (chartType === 'pie' || chartType === 'doughnut') {
      ccMainChart = new Chart(mainCtx, {
        type: chartType,
        data: {
          labels: labels,
          datasets: [{
            data: values,
            backgroundColor: colors,
            borderWidth: 2,
            borderColor: isDark ? '#1e293b' : '#ffffff',
            cutout: chartType === 'doughnut' ? '50%' : 0
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: { boxWidth: 12, font: { size: 11 }, color: textColor }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const value = context.raw;
                  const pct = pcts[context.dataIndex];
                  return `${context.label}: ${formatCurrency(value)} (${pct.toFixed(1)}%)`;
                }
              }
            }
          }
        }
      });
    } else {
      ccMainChart = new Chart(mainCtx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Total Cost',
            data: values,
            backgroundColor: colors,
            borderRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          indexAxis: 'y',
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const pct = pcts[context.dataIndex];
                  return `${formatCurrency(context.raw)} (${pct.toFixed(1)}%)`;
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: textColor,
                callback: function(value) {
                  if (value >= 1000000) return '$' + (value / 1000000).toFixed(1) + 'M';
                  if (value >= 1000) return '$' + (value / 1000).toFixed(0) + 'K';
                  return '$' + value;
                }
              },
              grid: { color: gridColor }
            },
            y: {
              ticks: { font: { size: 11 }, color: textColor },
              grid: { display: false }
            }
          }
        }
      });
    }
  }
  
  const topCtx = document.getElementById('ccTopCategoriesChart')?.getContext('2d');
  if (topCtx) {
    if (ccTopCategoriesChart) ccTopCategoriesChart.destroy();
    
    ccTopCategoriesChart = new Chart(topCtx, {
      type: 'doughnut',
      data: {
        labels: labels,
        datasets: [{
          data: pcts,
          backgroundColor: colors,
          borderWidth: 2,
          borderColor: isDark ? '#1e293b' : '#ffffff'
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '60%',
        plugins: {
          legend: {
            position: 'right',
            labels: { boxWidth: 12, font: { size: 11 }, color: textColor }
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                const idx = context.dataIndex;
                return `${context.label}: ${pcts[idx].toFixed(1)}% (${formatCurrency(values[idx])})`;
              }
            }
          }
        }
      }
    });
  }
}

function renderCCBreakdowns(filteredActuals, budgetLookup, totalCost) {
  const pmMap = {};
  const clientMap = {};
  
  filteredActuals.forEach(a => {
    const budget = budgetLookup[a.job_no];
    if (!budget) return;
    
    const pm = budget.project_manager_name || 'Unknown';
    const client = budget.customer_name || 'Unknown';
    const cost = parseFloat(a.actual_cost) || 0;
    
    if (!pmMap[pm]) pmMap[pm] = { name: pm, total: 0, jobs: new Set() };
    pmMap[pm].total += cost;
    pmMap[pm].jobs.add(a.job_no);
    
    if (!clientMap[client]) clientMap[client] = { name: client, total: 0, jobs: new Set() };
    clientMap[client].total += cost;
    clientMap[client].jobs.add(a.job_no);
  });
  
  const pmData = Object.values(pmMap).sort((a, b) => b.total - a.total).slice(0, 10);
  const clientData = Object.values(clientMap).sort((a, b) => b.total - a.total).slice(0, 10);
  
  const pmBody = document.getElementById('ccPmBreakdownBody');
  if (pmBody) {
    if (pmData.length === 0) {
      pmBody.innerHTML = '<tr><td colspan="4" class="loading-cell">No data</td></tr>';
    } else {
      pmBody.innerHTML = pmData.map(pm => `
        <tr>
          <td>${pm.name}</td>
          <td class="number-col">${pm.jobs.size}</td>
          <td class="number-col">${formatCurrency(pm.total)}</td>
          <td class="number-col">${totalCost > 0 ? ((pm.total / totalCost) * 100).toFixed(1) : 0}%</td>
        </tr>
      `).join('');
    }
  }
  
  const clientBody = document.getElementById('ccClientBreakdownBody');
  if (clientBody) {
    if (clientData.length === 0) {
      clientBody.innerHTML = '<tr><td colspan="4" class="loading-cell">No data</td></tr>';
    } else {
      clientBody.innerHTML = clientData.map(c => `
        <tr>
          <td>${c.name}</td>
          <td class="number-col">${c.jobs.size}</td>
          <td class="number-col">${formatCurrency(c.total)}</td>
          <td class="number-col">${totalCost > 0 ? ((c.total / totalCost) * 100).toFixed(1) : 0}%</td>
        </tr>
      `).join('');
    }
  }
}

function filterAndRenderCC() {
  const jobSearch = (document.getElementById('ccJobSearchBar')?.value || '').toLowerCase().trim();
  const clientSearch = (document.getElementById('ccClientSearchBar')?.value || '').toLowerCase().trim();
  
  // Filter job+cost code level data by job number and client
  costCodeFiltered = ccJobCostCodeData.filter(item => {
    if (jobSearch && !item.job_no.toLowerCase().includes(jobSearch)) return false;
    if (clientSearch && !(item.customer_name || '').toLowerCase().includes(clientSearch)) return false;
    return true;
  });
  
  costCodeFiltered.sort((a, b) => {
    let valA = a[ccSortField];
    let valB = b[ccSortField];
    
    if (typeof valA === 'string') valA = valA.toLowerCase();
    if (typeof valB === 'string') valB = valB.toLowerCase();
    
    if (ccSortDir === 'asc') {
      return valA > valB ? 1 : valA < valB ? -1 : 0;
    } else {
      return valA < valB ? 1 : valA > valB ? -1 : 0;
    }
  });
  
  ccCurrentPage = 1;
  renderCCTable();
}

function renderCCTable() {
  const tbody = document.getElementById('costCodesTableBody');
  if (!tbody) {
    console.log('[CostCodes] Table body not found');
    return;
  }
  
  console.log('[CostCodes] Rendering table with', costCodeFiltered.length, 'items');
  
  if (costCodeFiltered.length === 0) {
    tbody.innerHTML = '<tr><td colspan="8" class="loading-cell">No cost codes found matching your filters</td></tr>';
    updateCCPagination(0);
    return;
  }
  
  // Calculate total cost for the filtered data to use for percentage calculation
  const filteredTotalCost = costCodeFiltered.reduce((sum, item) => sum + item.total_cost, 0);
  
  let displayData;
  let totalPages;
  
  if (ccPageSize === 'all') {
    displayData = costCodeFiltered;
    totalPages = 1;
  } else {
    const start = (ccCurrentPage - 1) * ccPageSize;
    const end = start + ccPageSize;
    displayData = costCodeFiltered.slice(start, end);
    totalPages = Math.ceil(costCodeFiltered.length / ccPageSize);
  }
  
  tbody.innerHTML = displayData.map(item => {
    // Calculate percentage as portion of filtered total cost
    const pctOfTotal = filteredTotalCost > 0 ? (item.total_cost / filteredTotalCost) * 100 : 0;
    // pct_of_revenue is calculated per job's earned revenue
    const pctOfRevenue = item.pct_of_revenue || 0;
    return `
    <tr>
      <td>${escapeHtml(item.job_no)}</td>
      <td>${escapeHtml(item.job_description)}</td>
      <td>${escapeHtml(item.project_manager || '')}</td>
      <td><span class="cc-code-badge">${escapeHtml(item.cost_code)}</span></td>
      <td>${escapeHtml(item.description)}</td>
      <td class="number-col">${formatCurrency(item.total_cost)}</td>
      <td class="number-col">${pctOfTotal.toFixed(2)}%</td>
      <td class="number-col">${pctOfRevenue > 0 ? pctOfRevenue.toFixed(2) + '%' : '—'}</td>
    </tr>
  `}).join('');
  
  updateCCPagination(costCodeFiltered.length);
  updateCCTableTotals(costCodeFiltered);
}

function toggleCCVendorExpand(row) {
  const idx = parseInt(row.dataset.idx);
  const costCode = row.dataset.costcode;
  const cc = costCodeFiltered[idx];
  const icon = row.querySelector('.cc-expand-icon');
  const isExpanded = row.classList.contains('expanded');
  
  // Remove any existing vendor/invoice rows for this cost code
  const existingVendorRows = document.querySelectorAll(`.cc-vendor-row[data-parent="${costCode}"], .cc-invoice-row[data-parent="${costCode}"]`);
  existingVendorRows.forEach(r => r.remove());
  
  if (isExpanded) {
    row.classList.remove('expanded');
    if (icon) icon.textContent = '▶';
    return;
  }
  
  row.classList.add('expanded');
  if (icon) icon.textContent = '▼';
  
  // Insert vendor rows after this row
  const vendorRows = cc.vendorList.map((vendor, vIdx) => {
    const hasInvoices = vendor.entries && vendor.entries.length > 0;
    return `
      <tr class="cc-vendor-row ${hasInvoices ? 'expandable' : ''}" data-parent="${escapeHtml(costCode)}" data-vidx="${vIdx}">
        <td class="cc-expand-cell" style="padding-left: 24px;">
          ${hasInvoices ? '<span class="cc-expand-icon">▶</span>' : ''}
        </td>
        <td colspan="2" style="padding-left: 24px;">
          <span class="cc-vendor-badge">${escapeHtml(vendor.name)}</span>
        </td>
        <td class="number-col">${formatCurrency(vendor.total_cost)}</td>
        <td class="number-col">${ccTotalEarnedRevenue > 0 ? ((vendor.total_cost / ccTotalEarnedRevenue) * 100).toFixed(2) + '%' : '-'}</td>
      </tr>
    `;
  }).join('');
  
  row.insertAdjacentHTML('afterend', vendorRows);
  
  // Add click handlers for vendor rows
  document.querySelectorAll(`.cc-vendor-row[data-parent="${costCode}"].expandable`).forEach(vRow => {
    vRow.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleCCInvoiceExpand(vRow, cc);
    });
  });
}

function toggleCCInvoiceExpand(vRow, cc) {
  const costCode = vRow.dataset.parent;
  const vIdx = parseInt(vRow.dataset.vidx);
  const vendor = cc.vendorList[vIdx];
  const icon = vRow.querySelector('.cc-expand-icon');
  const isExpanded = vRow.classList.contains('expanded');
  
  // Remove any existing invoice rows for this vendor
  const existingInvoiceRows = document.querySelectorAll(`.cc-invoice-row[data-parent="${costCode}"][data-vidx="${vIdx}"]`);
  existingInvoiceRows.forEach(r => r.remove());
  
  if (isExpanded) {
    vRow.classList.remove('expanded');
    if (icon) icon.textContent = '▶';
    return;
  }
  
  vRow.classList.add('expanded');
  if (icon) icon.textContent = '▼';
  
  // Insert invoice rows
  const invoiceRows = vendor.entries.slice(0, 50).map(entry => {
    const date = entry.date || entry.invoice_date || '-';
    const invoiceNo = entry.invoice_no || entry.reference || '-';
    const amount = parseFloat(entry.actual_cost) || 0;
    const jobNo = entry.job_no || '-';
    return `
      <tr class="cc-invoice-row" data-parent="${escapeHtml(costCode)}" data-vidx="${vIdx}">
        <td></td>
        <td style="padding-left: 48px; font-size: 0.85em; color: #666;">
          ${escapeHtml(invoiceNo)} | Job: ${escapeHtml(jobNo)} | ${escapeHtml(date)}
        </td>
        <td></td>
        <td class="number-col" style="font-size: 0.85em;">${formatCurrency(amount)}</td>
        <td></td>
      </tr>
    `;
  }).join('');
  
  if (vendor.entries.length > 50) {
    const moreCount = vendor.entries.length - 50;
    vRow.insertAdjacentHTML('afterend', invoiceRows + `
      <tr class="cc-invoice-row" data-parent="${escapeHtml(costCode)}" data-vidx="${vIdx}">
        <td></td>
        <td colspan="4" style="padding-left: 48px; font-size: 0.85em; color: #999; font-style: italic;">
          ... and ${moreCount} more entries
        </td>
      </tr>
    `);
  } else {
    vRow.insertAdjacentHTML('afterend', invoiceRows);
  }
}

function updateCCPagination(total) {
  const totalPages = ccPageSize === 'all' ? 1 : Math.max(1, Math.ceil(total / ccPageSize));
  
  const pageInfo = document.getElementById('ccPageInfo');
  if (pageInfo) {
    pageInfo.textContent = ccPageSize === 'all' 
      ? `Showing all ${total} categories`
      : `Page ${ccCurrentPage} of ${totalPages}`;
  }
  
  const prevBtn = document.getElementById('ccPrevPage');
  const nextBtn = document.getElementById('ccNextPage');
  
  if (prevBtn) prevBtn.disabled = ccCurrentPage <= 1;
  if (nextBtn) nextBtn.disabled = ccCurrentPage >= totalPages;
}

function updateCCTableTotals(data) {
  let totalCost = 0;
  let totalRevPct = 0;
  const uniqueJobs = new Set();
  
  data.forEach(cc => {
    totalCost += cc.total_cost;
    totalRevPct += cc.pct_of_revenue || 0;
    uniqueJobs.add(cc.job_no);
  });
  
  const totalCostCell = document.getElementById('ccTotalCostCell');
  if (totalCostCell) totalCostCell.textContent = formatCurrency(totalCost);
  
  // Calculate % of Revenue - if single job, sum percentages; otherwise use total cost / total earned revenue
  const totalRevPctCell = document.getElementById('ccTotalRevPctCell');
  if (totalRevPctCell) {
    if (uniqueJobs.size === 1 && totalRevPct > 0) {
      // Single job - sum the percentages (they should add up to the job's total)
      totalRevPctCell.textContent = totalRevPct.toFixed(2) + '%';
    } else if (ccTotalEarnedRevenue > 0 && totalCost > 0) {
      // Multiple jobs - calculate as total cost / total earned revenue
      const revPct = (totalCost / ccTotalEarnedRevenue) * 100;
      totalRevPctCell.textContent = revPct.toFixed(2) + '%';
    } else {
      totalRevPctCell.textContent = '—';
    }
  }
}

function extractCostCodesData() {
  let text = "Cost Code Analysis:\n\n";
  
  const totalCost = costCodeFiltered.reduce((sum, cc) => sum + cc.total_cost, 0);
  text += `Total Cost: ${formatCurrency(totalCost)}\n`;
  text += `Total Earned Revenue: ${formatCurrency(ccTotalEarnedRevenue)}\n`;
  text += `Cost Categories: ${costCodeFiltered.length}\n\n`;
  
  text += "Cost Categories by Spend (with % of Earned Revenue):\n";
  costCodeFiltered.forEach((cc, i) => {
    text += `  ${i + 1}. ${cc.cost_code} - ${cc.description}: ${formatCurrency(cc.total_cost)} (${cc.pct_of_revenue.toFixed(1)}% of revenue)\n`;
  });
  
  return text || "No cost code data available";
}

// Export cost codes to CSV
function exportCostCodesCsv() {
  if (costCodeFiltered.length === 0) {
    alert('No data to export');
    return;
  }
  
  const totalCost = costCodeFiltered.reduce((sum, cc) => sum + cc.total_cost, 0);
  const headers = ['Job #', 'Job Description', 'Cost Code', 'Description', 'Total Cost', '% of Total', '% of Revenue'];
  const rows = costCodeFiltered.map(cc => {
    const pctOfTotal = totalCost > 0 ? (cc.total_cost / totalCost) * 100 : 0;
    return [
      cc.job_no,
      `"${(cc.job_description || '').replace(/"/g, '""')}"`,
      cc.cost_code,
      `"${cc.description.replace(/"/g, '""')}"`,
      cc.total_cost.toFixed(2),
      pctOfTotal.toFixed(2),
      cc.pct_of_revenue > 0 ? cc.pct_of_revenue.toFixed(2) : ''
    ];
  });
  
  const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `cost_codes_${new Date().toISOString().split('T')[0]}.csv`;
  a.click();
  URL.revokeObjectURL(url);
}

// Export cost codes to PDF (print-friendly format)
function exportCostCodesPdf() {
  const printWindow = window.open('', '_blank');
  if (!printWindow) {
    alert('Please allow pop-ups to export PDF');
    return;
  }
  
  const totalCost = costCodeFiltered.reduce((sum, cc) => sum + cc.total_cost, 0);
  
  printWindow.document.write(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Cost Code Analysis Report</title>
      <style>
        body { font-family: 'Inter', Arial, sans-serif; padding: 20px; color: #333; }
        h1 { color: #1e40af; margin-bottom: 5px; }
        .subtitle { color: #6b7280; margin-bottom: 20px; }
        .metrics { display: flex; gap: 20px; margin-bottom: 20px; }
        .metric { background: #f3f4f6; padding: 15px; border-radius: 8px; }
        .metric-label { font-size: 12px; color: #6b7280; }
        .metric-value { font-size: 24px; font-weight: bold; color: #111; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 10px; text-align: left; border-bottom: 1px solid #e5e7eb; }
        th { background: #f9fafb; font-weight: 600; }
        .number-col { text-align: right; }
        .footer { margin-top: 30px; font-size: 12px; color: #9ca3af; }
      </style>
    </head>
    <body>
      <h1>Cost Code Analysis Report</h1>
      <div class="subtitle">Generated on ${new Date().toLocaleDateString()}</div>
      
      <div class="metrics">
        <div class="metric">
          <div class="metric-label">Total Cost</div>
          <div class="metric-value">${formatCurrency(totalCost)}</div>
        </div>
        <div class="metric">
          <div class="metric-label">Earned Revenue</div>
          <div class="metric-value">${formatCurrency(ccTotalEarnedRevenue)}</div>
        </div>
        <div class="metric">
          <div class="metric-label">Categories</div>
          <div class="metric-value">${costCodeFiltered.length}</div>
        </div>
      </div>
      
      <table>
        <thead>
          <tr>
            <th>Job #</th>
            <th>Job Description</th>
            <th>Cost Code</th>
            <th>Description</th>
            <th class="number-col">Total Cost</th>
            <th class="number-col">% of Total</th>
            <th class="number-col">% of Revenue</th>
          </tr>
        </thead>
        <tbody>
          ${costCodeFiltered.map(cc => {
            const pctOfTotal = totalCost > 0 ? (cc.total_cost / totalCost) * 100 : 0;
            return `
            <tr>
              <td>${cc.job_no}</td>
              <td>${cc.job_description || ''}</td>
              <td>${cc.cost_code}</td>
              <td>${cc.description}</td>
              <td class="number-col">${formatCurrency(cc.total_cost)}</td>
              <td class="number-col">${pctOfTotal.toFixed(2)}%</td>
              <td class="number-col">${cc.pct_of_revenue > 0 ? cc.pct_of_revenue.toFixed(2) + '%' : '—'}</td>
            </tr>
          `}).join('')}
        </tbody>
      </table>
      
      <div class="footer">FTG Dashboard - Cost Code Analysis</div>
    </body>
    </html>
  `);
  
  printWindow.document.close();
  setTimeout(() => printWindow.print(), 500);
}

// Render trend chart
function renderCCTrendChart() {
  const canvas = document.getElementById('ccTrendChart');
  if (!canvas) return;
  
  const period = document.getElementById('ccTrendPeriod')?.value || 'monthly';
  const display = document.getElementById('ccTrendDisplay')?.value || 'top5';
  
  if (ccTrendChart) {
    ccTrendChart.destroy();
    ccTrendChart = null;
  }
  
  if (!ccFilteredActualsCache || ccFilteredActualsCache.length === 0) return;
  
  // Group actuals by period and cost code
  const periodData = {};
  const costCodeTotals = {};
  
  ccFilteredActualsCache.forEach(a => {
    const cost = parseFloat(a.actual_cost) || 0;
    const code = a.cost_code_no || 'Unknown';
    const date = a.transaction_date || a.date || '';
    
    if (!date) return;
    
    let periodKey;
    const dateParts = date.split('-');
    if (dateParts.length >= 2) {
      const year = dateParts[0];
      const month = dateParts[1];
      
      if (period === 'yearly') {
        periodKey = year;
      } else if (period === 'quarterly') {
        const quarter = Math.ceil(parseInt(month) / 3);
        periodKey = `${year}-Q${quarter}`;
      } else {
        periodKey = `${year}-${month}`;
      }
    } else {
      periodKey = 'Unknown';
    }
    
    if (!periodData[periodKey]) periodData[periodKey] = {};
    if (!periodData[periodKey][code]) periodData[periodKey][code] = 0;
    periodData[periodKey][code] += cost;
    
    if (!costCodeTotals[code]) costCodeTotals[code] = 0;
    costCodeTotals[code] += cost;
  });
  
  // Get top cost codes
  const sortedCodes = Object.entries(costCodeTotals)
    .sort((a, b) => b[1] - a[1])
    .map(([code]) => code);
  
  const topN = display === 'top10' ? 10 : display === 'top5' ? 5 : 0;
  const codesToShow = display === 'total' ? [] : sortedCodes.slice(0, topN);
  
  // Sort periods chronologically
  const periods = Object.keys(periodData).sort();
  
  // Generate chart colors
  const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1'];
  
  const datasets = [];
  
  if (display === 'total') {
    datasets.push({
      label: 'Total Cost',
      data: periods.map(p => Object.values(periodData[p]).reduce((sum, v) => sum + v, 0)),
      borderColor: colors[0],
      backgroundColor: colors[0] + '20',
      fill: true,
      tension: 0.3
    });
  } else {
    codesToShow.forEach((code, i) => {
      datasets.push({
        label: code,
        data: periods.map(p => periodData[p]?.[code] || 0),
        borderColor: colors[i % colors.length],
        backgroundColor: colors[i % colors.length] + '40',
        tension: 0.3,
        fill: false
      });
    });
  }
  
  // Theme-adaptive colors
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#ffffff' : '#374151';
  const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
  
  ccTrendChart = new Chart(canvas.getContext('2d'), {
    type: 'line',
    data: { labels: periods, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        legend: { position: 'bottom', labels: { boxWidth: 12, padding: 15, color: textColor } },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatCurrency(ctx.raw)}`
          }
        }
      },
      scales: {
        x: {
          ticks: { color: textColor },
          grid: { color: gridColor }
        },
        y: {
          beginAtZero: true,
          ticks: { callback: v => formatCurrency(v), color: textColor },
          grid: { color: gridColor }
        }
      }
    }
  });
}

// Drill-down modal functions
function openCCDrilldownModal(costCode, description) {
  const modal = document.getElementById('ccDrilldownModal');
  if (!modal) return;
  
  document.getElementById('ccModalTitle').textContent = `${costCode} - ${description}`;
  
  // Get jobs for this cost code from cached actuals
  const jobData = {};
  let totalCost = 0;
  let totalEntries = 0;
  
  ccFilteredActualsCache.forEach(a => {
    if (a.cost_code_no !== costCode) return;
    
    const jobNo = a.job_no;
    if (!jobData[jobNo]) {
      const budget = jobBudgetsData?.find(b => b.job_no === jobNo) || {};
      jobData[jobNo] = {
        job_no: jobNo,
        description: budget.job_description || a.job_description || '-',
        client: budget.customer_name || '-',
        pm: budget.project_manager_name || '-',
        entries: 0,
        cost: 0
      };
    }
    
    const cost = parseFloat(a.actual_cost) || 0;
    jobData[jobNo].entries++;
    jobData[jobNo].cost += cost;
    totalCost += cost;
    totalEntries++;
  });
  
  const jobs = Object.values(jobData).sort((a, b) => b.cost - a.cost);
  
  document.getElementById('ccModalTotalCost').textContent = formatCurrency(totalCost);
  document.getElementById('ccModalJobCount').textContent = jobs.length.toLocaleString();
  document.getElementById('ccModalEntryCount').textContent = totalEntries.toLocaleString();
  
  const tbody = document.getElementById('ccModalTableBody');
  if (jobs.length === 0) {
    tbody.innerHTML = '<tr><td colspan="6" class="loading-cell">No jobs found for this cost code</td></tr>';
  } else {
    tbody.innerHTML = jobs.map(job => `
      <tr>
        <td><strong>${escapeHtml(job.job_no)}</strong></td>
        <td>${escapeHtml(job.description)}</td>
        <td>${escapeHtml(job.client)}</td>
        <td>${escapeHtml(job.pm)}</td>
        <td class="number-col">${job.entries.toLocaleString()}</td>
        <td class="number-col">${formatCurrency(job.cost)}</td>
      </tr>
    `).join('');
  }
  
  modal.classList.remove('hidden');
}

function closeCCDrilldownModal() {
  const modal = document.getElementById('ccDrilldownModal');
  if (modal) modal.classList.add('hidden');
}

// ========================================
// ADMIN MODULE
// ========================================

let adminRoles = [];
let adminPermissions = [];
let adminUsers = [];

function getAuthHeaders() {
  const token = getAuthToken();
  return token ? { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' } : { 'Content-Type': 'application/json' };
}

function initAdminModule() {
  // Tab switching
  document.querySelectorAll('.admin-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.admin-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.admin-tab-content').forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      const tabId = tab.dataset.tab;
      document.getElementById(`admin${tabId.charAt(0).toUpperCase() + tabId.slice(1)}Tab`).classList.add('active');
      
      if (tabId === 'users') loadUsers();
      if (tabId === 'roles') loadRoles();
      if (tabId === 'audit') loadAuditLog();
    });
  });
  
  // Add user button
  document.getElementById('addUserBtn')?.addEventListener('click', () => openUserModal());
  
  // User search
  document.getElementById('userSearchInput')?.addEventListener('input', filterUsers);
  
  // Refresh audit button
  document.getElementById('refreshAuditBtn')?.addEventListener('click', loadAuditLog);
  document.getElementById('auditCategoryFilter')?.addEventListener('change', loadAuditLog);
  document.getElementById('auditSeverityFilter')?.addEventListener('change', loadAuditLog);
  document.getElementById('auditSearchInput')?.addEventListener('input', debounce(loadAuditLog, 300));
  
  // Load initial data
  loadRolesForSelect();
  loadUsers();
}

async function loadUsers() {
  const tbody = document.getElementById('usersTableBody');
  tbody.innerHTML = '<tr><td colspan="6" class="loading-cell">Loading users...</td></tr>';
  
  try {
    const resp = await fetch('/api/admin/users', { headers: getAuthHeaders() });
    const data = await resp.json();
    
    if (!data.success) throw new Error(data.error);
    
    adminUsers = data.users;
    renderUsersTable();
  } catch (err) {
    tbody.innerHTML = `<tr><td colspan="6" class="loading-cell">Error: ${err.message}</td></tr>`;
  }
}

function renderUsersTable() {
  const tbody = document.getElementById('usersTableBody');
  const search = document.getElementById('userSearchInput')?.value.toLowerCase() || '';
  
  const filtered = adminUsers.filter(u => 
    u.displayName.toLowerCase().includes(search) || 
    u.email.toLowerCase().includes(search)
  );
  
  if (filtered.length === 0) {
    tbody.innerHTML = '<tr><td colspan="6" class="loading-cell">No users found</td></tr>';
    return;
  }
  
  tbody.innerHTML = filtered.map(u => `
    <tr>
      <td>${escapeHtml(u.displayName)}</td>
      <td>${escapeHtml(u.email)}</td>
      <td><span class="role-badge ${u.roleName || ''}">${u.roleName || 'None'}</span></td>
      <td><span class="status-badge ${u.isActive ? 'active' : 'inactive'}">${u.isActive ? 'Active' : 'Inactive'}</span></td>
      <td>${u.lastLogin ? new Date(u.lastLogin).toLocaleDateString() : 'Never'}</td>
      <td>
        <button class="action-btn edit" onclick="openUserModal(${u.id})">Edit</button>
        <button class="action-btn reset" onclick="resetUserPassword(${u.id})">Reset</button>
        ${u.isActive 
          ? `<button class="action-btn warning" onclick="disableUser(${u.id})">Disable</button>` 
          : `<button class="action-btn success" onclick="enableUser(${u.id})">Enable</button>`}
        <button class="action-btn delete" onclick="deleteUser(${u.id}, '${u.displayName.replace(/'/g, "\\'")}')">Delete</button>
      </td>
    </tr>
  `).join('');
}

function filterUsers() {
  renderUsersTable();
}

function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

async function loadRolesForSelect() {
  try {
    const resp = await fetch('/api/admin/roles', { headers: getAuthHeaders() });
    const data = await resp.json();
    if (data.success) {
      adminRoles = data.roles;
      const select = document.getElementById('userRole');
      if (select) {
        select.innerHTML = '<option value="">Select Role...</option>' + 
          adminRoles.map(r => `<option value="${r.id}">${r.name}</option>`).join('');
      }
    }
  } catch (err) {
    console.error('Failed to load roles:', err);
  }
}

function openUserModal(userId = null) {
  const modal = document.getElementById('userModal');
  const title = document.getElementById('userModalTitle');
  const hint = document.getElementById('passwordHint');
  const error = document.getElementById('userModalError');
  
  error.textContent = '';
  document.getElementById('editUserId').value = userId || '';
  document.getElementById('userDisplayName').value = '';
  document.getElementById('userEmail').value = '';
  document.getElementById('userRole').value = '';
  document.getElementById('userPassword').value = '';
  document.getElementById('userActive').checked = true;
  
  if (userId) {
    title.textContent = 'Edit User';
    hint.style.display = 'block';
    const user = adminUsers.find(u => u.id === userId);
    if (user) {
      document.getElementById('userDisplayName').value = user.displayName;
      document.getElementById('userEmail').value = user.email;
      document.getElementById('userRole').value = user.roleId || '';
      document.getElementById('userActive').checked = user.isActive;
    }
  } else {
    title.textContent = 'Add User';
    hint.style.display = 'none';
  }
  
  modal.classList.remove('hidden');
}

function closeUserModal() {
  document.getElementById('userModal').classList.add('hidden');
}

async function saveUser() {
  const userId = document.getElementById('editUserId').value;
  const error = document.getElementById('userModalError');
  const btn = document.getElementById('saveUserBtn');
  
  const data = {
    displayName: document.getElementById('userDisplayName').value.trim(),
    email: document.getElementById('userEmail').value.trim(),
    roleId: document.getElementById('userRole').value || null,
    isActive: document.getElementById('userActive').checked
  };
  
  const password = document.getElementById('userPassword').value;
  if (password) data.password = password;
  
  if (!data.displayName || !data.email) {
    error.textContent = 'Display name and email are required';
    return;
  }
  
  if (!userId && !password) {
    error.textContent = 'Password is required for new users';
    return;
  }
  
  btn.disabled = true;
  btn.textContent = 'Saving...';
  error.textContent = '';
  
  try {
    const url = userId ? `/api/admin/users/${userId}` : '/api/admin/users';
    const method = userId ? 'PUT' : 'POST';
    
    const resp = await fetch(url, {
      method,
      headers: getAuthHeaders(),
      body: JSON.stringify(data)
    });
    
    const result = await resp.json();
    if (!result.success) throw new Error(result.error);
    
    closeUserModal();
    loadUsers();
  } catch (err) {
    error.textContent = err.message;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Save User';
  }
}

async function resetUserPassword(userId) {
  const newPassword = prompt('Enter new password (min 6 characters):');
  if (!newPassword) return;
  
  if (newPassword.length < 6) {
    alert('Password must be at least 6 characters');
    return;
  }
  
  try {
    const resp = await fetch(`/api/admin/reset-password/${userId}`, {
      method: 'POST',
      headers: getAuthHeaders(),
      body: JSON.stringify({ password: newPassword })
    });
    
    const result = await resp.json();
    if (!result.success) throw new Error(result.error);
    
    alert('Password reset successfully');
  } catch (err) {
    alert('Error: ' + err.message);
  }
}

async function disableUser(userId) {
  if (!confirm('Are you sure you want to disable this user? They will not be able to log in.')) return;
  
  try {
    const resp = await fetch(`/api/admin/users/${userId}`, {
      method: 'PUT',
      headers: getAuthHeaders(),
      body: JSON.stringify({ isActive: false })
    });
    
    const result = await resp.json();
    if (!result.success) throw new Error(result.error);
    
    loadUsers();
  } catch (err) {
    alert('Error: ' + err.message);
  }
}

async function enableUser(userId) {
  try {
    const resp = await fetch(`/api/admin/users/${userId}`, {
      method: 'PUT',
      headers: getAuthHeaders(),
      body: JSON.stringify({ isActive: true })
    });
    
    const result = await resp.json();
    if (!result.success) throw new Error(result.error);
    
    loadUsers();
  } catch (err) {
    alert('Error: ' + err.message);
  }
}

async function deleteUser(userId, displayName) {
  if (!confirm(`Are you sure you want to permanently delete "${displayName}"? This action cannot be undone.`)) return;
  if (!confirm('This will delete all user data including sessions, preferences, and audit history. Continue?')) return;
  
  try {
    const resp = await fetch(`/api/admin/users/${userId}/permanent`, {
      method: 'DELETE',
      headers: getAuthHeaders()
    });
    
    const result = await resp.json();
    if (!result.success) throw new Error(result.error);
    
    alert('User deleted successfully');
    loadUsers();
  } catch (err) {
    alert('Error: ' + err.message);
  }
}

async function loadRoles() {
  const container = document.getElementById('rolesContainer');
  container.innerHTML = '<div class="loading-spinner">Loading roles...</div>';
  
  try {
    const [rolesResp, permsResp] = await Promise.all([
      fetch('/api/admin/roles', { headers: getAuthHeaders() }),
      fetch('/api/admin/permissions', { headers: getAuthHeaders() })
    ]);
    
    const rolesData = await rolesResp.json();
    const permsData = await permsResp.json();
    
    if (!rolesData.success || !permsData.success) throw new Error('Failed to load data');
    
    adminRoles = rolesData.roles;
    adminPermissions = permsData.permissions;
    
    let html = `
      <div class="roles-header">
        <h3>Manage Roles</h3>
        <button class="btn-primary" onclick="openRoleModal()">+ Add Role</button>
      </div>
      <div class="roles-grid">
    `;
    
    for (const role of adminRoles) {
      const rolePermsResp = await fetch(`/api/admin/roles/${role.id}/permissions`, { headers: getAuthHeaders() });
      const rolePermsData = await rolePermsResp.json();
      const rolePerms = rolePermsData.permissions || [];
      
      const isProtected = role.name.toLowerCase() === 'admin';
      
      html += `
        <div class="role-card" data-role-id="${role.id}">
          <div class="role-card-header">
            <div>
              <span class="role-card-title">${escapeHtml(role.name)}</span>
              ${isProtected ? '<span class="role-protected-badge">System Role</span>' : ''}
            </div>
            <div class="role-card-actions">
              <button class="action-btn edit" onclick="openRoleModal(${role.id})">Edit</button>
              ${!isProtected ? `<button class="action-btn delete" onclick="deleteRole(${role.id}, '${escapeHtml(role.name)}')">Delete</button>` : ''}
            </div>
          </div>
          <div class="role-card-description">${escapeHtml(role.description || '')}</div>
          <div class="permissions-grouped">
            ${renderGroupedPermissions(adminPermissions, rolePerms, role.id, 'perm')}
          </div>
        </div>
      `;
    }
    
    html += '</div>';
    container.innerHTML = html;
  } catch (err) {
    container.innerHTML = `<div class="loading-cell">Error: ${err.message}</div>`;
  }
}

async function openRoleModal(roleId = null) {
  const modal = document.getElementById('roleModal');
  const title = document.getElementById('roleModalTitle');
  const error = document.getElementById('roleModalError');
  const grid = document.getElementById('rolePermissionsGrid');
  
  error.textContent = '';
  document.getElementById('editRoleId').value = roleId || '';
  document.getElementById('roleName').value = '';
  document.getElementById('roleDescription').value = '';
  
  // Load permissions if not already loaded
  if (!adminPermissions || adminPermissions.length === 0) {
    try {
      const resp = await fetch('/api/admin/permissions', { headers: getAuthHeaders() });
      const data = await resp.json();
      if (data.success) adminPermissions = data.permissions;
    } catch (err) {
      console.error('Failed to load permissions:', err);
    }
  }
  
  let rolePerms = [];
  
  if (roleId) {
    title.textContent = 'Edit Role';
    const role = adminRoles.find(r => r.id === roleId);
    if (role) {
      document.getElementById('roleName').value = role.name;
      document.getElementById('roleDescription').value = role.description || '';
    }
    
    try {
      const resp = await fetch(`/api/admin/roles/${roleId}/permissions`, { headers: getAuthHeaders() });
      const data = await resp.json();
      if (data.success) rolePerms = data.permissions;
    } catch (err) {
      console.error('Failed to load role permissions:', err);
    }
  } else {
    title.textContent = 'Add Role';
  }
  
  // Render permissions grid with grouping
  grid.innerHTML = renderGroupedPermissions(adminPermissions, rolePerms, null, 'modal_perm');
  
  modal.classList.remove('hidden');
}

function renderGroupedPermissions(permissions, selectedPerms, roleId, prefix) {
  const permissionGroups = {
    'Financials': ['overview', 'ai_insights', 'income_statement', 'balance_sheet', 'cash_flow', 'cash_balances', 'account', 'payments', 'ap_aging', 'ar_aging'],
    'Job Reports': ['job_overview', 'job_budgets', 'job_actuals', 'over_under_billing', 'cost_codes', 'pm_report'],
    'Admin': ['admin']
  };
  
  let html = '';
  
  for (const [groupName, groupKeys] of Object.entries(permissionGroups)) {
    const groupPerms = permissions.filter(p => groupKeys.includes(p.pageKey));
    if (groupPerms.length === 0) continue;
    
    html += `<div class="permission-group">
      <div class="permission-group-title">${escapeHtml(groupName)}</div>
      <div class="permission-group-items">`;
    
    for (const p of groupPerms) {
      const inputId = roleId ? `${prefix}_${roleId}_${p.pageKey}` : `${prefix}_${p.pageKey}`;
      const isChecked = selectedPerms.includes(p.pageKey) ? 'checked' : '';
      const onChangeAttr = roleId ? `onchange="saveRolePermissions(${roleId})"` : '';
      
      html += `
        <div class="permission-item">
          <input type="checkbox" id="${inputId}" ${isChecked} ${onChangeAttr}>
          <label for="${inputId}">${escapeHtml(p.pageName)}</label>
        </div>`;
    }
    
    html += `</div></div>`;
  }
  
  return html;
}

function closeRoleModal() {
  document.getElementById('roleModal').classList.add('hidden');
}

async function saveRole() {
  const roleId = document.getElementById('editRoleId').value;
  const error = document.getElementById('roleModalError');
  const btn = document.getElementById('saveRoleBtn');
  
  const name = document.getElementById('roleName').value.trim();
  const description = document.getElementById('roleDescription').value.trim();
  
  if (!name) {
    error.textContent = 'Role name is required';
    return;
  }
  
  // Collect selected permissions
  const permissions = [];
  adminPermissions.forEach(p => {
    const cb = document.getElementById(`modal_perm_${p.pageKey}`);
    if (cb && cb.checked) {
      permissions.push(p.pageKey);
    }
  });
  
  btn.disabled = true;
  btn.textContent = 'Saving...';
  
  try {
    const url = roleId ? `/api/admin/roles/${roleId}` : '/api/admin/roles';
    const method = roleId ? 'PUT' : 'POST';
    
    const resp = await fetch(url, {
      method,
      headers: getAuthHeaders(),
      body: JSON.stringify({ name, description, permissions })
    });
    
    const result = await resp.json();
    if (!result.success) throw new Error(result.error);
    
    closeRoleModal();
    loadRoles();
    loadRolesForSelect();
  } catch (err) {
    error.textContent = err.message;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Save Role';
  }
}

async function deleteRole(roleId, roleName) {
  if (!confirm(`Are you sure you want to delete the "${roleName}" role?`)) return;
  
  try {
    const resp = await fetch(`/api/admin/roles/${roleId}`, {
      method: 'DELETE',
      headers: getAuthHeaders()
    });
    
    const result = await resp.json();
    
    if (!result.success) {
      if (result.error === 'users_assigned') {
        openReassignModal(roleId, roleName, result.users, result.availableRoles);
        return;
      }
      throw new Error(result.error);
    }
    
    loadRoles();
    loadRolesForSelect();
  } catch (err) {
    alert('Error: ' + err.message);
  }
}

function openReassignModal(roleId, roleName, users, availableRoles) {
  const modal = document.getElementById('roleReassignModal');
  const message = document.getElementById('reassignMessage');
  const usersList = document.getElementById('reassignUsersList');
  const roleSelect = document.getElementById('reassignNewRole');
  const error = document.getElementById('reassignModalError');
  
  document.getElementById('reassignRoleId').value = roleId;
  error.textContent = '';
  
  const userCount = users.length;
  message.innerHTML = `The <strong>"${escapeHtml(roleName)}"</strong> role has <strong>${userCount} user${userCount > 1 ? 's' : ''}</strong> assigned. Please select a new role for them before deleting.`;
  
  usersList.innerHTML = users.map(u => `
    <div class="reassign-user-item">
      <div class="reassign-user-icon">${escapeHtml(u.username.charAt(0).toUpperCase())}</div>
      <span class="reassign-user-name">${escapeHtml(u.username)}</span>
    </div>
  `).join('');
  
  roleSelect.innerHTML = '<option value="">Select new role...</option>' + 
    availableRoles.map(r => `<option value="${r.id}">${escapeHtml(r.name)}</option>`).join('');
  
  modal.classList.remove('hidden');
}

function closeReassignModal() {
  document.getElementById('roleReassignModal').classList.add('hidden');
}

async function confirmReassignAndDelete() {
  const roleId = document.getElementById('reassignRoleId').value;
  const newRoleId = document.getElementById('reassignNewRole').value;
  const error = document.getElementById('reassignModalError');
  const btn = document.getElementById('confirmReassignBtn');
  
  if (!newRoleId) {
    error.textContent = 'Please select a role to reassign users to';
    return;
  }
  
  btn.disabled = true;
  btn.textContent = 'Processing...';
  error.textContent = '';
  
  try {
    const resp = await fetch(`/api/admin/roles/${roleId}/reassign-and-delete`, {
      method: 'POST',
      headers: getAuthHeaders(),
      body: JSON.stringify({ newRoleId: parseInt(newRoleId) })
    });
    
    const result = await resp.json();
    if (!result.success) throw new Error(result.error);
    
    closeReassignModal();
    loadRoles();
    loadRolesForSelect();
    loadUsers();
  } catch (err) {
    error.textContent = err.message;
  } finally {
    btn.disabled = false;
    btn.textContent = 'Reassign & Delete Role';
  }
}

async function saveRolePermissions(roleId) {
  const card = document.querySelector(`.role-card[data-role-id="${roleId}"]`);
  const checkboxes = card.querySelectorAll('input[type="checkbox"]');
  const permissions = [];
  
  checkboxes.forEach(cb => {
    if (cb.checked) {
      const pageKey = cb.id.replace(`perm_${roleId}_`, '');
      permissions.push(pageKey);
    }
  });
  
  try {
    const resp = await fetch(`/api/admin/roles/${roleId}/permissions`, {
      method: 'PUT',
      headers: getAuthHeaders(),
      body: JSON.stringify({ permissions })
    });
    
    const result = await resp.json();
    if (!result.success) throw new Error(result.error);
    
    alert('Permissions saved successfully');
  } catch (err) {
    alert('Error: ' + err.message);
  }
}

async function loadAuditLog() {
  const tbody = document.getElementById('auditLogBody');
  tbody.innerHTML = '<tr><td colspan="7" class="loading-cell">Loading audit log...</td></tr>';
  
  try {
    const category = document.getElementById('auditCategoryFilter')?.value || '';
    const severity = document.getElementById('auditSeverityFilter')?.value || '';
    const search = document.getElementById('auditSearchInput')?.value || '';
    
    let url = '/api/admin/audit-log?limit=100';
    if (category) url += `&category=${encodeURIComponent(category)}`;
    if (severity) url += `&severity=${encodeURIComponent(severity)}`;
    if (search) url += `&search=${encodeURIComponent(search)}`;
    
    const resp = await fetch(url, { headers: getAuthHeaders() });
    const data = await resp.json();
    
    if (!data.success) throw new Error(data.error);
    
    if (data.logs.length === 0) {
      tbody.innerHTML = '<tr><td colspan="7" class="loading-cell">No audit logs found</td></tr>';
      return;
    }
    
    const severityBadge = (sev) => {
      const colors = { info: '#3b82f6', warning: '#f59e0b', critical: '#dc2626' };
      const color = colors[sev] || '#6b7280';
      return `<span style="background: ${color}; color: #fff; padding: 2px 8px; border-radius: 4px; font-size: 11px; text-transform: uppercase;">${sev || 'info'}</span>`;
    };
    
    const categoryLabel = (cat) => {
      const labels = { authentication: 'Auth', security: 'Security', user_management: 'Users', role_management: 'Roles', data_access: 'Data', general: 'General' };
      return labels[cat] || cat || 'General';
    };
    
    tbody.innerHTML = data.logs.map(log => `
      <tr>
        <td>${log.createdAt ? new Date(log.createdAt).toLocaleString('en-US', { timeZone: 'America/Los_Angeles', month: 'short', day: 'numeric', year: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true }) : ''}</td>
        <td>${escapeHtml(categoryLabel(log.category))}</td>
        <td>${severityBadge(log.severity)}</td>
        <td>${escapeHtml(log.userName || 'Unknown')}</td>
        <td>${escapeHtml(log.action)}</td>
        <td>${log.details ? escapeHtml(JSON.stringify(log.details).substring(0, 50)) : ''}</td>
        <td>${escapeHtml(log.ipAddress || '')}</td>
      </tr>
    `).join('');
  } catch (err) {
    tbody.innerHTML = `<tr><td colspan="7" class="loading-cell">Error: ${err.message}</td></tr>`;
  }
}

// Map data-section attributes to permission page_keys
const sectionToPermission = {
  'overview': 'overview',
  'accounts': 'account',
  'incomeStatement': 'income_statement',
  'balanceSheet': 'balance_sheet',
  'cashFlows': 'cash_flow',
  'apAging': 'ap_aging',
  'arAging': 'ar_aging',
  'jobAnalytics': 'job_analytics',
  'jobOverview': 'job_overview',
  'jobBudgets': 'job_budgets',
  'jobActuals': 'job_actuals',
  'overUnderBilling': 'over_under_billing',
  'costCodes': 'cost_codes',
  'missingBudgets': 'missing_budgets',
  'pmReport': 'pm_report',
  'aiInsights': 'ai_insights',
  'payments': 'payments',
  'cashReports': 'cash_balances',
  'admin': 'admin',
  'deptHeadMeeting': 'admin',
  'cashReport': 'admin',
  'monthEndReporting': 'admin'
};

// Order of sections for default page selection
const sectionOrder = [
  'overview', 'incomeStatement', 'balanceSheet', 'cashFlows', 
  'cashReports', 'accounts', 'apAging', 'arAging', 'payments',
  'jobOverview', 'jobBudgets', 'jobActuals', 'overUnderBilling', 'costCodes', 'missingBudgets', 'pmReport', 'jobAnalytics', 'aiInsights'
];

// Check permissions and show/hide nav items based on user role
async function checkAdminAccess() {
  const token = getAuthToken();
  console.log('[DEBUG] checkAdminAccess - token:', token ? 'exists' : 'missing');
  if (!token) {
    // No token - show overview as default for legacy behavior
    showDefaultSection();
    return;
  }
  
  try {
    const resp = await fetch('/api/verify-session', { headers: getAuthHeaders() });
    const data = await resp.json();
    console.log('[DEBUG] verify-session response:', JSON.stringify(data));
    
    if (data.success && data.user) {
      const userPerms = data.user.permissions || [];
      // Case-insensitive admin check
      const userRole = data.user.role || '';
      const isAdmin = userRole.toLowerCase() === 'admin';
      console.log('[DEBUG] userRole:', userRole, 'isAdmin:', isAdmin);
      
      // Get all nav items
      const navItems = document.querySelectorAll('.nav-item[data-section]');
      
      navItems.forEach(navItem => {
        const section = navItem.getAttribute('data-section');
        const permKey = sectionToPermission[section];
        
        if (permKey) {
          // Admin role has all permissions, otherwise check specific permission
          if (isAdmin || userPerms.includes(permKey)) {
            navItem.classList.remove('hidden');
          } else {
            navItem.classList.add('hidden');
          }
        }
      });
      
      // Special handling for admin nav - only visible to admin role
      const adminNavItem = document.getElementById('adminNavItem');
      console.log('[DEBUG] adminNavItem element:', adminNavItem);
      console.log('[DEBUG] adminNavItem classList before:', adminNavItem ? adminNavItem.classList.toString() : 'null');
      if (adminNavItem) {
        if (isAdmin) {
          adminNavItem.classList.remove('hidden');
          console.log('[DEBUG] Removed hidden class from adminNavItem');
        } else {
          adminNavItem.classList.add('hidden');
          console.log('[DEBUG] Added hidden class to adminNavItem');
        }
        console.log('[DEBUG] adminNavItem classList after:', adminNavItem.classList.toString());
      }
      
      // Special handling for Distribution Reports section - only visible to admin role
      const distReportsSection = document.getElementById('distReportsSection');
      if (distReportsSection) {
        if (isAdmin) {
          distReportsSection.classList.remove('hidden');
          console.log('[DEBUG] Removed hidden class from distReportsSection');
        } else {
          distReportsSection.classList.add('hidden');
          console.log('[DEBUG] Added hidden class to distReportsSection');
        }
      }
      
      // Store permissions for later use (in memory and localStorage for page refresh)
      window.userPermissions = userPerms;
      window.isAdminUser = isAdmin;
      window.userRole = userRole;
      
      // Cache admin status and display name in localStorage for immediate access on page refresh
      localStorage.setItem("ftg_is_admin", isAdmin ? "true" : "false");
      localStorage.setItem("ftg_user_role", userRole);
      
      // Store display name for greeting and user display
      if (data.user.displayName) {
        localStorage.setItem("ftg_display_name", data.user.displayName);
        // Update current user display in header
        const currentUserEl = document.getElementById("currentUser");
        if (currentUserEl) {
          currentUserEl.textContent = data.user.displayName;
        }
        // Update greeting if visible
        if (typeof updateGreeting === 'function') {
          updateGreeting();
        }
      }
      
      // Navigate to the appropriate default page based on permissions
      navigateToDefaultPage(userRole, userPerms, isAdmin);
    } else {
      // Session invalid - but preserve cached admin status for display continuity
      console.log('[DEBUG] Session invalid but checking cached admin status');
      const cachedIsAdmin = localStorage.getItem("ftg_is_admin") === "true";
      if (cachedIsAdmin) {
        window.isAdminUser = true;
        const adminNavItem = document.getElementById('adminNavItem');
        if (adminNavItem) {
          adminNavItem.classList.remove('hidden');
          console.log('[DEBUG] Session invalid - Preserved admin nav from cache');
        }
        const distReportsSection = document.getElementById('distReportsSection');
        if (distReportsSection) {
          distReportsSection.classList.remove('hidden');
          console.log('[DEBUG] Session invalid - Preserved dist reports nav from cache');
        }
      }
      showDefaultSection();
    }
  } catch (err) {
    console.error('[DEBUG] Failed to check permissions:', err);
    // On error, preserve cached admin status and show default section
    const cachedIsAdmin = localStorage.getItem("ftg_is_admin") === "true";
    console.log('[DEBUG] Error catch - cachedIsAdmin:', cachedIsAdmin);
    if (cachedIsAdmin) {
      window.isAdminUser = true;
      const adminNavItem = document.getElementById('adminNavItem');
      if (adminNavItem) {
        adminNavItem.classList.remove('hidden');
        console.log('[DEBUG] Error catch - Preserved admin nav visibility from cache');
      }
      const distReportsSection = document.getElementById('distReportsSection');
      if (distReportsSection) {
        distReportsSection.classList.remove('hidden');
        console.log('[DEBUG] Error catch - Preserved dist reports nav from cache');
      }
    }
    showDefaultSection();
  }
}

// Fallback function to show overview when permission check fails or for non-authenticated users
function showDefaultSection() {
  const overviewEl = document.getElementById('overview');
  const overviewNav = document.querySelector('.nav-item[data-section="overview"]');
  
  if (overviewEl) {
    overviewEl.classList.add('visible');
    initOverviewModule();
    loadFinancialCharts();
  }
  if (overviewNav) {
    overviewNav.classList.add('active');
  }
  
  // Also check if we have stored admin status from a previous successful auth
  if (window.isAdminUser) {
    const adminNavItem = document.getElementById('adminNavItem');
    if (adminNavItem) adminNavItem.classList.remove('hidden');
  }
}

function navigateToDefaultPage(userRole, userPerms, isAdmin) {
  // Determine which section to show
  let targetSection = null;
  
  // Role-based default landing pages
  const roleLower = userRole.toLowerCase();
  if (roleLower === 'project_manager' && (isAdmin || userPerms.includes('job_overview'))) {
    // Project Managers default to Job Overview
    targetSection = 'jobOverview';
  } else if (roleLower === 'manager' && (isAdmin || userPerms.includes('job_budgets'))) {
    // Managers default to Job Budgets
    targetSection = 'jobBudgets';
  } else if (isAdmin) {
    // Admins default to overview
    targetSection = 'overview';
  } else {
    // For everyone else, find the first permitted section
    for (const section of sectionOrder) {
      const permKey = sectionToPermission[section];
      if (permKey && userPerms.includes(permKey)) {
        targetSection = section;
        break;
      }
    }
  }
  
  if (targetSection) {
    // Navigate to the target section
    const sections = document.querySelectorAll('.dashboard-section');
    const navItems = document.querySelectorAll('.nav-item[data-section]');
    
    // Remove visible from all sections
    sections.forEach(s => s.classList.remove('visible'));
    navItems.forEach(i => i.classList.remove('active'));
    
    // Activate target section
    const targetEl = document.getElementById(targetSection);
    const targetNav = document.querySelector(`.nav-item[data-section="${targetSection}"]`);
    
    if (targetEl) targetEl.classList.add('visible');
    if (targetNav) targetNav.classList.add('active');
    
    // Hide export ribbon on admin page
    const exportArea = document.querySelector('.content-export-area');
    if (exportArea) {
      exportArea.style.display = targetSection === 'admin' ? 'none' : '';
    }
    
    // Expand parent nav if needed
    const finStatementsParent = document.getElementById("navFinancialStatements");
    const finStatementsChildren = document.getElementById("navFinancialStatementsChildren");
    const jobsParent = document.getElementById("navJobs");
    const jobsChildren = document.getElementById("navJobsChildren");
    
    const fsChildren = ['overview', 'revenue', 'incomeStatement', 'balanceSheet', 'cashFlows', 'cashReports', 'accounts', 'payments', 'apAging', 'arAging'];
    const jobsChildItems = ['jobOverview', 'jobBudgets', 'jobActuals', 'overUnderBilling', 'costCodes', 'missingBudgets', 'pmReport', 'jobAnalytics'];
    
    if (fsChildren.includes(targetSection) && finStatementsParent && finStatementsChildren) {
      finStatementsParent.classList.add("expanded");
      finStatementsChildren.classList.add("expanded");
    }
    
    if (jobsChildItems.includes(targetSection) && jobsParent && jobsChildren) {
      jobsParent.classList.add("expanded");
      jobsChildren.classList.add("expanded");
    }
    
    // Initialize the section if needed - comprehensive list matching nav click handlers
    if (targetSection === "overview") {
      initOverviewModule();
      loadFinancialCharts();
    }
    if (targetSection === "revenue") initRevenueModule();
    if (targetSection === "accounts") initAccountModule();
    if (targetSection === "incomeStatement") loadIncomeStatement();
    if (targetSection === "balanceSheet") initBalanceSheet();
    if (targetSection === "cashFlows") loadCashFlowStatement();
    if (targetSection === "cashReports") initCashReports();
    if (targetSection === "cashReport") initCashReport();
    if (targetSection === "jobOverview") initJobOverview();
    if (targetSection === "jobBudgets") initJobBudgets();
    if (targetSection === "jobActuals") initJobActuals();
    if (targetSection === "overUnderBilling") initOverUnderBilling();
    if (targetSection === "costCodes") initCostCodes();
    if (targetSection === "missingBudgets") initMissingBudgets();
    if (targetSection === "payments") initPayments();
    if (targetSection === "apAging") initApAging();
    if (targetSection === "arAging") initArAging();
    if (targetSection === "admin") initAdminModule();
  }
  
  // Show admin nav item if user is admin
  if (isAdmin) {
    const adminNavItem = document.getElementById('adminNavItem');
    if (adminNavItem) adminNavItem.classList.remove('hidden');
  }
}

// Update initNavigation to handle admin section
const originalInitNav = initNavigation;
initNavigation = function() {
  originalInitNav();
  
  // Add admin section handler
  const adminNavItem = document.getElementById('adminNavItem');
  if (adminNavItem) {
    adminNavItem.addEventListener('click', () => {
      initAdminModule();
    });
  }
  
  // Check admin access on load
  console.log('Calling checkAdminAccess from initNavigation');
  checkAdminAccess();
  
  // Fallback: Re-check admin nav visibility after a delay to handle any race conditions
  setTimeout(() => {
    const cachedIsAdmin = localStorage.getItem("ftg_is_admin") === "true";
    const adminNav = document.getElementById('adminNavItem');
    console.log('[DEBUG] Fallback check - cachedIsAdmin:', cachedIsAdmin, 'adminNav:', adminNav);
    if (cachedIsAdmin && adminNav && adminNav.classList.contains('hidden')) {
      console.log('[DEBUG] Fallback: Forcing admin nav to show');
      adminNav.classList.remove('hidden');
    }
  }, 500);
};

/* ============================================================
   PAYMENTS MODULE (Optimized - Server-side pagination)
============================================================ */
let paymentsInitialized = false;
let paymentsCurrentPage = 1;
let paymentsPageSize = 25;
let paymentsSortColumn = 'invoice_date';
let paymentsSortDirection = 'desc';
let paymentsColumnFilters = {};
let paymentsVendorSearch = '';
let paymentsInvoiceSearch = '';
let paymentsJobSearch = '';
let paymentsPmFilter = '';
let paymentsTotal = 0;
let topVendorsChart = null;
let paymentsYearData = null;
let paymentsTotalPages = 1;
let paymentsFilterValuesCache = {};

function initPayments() {
  const loadingOverlay = document.getElementById('paymentsLoadingOverlay');
  if (loadingOverlay) loadingOverlay.classList.remove('hidden');
  
  // Show skeleton loading in table (10 visible columns when collapsed)
  const tbody = document.getElementById('paymentsTableBody');
  if (tbody) {
    tbody.innerHTML = Array(10).fill().map(() => `
      <tr class="skeleton-row">
        <td><div class="skeleton-text"></div></td>
        <td><div class="skeleton-text"></div></td>
        <td><div class="skeleton-text"></div></td>
        <td><div class="skeleton-text"></div></td>
        <td><div class="skeleton-text"></div></td>
        <td><div class="skeleton-text"></div></td>
        <td><div class="skeleton-text"></div></td>
        <td><div class="skeleton-text"></div></td>
        <td><div class="skeleton-text"></div></td>
        <td><div class="skeleton-text"></div></td>
      </tr>
    `).join('');
  }
  
  // Initialize event handlers only once
  if (!paymentsInitialized) {
    initPaymentsEventHandlers();
    initPaymentsColumnFiltersOptimized();
    initPaymentsYearRangeSlider();
    paymentsInitialized = true;
  }
  
  // Load top vendors chart
  loadTopVendorsChart();
  
  // Apply My PM View filter (sync, before loading data)
  if (getMyPmViewEnabled() && isUserProjectManager()) {
    const pmName = getCurrentUserPmName();
    if (pmName) {
      // Set the column filter for server-side filtering
      paymentsColumnFilters['project_manager'] = new Set([pmName]);
      // Update the filter button indicator
      const filterBtn = document.querySelector('#paymentsTable .filter-btn[data-filter="project_manager"]');
      if (filterBtn) filterBtn.classList.add('has-filter');
    }
  }
  
  // Load first page of data
  loadPaymentsPage();
  
  const dataAsOf = document.getElementById('paymentsDataAsOf');
  if (dataAsOf) {
    const now = new Date();
    dataAsOf.textContent = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  }
}

function loadPaymentsPage(retryCount = 0) {
  const loadingOverlay = document.getElementById('paymentsLoadingOverlay');
  if (loadingOverlay) loadingOverlay.classList.remove('hidden');
  
  // Build query params
  const params = new URLSearchParams({
    page: paymentsCurrentPage,
    pageSize: paymentsPageSize,
    sortColumn: paymentsSortColumn,
    sortDirection: paymentsSortDirection
  });
  
  // Add individual search filters
  if (paymentsJobSearch) params.set('job', paymentsJobSearch);
  if (paymentsVendorSearch) params.set('vendor', paymentsVendorSearch);
  if (paymentsInvoiceSearch) params.set('invoice', paymentsInvoiceSearch);
  if (paymentsPmFilter) params.set('pm', paymentsPmFilter);
  
  // Add column filters
  const activeFilters = {};
  for (const [col, values] of Object.entries(paymentsColumnFilters)) {
    if (values && values.size > 0) {
      activeFilters[col] = Array.from(values);
    }
  }
  if (Object.keys(activeFilters).length > 0) {
    params.set('filters', JSON.stringify(activeFilters));
  }
  
  fetch(`/api/payments?${params.toString()}`)
    .then(r => {
      if (!r.ok) throw new Error('Network response not ok');
      return r.json();
    })
    .then(data => {
      paymentsTotal = data.total || 0;
      paymentsTotalPages = data.totalPages || 1;
      renderPaymentsTableFromServer(data.payments || [], data.totals || {});
      if (loadingOverlay) loadingOverlay.classList.add('hidden');
    })
    .catch(err => {
      console.error('Error loading payments:', err);
      // Retry up to 2 times with delay
      if (retryCount < 2) {
        setTimeout(() => loadPaymentsPage(retryCount + 1), 500);
        return;
      }
      const tbody = document.getElementById('paymentsTableBody');
      if (tbody) {
        tbody.innerHTML = `<tr><td colspan="9" class="error-cell">Error loading payment data. <button onclick="loadPaymentsPage()" class="retry-btn">Retry</button></td></tr>`;
      }
      paymentsTotal = 0;
      paymentsTotalPages = 1;
      const pageInfo = document.getElementById('paymentsPageInfo');
      if (pageInfo) pageInfo.textContent = 'Error loading data';
      if (loadingOverlay) loadingOverlay.classList.add('hidden');
    });
}

function updatePaymentsKeyMetricsFromServer(metrics) {
  const countEl = document.getElementById('paymentsTotalCount');
  const amountEl = document.getElementById('paymentsTotalAmount');
  const vendorsEl = document.getElementById('paymentsUniqueVendors');
  const paidEl = document.getElementById('paymentsTotalPaid');
  const remainingEl = document.getElementById('paymentsTotalRemaining');
  
  if (countEl) countEl.textContent = (metrics.totalCount || 0).toLocaleString();
  if (amountEl) amountEl.textContent = formatCurrency(metrics.totalInvoiceAmount || 0);
  if (vendorsEl) vendorsEl.textContent = (metrics.uniqueVendors || 0).toLocaleString();
  if (paidEl) paidEl.textContent = formatCurrency(metrics.totalPaid || 0);
  if (remainingEl) remainingEl.textContent = formatCurrency(metrics.totalRemaining || 0);
}

function getPaymentDisplayStatus(p) {
  const remaining = p.remaining_balance || 0;
  const retention = p.retention || 0;
  if (p.status === 'Paid') return { status: 'Paid', class: 'status-paid' };
  if (remaining > 0 && retention > 0 && Math.abs(remaining - retention) < 0.01) {
    return { status: 'Retention Due', class: 'status-retention-due' };
  }
  return { status: p.status || '-', class: '' };
}

function renderPaymentsTableFromServer(payments, totals) {
  const tbody = document.getElementById('paymentsTableBody');
  if (!tbody) return;
  
  totals = totals || {};
  
  // Subtotal row (appears first, after header)
  const subtotalRow = `<tr class="totals-row">
    <td colspan="6"><strong>Totals (${paymentsTotal.toLocaleString()} invoices)</strong></td>
    <td class="number-col retention-col"><strong>${formatCurrency(totals.non_retention || 0)}</strong></td>
    <td class="number-col retention-col"><strong>${formatCurrency(totals.retention || 0)}</strong></td>
    <td class="number-col"><strong>${formatCurrency(totals.invoice_amount || 0)}</strong></td>
    <td class="number-col"><strong>${formatCurrency(totals.paid_to_date || 0)}</strong></td>
    <td class="number-col"><strong>${formatCurrency(totals.remaining_balance || 0)}</strong></td>
    <td></td>
  </tr>`;
  
  if (payments.length === 0) {
    tbody.innerHTML = subtotalRow + '<tr><td colspan="12" class="no-data-cell">No invoices found</td></tr>';
  } else {
    const dataRows = payments.map(p => {
      const displayStatus = getPaymentDisplayStatus(p);
      return `
      <tr>
        <td>${escapeHtml(p.vendor || '-')}</td>
        <td>${escapeHtml(p.invoice_no || '-')}</td>
        <td>${escapeHtml(p.invoice_date || '-')}</td>
        <td>${escapeHtml(p.job_no || '-')}</td>
        <td>${escapeHtml(p.job_description || '-')}</td>
        <td>${escapeHtml(p.project_manager || '-')}</td>
        <td class="number-col retention-col">${formatCurrency(p.non_retention)}</td>
        <td class="number-col retention-col">${formatCurrency(p.retention)}</td>
        <td class="number-col">${formatCurrency(p.invoice_amount)}</td>
        <td class="number-col">${formatCurrency(p.paid_to_date)}</td>
        <td class="number-col">${formatCurrency(p.remaining_balance)}</td>
        <td class="${displayStatus.class}">${escapeHtml(displayStatus.status)}</td>
      </tr>
    `}).join('');
    tbody.innerHTML = subtotalRow + dataRows;
  }
  
  if (typeof applyPaymentsColumnVisibility === 'function') {
    applyPaymentsColumnVisibility();
  }
  
  const pageInfo = document.getElementById('paymentsPageInfo');
  const prevBtn = document.getElementById('paymentsPrevPage');
  const nextBtn = document.getElementById('paymentsNextPage');
  
  if (pageInfo) pageInfo.textContent = `Page ${paymentsCurrentPage} of ${paymentsTotalPages} (${paymentsTotal.toLocaleString()} records)`;
  if (prevBtn) prevBtn.disabled = paymentsCurrentPage <= 1;
  if (nextBtn) nextBtn.disabled = paymentsCurrentPage >= paymentsTotalPages;
}

function initPaymentsColumnFiltersOptimized() {
  const filterableColumns = ['vendor', 'invoice_no', 'job_no', 'job_description', 'project_manager', 'status'];
  const columnLabels = {
    'vendor': 'Vendor',
    'invoice_no': 'Invoice #',
    'job_no': 'Job #',
    'job_description': 'Description',
    'project_manager': 'Project Manager',
    'status': 'Status'
  };
  
  filterableColumns.forEach(col => {
    const dropdown = document.querySelector(`#paymentsTable .column-filter-dropdown[data-filter="${col}"]`);
    if (!dropdown) return;
    
    paymentsColumnFilters[col] = new Set();
    
    dropdown.innerHTML = `
      <input type="text" class="filter-search-input" placeholder="Search ${columnLabels[col] || col}..." data-filter="${col}">
      <div class="filter-quick-links">
        <span class="filter-quick-link" data-action="select-all">Select All</span>
        <span class="filter-quick-link" data-action="clear-all">Clear All</span>
      </div>
      <div class="filter-options-list">
        <div class="filter-loading">Loading values...</div>
      </div>
      <div class="filter-actions">
        <button class="filter-ok-btn" data-filter="${col}">OK</button>
        <button class="filter-cancel-btn" data-filter="${col}">Cancel</button>
      </div>
    `;
  });
}

function excelDateToDate(excelDate) {
  if (!excelDate || isNaN(excelDate)) return null;
  const date = new Date((excelDate - 25569) * 86400 * 1000);
  return date;
}

function formatPaymentDate(date) {
  if (!date || !(date instanceof Date) || isNaN(date)) return '-';
  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
}

function initPaymentsYearRangeSlider() {
  const startSlider = document.getElementById('payYearStart');
  const endSlider = document.getElementById('payYearEnd');
  const startLabel = document.getElementById('payYearStartLabel');
  const endLabel = document.getElementById('payYearEndLabel');
  
  if (!startSlider || !endSlider) return;
  
  // Fetch available years from the server
  fetch('/api/payments/years')
    .then(r => r.json())
    .then(data => {
      const years = data.years || [2020, 2021, 2022, 2023, 2024, 2025];
      const minYear = Math.min(...years);
      const maxYear = Math.max(...years);
      
      startSlider.min = endSlider.min = minYear;
      startSlider.max = endSlider.max = maxYear;
      startSlider.value = minYear;
      endSlider.value = maxYear;
      
      if (startLabel) startLabel.textContent = minYear;
      if (endLabel) endLabel.textContent = maxYear;
    })
    .catch(() => {
      // Use defaults if API fails
      if (startLabel) startLabel.textContent = startSlider.value;
      if (endLabel) endLabel.textContent = endSlider.value;
    });
  
  startSlider.oninput = () => {
    if (+startSlider.value > +endSlider.value) startSlider.value = endSlider.value;
    if (startLabel) startLabel.textContent = startSlider.value;
  };
  
  endSlider.oninput = () => {
    if (+endSlider.value < +startSlider.value) endSlider.value = startSlider.value;
    if (endLabel) endLabel.textContent = endSlider.value;
  };
  
  startSlider.onchange = () => loadTopVendorsChart();
  endSlider.onchange = () => loadTopVendorsChart();
}

function loadTopVendorsChart(retryCount = 0) {
  const startSlider = document.getElementById('payYearStart');
  const endSlider = document.getElementById('payYearEnd');
  const startYear = startSlider ? +startSlider.value : 2015;
  const endYear = endSlider ? +endSlider.value : 2025;
  
  fetch(`/api/payments/top-vendors?startYear=${startYear}&endYear=${endYear}`)
    .then(r => {
      if (!r.ok) throw new Error('Network response not ok');
      return r.json();
    })
    .then(data => {
      renderTopVendorsChart(data.vendors || []);
    })
    .catch(err => {
      console.error('Error loading top vendors:', err);
      // Retry up to 2 times with delay
      if (retryCount < 2) {
        setTimeout(() => loadTopVendorsChart(retryCount + 1), 500);
      }
    });
}

function renderTopVendorsChart(vendors) {
  const canvas = document.getElementById('topVendorsChart');
  if (!canvas) return;
  
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#ffffff' : '#374151';
  const gridColor = isDark ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.1)';
  
  if (topVendorsChart) topVendorsChart.destroy();
  
  // Calculate max value rounded up to next $5M increment
  const maxValue = vendors.length > 0 ? Math.max(...vendors.map(v => v.total)) : 0;
  const xAxisMax = Math.ceil(maxValue / 5000000) * 5000000;
  
  const ctx = canvas.getContext('2d');
  topVendorsChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: vendors.map(v => v.vendor.length > 25 ? v.vendor.substring(0, 25) + '...' : v.vendor),
      datasets: [{
        label: 'Total Spend',
        data: vendors.map(v => v.total),
        backgroundColor: '#3b82f6',
        borderRadius: 4,
        barPercentage: 0.7
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      indexAxis: 'y',
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            title: (items) => {
              const idx = items[0].dataIndex;
              return vendors[idx] ? vendors[idx].vendor : '';
            },
            label: (ctx) => formatCurrency(ctx.raw)
          }
        },
        datalabels: {
          display: true,
          anchor: 'end',
          align: 'right',
          color: textColor,
          font: { size: 10, weight: 'bold' },
          formatter: (val) => formatCurrencyCompact(val)
        }
      },
      scales: {
        x: {
          max: xAxisMax,
          ticks: {
            color: textColor,
            font: { size: 10 },
            callback: (val) => formatCurrencyCompact(val)
          },
          grid: { color: gridColor }
        },
        y: {
          ticks: { color: textColor, font: { size: 10 } },
          grid: { display: false }
        }
      }
    },
    plugins: [ChartDataLabels]
  });
}

function initPaymentsEventHandlers() {
  // Job # search filter
  const jobSearch = document.getElementById('payJobSearch');
  if (jobSearch) {
    jobSearch.addEventListener('input', debounce(() => {
      paymentsJobSearch = jobSearch.value.toLowerCase().trim();
      paymentsCurrentPage = 1;
      loadPaymentsPage();
    }, 400));
  }
  
  // Vendor search filter
  const vendorSearch = document.getElementById('payVendorSearch');
  if (vendorSearch) {
    vendorSearch.addEventListener('input', debounce(() => {
      paymentsVendorSearch = vendorSearch.value.toLowerCase().trim();
      paymentsCurrentPage = 1;
      loadPaymentsPage();
    }, 400));
  }
  
  // Invoice # search filter
  const invoiceSearch = document.getElementById('payInvoiceSearch');
  if (invoiceSearch) {
    invoiceSearch.addEventListener('input', debounce(() => {
      paymentsInvoiceSearch = invoiceSearch.value.toLowerCase().trim();
      paymentsCurrentPage = 1;
      loadPaymentsPage();
    }, 400));
  }
  
  // PM dropdown filter
  const pmFilter = document.getElementById('payPmFilter');
  if (pmFilter) {
    pmFilter.addEventListener('change', () => {
      paymentsPmFilter = pmFilter.value;
      paymentsCurrentPage = 1;
      loadPaymentsPage();
    });
  }
  
  document.querySelectorAll('#paymentsTable .sort-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const col = btn.dataset.sort;
      const dir = btn.dataset.dir;
      paymentsSortColumn = col;
      paymentsSortDirection = dir;
      updatePaymentsSortIndicators();
      paymentsCurrentPage = 1;
      loadPaymentsPage();
    });
  });
  
  document.querySelectorAll('#paymentsTable .filter-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const filterCol = btn.dataset.filter;
      const dropdown = document.querySelector(`#paymentsTable .column-filter-dropdown[data-filter="${filterCol}"]`);
      if (dropdown) {
        closeAllPaymentsFilterDropdowns();
        dropdown.classList.toggle('open');
        if (dropdown.classList.contains('open')) {
          positionFilterDropdown(btn, dropdown);
          loadPaymentsFilterValues(filterCol, dropdown);
        }
        const searchInputEl = dropdown.querySelector('.filter-search-input');
        if (searchInputEl) searchInputEl.focus();
      }
    });
  });
  
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.column-filter-dropdown') && !e.target.closest('.filter-btn')) {
      closeAllPaymentsFilterDropdowns();
    }
  });
  
  const prevBtn = document.getElementById('paymentsPrevPage');
  const nextBtn = document.getElementById('paymentsNextPage');
  const pageSizeSelect = document.getElementById('paymentsPageSize');
  
  if (prevBtn) prevBtn.addEventListener('click', () => {
    if (paymentsCurrentPage > 1) {
      paymentsCurrentPage--;
      loadPaymentsPage();
    }
  });
  
  if (nextBtn) nextBtn.addEventListener('click', () => {
    if (paymentsCurrentPage < paymentsTotalPages) {
      paymentsCurrentPage++;
      loadPaymentsPage();
    }
  });
  
  if (pageSizeSelect) pageSizeSelect.addEventListener('change', () => {
    paymentsPageSize = parseInt(pageSizeSelect.value);
    paymentsCurrentPage = 1;
    loadPaymentsPage();
  });
  
  initPaymentsColumnPicker();
  populatePaymentsPmFilter();
}

function populatePaymentsPmFilter() {
  // Fetch unique PM values from server
  fetch('/api/payments/pms')
    .then(r => r.json())
    .then(pms => {
      const pmSelect = document.getElementById('payPmFilter');
      if (pmSelect && Array.isArray(pms)) {
        pmSelect.innerHTML = '<option value="">All Project Managers</option>' + 
          pms.map(pm => `<option value="${pm}">${pm}</option>`).join('');
      }
    })
    .catch(err => console.error('Error loading PM list:', err));
}

const paymentsColumnConfig = [
  { id: 'vendor', label: 'Vendor', required: false },
  { id: 'invoice_no', label: 'Invoice #', required: false },
  { id: 'invoice_date', label: 'Invoice Date', required: false },
  { id: 'job_no', label: 'Job #', required: false },
  { id: 'job_description', label: 'Job Description', required: false },
  { id: 'project_manager', label: 'Project Manager', required: false },
  { id: 'non_retention', label: 'Non-Retention', required: true },
  { id: 'retention', label: 'Retention', required: true },
  { id: 'invoice_amount', label: 'Invoice Amount', required: true },
  { id: 'paid_to_date', label: 'Paid to Date', required: false },
  { id: 'remaining_balance', label: 'Remaining Balance', required: false },
  { id: 'status', label: 'Status', required: false }
];

let paymentsVisibleColumns = null;

function getPaymentsVisibleColumns() {
  if (paymentsVisibleColumns) return paymentsVisibleColumns;
  
  const saved = localStorage.getItem('ftg_payments_visible_columns');
  if (saved) {
    try {
      paymentsVisibleColumns = new Set(JSON.parse(saved));
    } catch (e) {
      paymentsVisibleColumns = new Set(paymentsColumnConfig.map(c => c.id));
    }
  } else {
    paymentsVisibleColumns = new Set(paymentsColumnConfig.map(c => c.id));
  }
  return paymentsVisibleColumns;
}

function savePaymentsVisibleColumns() {
  localStorage.setItem('ftg_payments_visible_columns', JSON.stringify([...paymentsVisibleColumns]));
}

function initPaymentsColumnPicker() {
  const btn = document.getElementById('paymentsColumnPickerBtn');
  const dropdown = document.getElementById('paymentsColumnPickerDropdown');
  const body = document.getElementById('paymentsColumnPickerBody');
  const closeBtn = document.getElementById('paymentsColumnPickerClose');
  const resetBtn = document.getElementById('paymentsColumnPickerReset');
  const applyBtn = document.getElementById('paymentsColumnPickerApply');
  
  if (!btn || !dropdown || !body) return;
  
  getPaymentsVisibleColumns();
  applyPaymentsColumnVisibility();
  
  body.innerHTML = paymentsColumnConfig.map(col => `
    <div class="column-picker-item ${col.required ? 'disabled' : ''}" data-col="${col.id}">
      <input type="checkbox" id="col-pick-${col.id}" ${paymentsVisibleColumns.has(col.id) ? 'checked' : ''} ${col.required ? 'disabled' : ''}>
      <label for="col-pick-${col.id}">${col.label}${col.required ? ' (required)' : ''}</label>
    </div>
  `).join('');
  
  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    dropdown.classList.toggle('open');
  });
  
  closeBtn.addEventListener('click', () => {
    dropdown.classList.remove('open');
  });
  
  resetBtn.addEventListener('click', () => {
    paymentsVisibleColumns = new Set(paymentsColumnConfig.map(c => c.id));
    body.querySelectorAll('input[type="checkbox"]').forEach(cb => {
      cb.checked = true;
    });
  });
  
  applyBtn.addEventListener('click', () => {
    paymentsVisibleColumns.clear();
    body.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
      const item = cb.closest('.column-picker-item');
      if (item && item.dataset.col) {
        paymentsVisibleColumns.add(item.dataset.col);
      }
    });
    paymentsColumnConfig.filter(c => c.required).forEach(c => {
      paymentsVisibleColumns.add(c.id);
    });
    savePaymentsVisibleColumns();
    applyPaymentsColumnVisibility();
    dropdown.classList.remove('open');
  });
  
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.column-picker-container')) {
      dropdown.classList.remove('open');
    }
  });
}

function applyPaymentsColumnVisibility() {
  const table = document.getElementById('paymentsTable');
  if (!table) return;
  
  const visibleCols = getPaymentsVisibleColumns();
  
  paymentsColumnConfig.forEach((col, idx) => {
    const isVisible = visibleCols.has(col.id);
    const headerCells = table.querySelectorAll(`thead th:nth-child(${idx + 1})`);
    const bodyCells = table.querySelectorAll(`tbody td:nth-child(${idx + 1})`);
    
    headerCells.forEach(cell => {
      cell.style.display = isVisible ? '' : 'none';
    });
    bodyCells.forEach(cell => {
      cell.style.display = isVisible ? '' : 'none';
    });
  });
}

// ========================================
// JOB BUDGETS COLUMN PICKER
// ========================================

const budgetsColumnConfig = [
  { id: 'job_no', label: 'Job #', required: true },
  { id: 'job_description', label: 'Description', required: false },
  { id: 'customer_name', label: 'Client', required: false },
  { id: 'job_status', label: 'Status', required: false },
  { id: 'project_manager_name', label: 'Project Manager', required: false },
  { id: 'original_contract', label: 'Original Contract', required: false },
  { id: 'change_orders', label: 'Change Orders', required: false },
  { id: 'revised_contract', label: 'Revised Contract', required: false },
  { id: 'original_cost', label: 'Original Cost', required: false },
  { id: 'cost_adjustments', label: 'Cost Adjustments', required: false },
  { id: 'revised_cost', label: 'Revised Cost', required: false },
  { id: 'profit', label: 'Estimated Profit', required: false }
];

let budgetsVisibleColumns = null;

function getBudgetsVisibleColumns() {
  if (budgetsVisibleColumns) return budgetsVisibleColumns;
  
  const saved = localStorage.getItem('ftg_budgets_visible_columns');
  if (saved) {
    try {
      budgetsVisibleColumns = new Set(JSON.parse(saved));
    } catch (e) {
      budgetsVisibleColumns = new Set(budgetsColumnConfig.map(c => c.id));
    }
  } else {
    budgetsVisibleColumns = new Set(budgetsColumnConfig.map(c => c.id));
  }
  return budgetsVisibleColumns;
}

function saveBudgetsVisibleColumns() {
  localStorage.setItem('ftg_budgets_visible_columns', JSON.stringify([...budgetsVisibleColumns]));
}

function initBudgetsColumnPicker() {
  const btn = document.getElementById('budgetsColumnPickerBtn');
  const dropdown = document.getElementById('budgetsColumnPickerDropdown');
  const body = document.getElementById('budgetsColumnPickerBody');
  const closeBtn = document.getElementById('budgetsColumnPickerClose');
  const resetBtn = document.getElementById('budgetsColumnPickerReset');
  const applyBtn = document.getElementById('budgetsColumnPickerApply');
  
  if (!btn || !dropdown || !body) return;
  
  getBudgetsVisibleColumns();
  applyBudgetsColumnVisibility();
  
  body.innerHTML = budgetsColumnConfig.map(col => `
    <div class="column-picker-item ${col.required ? 'disabled' : ''}" data-col="${col.id}">
      <input type="checkbox" id="budgets-col-pick-${col.id}" ${budgetsVisibleColumns.has(col.id) ? 'checked' : ''} ${col.required ? 'disabled' : ''}>
      <label for="budgets-col-pick-${col.id}">${col.label}${col.required ? ' (required)' : ''}</label>
    </div>
  `).join('');
  
  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    dropdown.classList.toggle('open');
  });
  
  closeBtn.addEventListener('click', () => {
    dropdown.classList.remove('open');
  });
  
  resetBtn.addEventListener('click', () => {
    budgetsVisibleColumns = new Set(budgetsColumnConfig.map(c => c.id));
    body.querySelectorAll('input[type="checkbox"]').forEach(cb => {
      cb.checked = true;
    });
  });
  
  applyBtn.addEventListener('click', () => {
    budgetsVisibleColumns.clear();
    body.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
      const item = cb.closest('.column-picker-item');
      if (item && item.dataset.col) {
        budgetsVisibleColumns.add(item.dataset.col);
      }
    });
    budgetsColumnConfig.filter(c => c.required).forEach(c => {
      budgetsVisibleColumns.add(c.id);
    });
    saveBudgetsVisibleColumns();
    applyBudgetsColumnVisibility();
    dropdown.classList.remove('open');
  });
}

function applyBudgetsColumnVisibility() {
  // All columns are now always visible - no column picker functionality
  const table = document.getElementById('jobBudgetsTable');
  if (!table) return;
  
  // Show all columns
  budgetsColumnConfig.forEach((col, idx) => {
    const headerCells = table.querySelectorAll(`thead th:nth-child(${idx + 1})`);
    const bodyCells = table.querySelectorAll(`tbody td:nth-child(${idx + 1})`);
    
    headerCells.forEach(cell => {
      cell.style.display = '';
    });
    bodyCells.forEach(cell => {
      cell.style.display = '';
    });
  });
}

// ========================================
// JOB ACTUALS COLUMN PICKER
// ========================================

const actualsColumnConfig = [
  { id: 'job_no', label: 'Job #', required: true },
  { id: 'job_description', label: 'Description', required: false },
  { id: 'customer_name', label: 'Client', required: false },
  { id: 'job_status', label: 'Status', required: false },
  { id: 'project_manager_name', label: 'Project Manager', required: false },
  { id: 'revised_contract', label: 'Revised Contract', required: false },
  { id: 'revised_cost', label: 'Revised Cost', required: false },
  { id: 'actual_cost', label: 'Actual Cost', required: false },
  { id: 'percent_complete', label: '% Complete', required: false },
  { id: 'earned_revenue', label: 'Earned Revenue', required: false },
  { id: 'billed_revenue', label: 'Billed Revenue', required: false },
  { id: 'over_under', label: 'Over/(Under)', required: false },
  { id: 'actual_profit', label: 'Actual Profit', required: false },
  { id: 'actual_margin', label: 'Actual Margin', required: false }
];

let actualsVisibleColumns = null;

function getActualsVisibleColumns() {
  if (actualsVisibleColumns) return actualsVisibleColumns;
  
  const saved = localStorage.getItem('ftg_actuals_visible_columns');
  if (saved) {
    try {
      actualsVisibleColumns = new Set(JSON.parse(saved));
    } catch (e) {
      actualsVisibleColumns = new Set(actualsColumnConfig.map(c => c.id));
    }
  } else {
    actualsVisibleColumns = new Set(actualsColumnConfig.map(c => c.id));
  }
  return actualsVisibleColumns;
}

function saveActualsVisibleColumns() {
  localStorage.setItem('ftg_actuals_visible_columns', JSON.stringify([...actualsVisibleColumns]));
}

function initActualsColumnPicker() {
  const btn = document.getElementById('actualsColumnPickerBtn');
  const dropdown = document.getElementById('actualsColumnPickerDropdown');
  const body = document.getElementById('actualsColumnPickerBody');
  const closeBtn = document.getElementById('actualsColumnPickerClose');
  const resetBtn = document.getElementById('actualsColumnPickerReset');
  const applyBtn = document.getElementById('actualsColumnPickerApply');
  
  if (!btn || !dropdown || !body) return;
  
  getActualsVisibleColumns();
  applyActualsColumnVisibility();
  
  body.innerHTML = actualsColumnConfig.map(col => `
    <div class="column-picker-item ${col.required ? 'disabled' : ''}" data-col="${col.id}">
      <input type="checkbox" id="actuals-col-pick-${col.id}" ${actualsVisibleColumns.has(col.id) ? 'checked' : ''} ${col.required ? 'disabled' : ''}>
      <label for="actuals-col-pick-${col.id}">${col.label}${col.required ? ' (required)' : ''}</label>
    </div>
  `).join('');
  
  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    dropdown.classList.toggle('open');
  });
  
  closeBtn.addEventListener('click', () => {
    dropdown.classList.remove('open');
  });
  
  resetBtn.addEventListener('click', () => {
    actualsVisibleColumns = new Set(actualsColumnConfig.map(c => c.id));
    body.querySelectorAll('input[type="checkbox"]').forEach(cb => {
      cb.checked = true;
    });
  });
  
  applyBtn.addEventListener('click', () => {
    actualsVisibleColumns.clear();
    body.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
      const item = cb.closest('.column-picker-item');
      if (item && item.dataset.col) {
        actualsVisibleColumns.add(item.dataset.col);
      }
    });
    actualsColumnConfig.filter(c => c.required).forEach(c => {
      actualsVisibleColumns.add(c.id);
    });
    saveActualsVisibleColumns();
    applyActualsColumnVisibility();
    dropdown.classList.remove('open');
  });
}

function applyActualsColumnVisibility() {
  // All columns are now always visible - no column picker functionality
  const table = document.getElementById('jobActualsTable');
  if (!table) return;
  
  // Show all columns
  actualsColumnConfig.forEach((col, idx) => {
    const headerCells = table.querySelectorAll(`thead th:nth-child(${idx + 1})`);
    const bodyCells = table.querySelectorAll(`tbody td:nth-child(${idx + 1})`);
    
    headerCells.forEach(cell => {
      cell.style.display = '';
    });
    bodyCells.forEach(cell => {
      cell.style.display = '';
    });
  });
}

function loadPaymentsFilterValues(col, dropdown) {
  if (paymentsFilterValuesCache[col]) {
    populatePaymentsFilterDropdown(col, dropdown, paymentsFilterValuesCache[col]);
    return;
  }
  
  const optionsList = dropdown.querySelector('.filter-options-list');
  if (optionsList) optionsList.innerHTML = '<div class="filter-loading">Loading...</div>';
  
  fetch(`/api/payments/filter-values?column=${encodeURIComponent(col)}`)
    .then(r => r.json())
    .then(data => {
      if (data.success) {
        paymentsFilterValuesCache[col] = data.values;
        populatePaymentsFilterDropdown(col, dropdown, data.values);
      }
    })
    .catch(err => {
      console.error('Error loading filter values:', err);
      if (optionsList) optionsList.innerHTML = '<div class="filter-error">Error loading values</div>';
    });
}

function populatePaymentsFilterDropdown(col, dropdown, values) {
  const optionsList = dropdown.querySelector('.filter-options-list');
  if (!optionsList) return;
  
  const currentFilter = paymentsColumnFilters[col] || new Set();
  const hasActiveFilter = currentFilter.size > 0;
  
  function renderFilteredOptions(searchTerm = '') {
    const searchVal = searchTerm.toLowerCase();
    const filteredValues = searchVal 
      ? values.filter(val => String(val).toLowerCase().includes(searchVal))
      : values;
    
    const displayValues = filteredValues.slice(0, 200);
    const remaining = filteredValues.length - displayValues.length;
    
    optionsList.innerHTML = displayValues.map(val => {
      const isChecked = hasActiveFilter ? currentFilter.has(val) : true;
      return `
        <label class="filter-option">
          <input type="checkbox" value="${escapeHtml(val)}" ${isChecked ? 'checked' : ''}>
          <span class="filter-option-text">${escapeHtml(val) || '(empty)'}</span>
        </label>
      `;
    }).join('') + (remaining > 0 ? `<div class="filter-truncated-notice">${remaining} more values not shown. Use search to narrow down.</div>` : '');
  }
  
  renderFilteredOptions();
  
  const searchInput = dropdown.querySelector('.filter-search-input');
  if (searchInput) {
    searchInput.onclick = (e) => e.stopPropagation();
    searchInput.oninput = () => {
      renderFilteredOptions(searchInput.value);
    };
  }
  
  const selectAllLink = dropdown.querySelector('.filter-quick-link[data-action="select-all"]');
  const clearAllLink = dropdown.querySelector('.filter-quick-link[data-action="clear-all"]');
  const okBtn = dropdown.querySelector('.filter-ok-btn');
  const cancelBtn = dropdown.querySelector('.filter-cancel-btn');
  
  if (selectAllLink) {
    selectAllLink.onclick = (e) => {
      e.stopPropagation();
      dropdown.querySelectorAll('.filter-option input').forEach(cb => cb.checked = true);
    };
  }
  
  if (clearAllLink) {
    clearAllLink.onclick = (e) => {
      e.stopPropagation();
      dropdown.querySelectorAll('.filter-option input').forEach(cb => cb.checked = false);
    };
  }
  
  if (okBtn) {
    okBtn.onclick = (e) => {
      e.stopPropagation();
      collectPaymentsColumnFilter(col, dropdown);
      closeAllPaymentsFilterDropdowns();
      paymentsCurrentPage = 1;
      loadPaymentsPage();
    };
  }
  
  if (cancelBtn) {
    cancelBtn.onclick = (e) => {
      e.stopPropagation();
      closeAllPaymentsFilterDropdowns();
    };
  }
}

function collectPaymentsColumnFilter(col, dropdown) {
  const checkedValues = new Set();
  dropdown?.querySelectorAll('.filter-option input:checked').forEach(cb => {
    checkedValues.add(cb.value);
  });
  
  const allValues = new Set();
  dropdown?.querySelectorAll('.filter-option input').forEach(cb => {
    allValues.add(cb.value);
  });
  
  if (checkedValues.size === allValues.size || checkedValues.size === 0) {
    paymentsColumnFilters[col] = new Set();
  } else {
    paymentsColumnFilters[col] = checkedValues;
  }
  
  updatePaymentsFilterIndicator(col);
}

function updatePaymentsFilterIndicator(col) {
  const btn = document.querySelector(`#paymentsTable .filter-btn[data-filter="${col}"]`);
  if (btn) {
    const hasFilter = paymentsColumnFilters[col] && paymentsColumnFilters[col].size > 0;
    btn.classList.toggle('has-filter', hasFilter);
  }
}

function closeAllPaymentsFilterDropdowns() {
  document.querySelectorAll('#paymentsTable .column-filter-dropdown.open').forEach(d => {
    d.classList.remove('open');
    d.style.position = '';
    d.style.top = '';
    d.style.left = '';
  });
}

function updatePaymentsSortIndicators() {
  document.querySelectorAll('#paymentsTable .sort-btn').forEach(btn => {
    btn.classList.remove('active');
    if (btn.dataset.sort === paymentsSortColumn && btn.dataset.dir === paymentsSortDirection) {
      btn.classList.add('active');
    }
  });
}

function escapeHtml(str) {
  if (str === null || str === undefined) return '';
  return String(str).replace(/[&<>"']/g, m => ({
    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
  }[m]));
}

function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/* ------------------------------------------------------------
   AP AGING REPORT
------------------------------------------------------------ */
let apAgingInitialized = false;
let apAgingSortColumn = 'days_90_plus';
let apAgingSortDirection = 'desc';
let apAgingSearchTerm = '';
let apAgingJobSearchTerm = '';
let apAgingChart = null;

async function initApAging() {
  if (!apAgingInitialized) {
    setupApAgingEventHandlers();
    apAgingInitialized = true;
  }
  
  // Load PM tabs for AP Aging page
  await loadAndBuildPmTabs('apAgingPmTabs', 'apa', () => {
    loadApAgingData();
  });
  
  loadApAgingData();
  
  const now = new Date();
  const dateStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  
  const dataAsOf = document.getElementById('apAgingDataAsOf');
  if (dataAsOf) dataAsOf.textContent = dateStr;
  
  const chartDate = document.getElementById('apAgingChartDate');
  if (chartDate) chartDate.textContent = dateStr;
}

function setupApAgingEventHandlers() {
  const searchInput = document.getElementById('apAgingSearch');
  if (searchInput) {
    searchInput.addEventListener('input', debounce(() => {
      apAgingSearchTerm = searchInput.value.trim();
      loadApAgingData();
    }, 300));
  }
  
  const jobSearchInput = document.getElementById('apAgingJobSearch');
  if (jobSearchInput) {
    jobSearchInput.addEventListener('input', debounce(() => {
      apAgingJobSearchTerm = jobSearchInput.value.trim();
      loadApAgingData();
    }, 300));
  }
  
  const table = document.getElementById('apAgingTable');
  if (table) {
    table.querySelectorAll('.sort-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const col = btn.dataset.sort;
        const dir = btn.dataset.dir;
        apAgingSortColumn = col;
        apAgingSortDirection = dir;
        updateApAgingSortIndicators();
        loadApAgingData();
      });
    });
  }
}

function loadApAgingData() {
  const loadingOverlay = document.getElementById('apAgingLoadingOverlay');
  if (loadingOverlay) loadingOverlay.classList.remove('hidden');
  
  const params = new URLSearchParams({
    sortColumn: apAgingSortColumn,
    sortDirection: apAgingSortDirection
  });
  
  if (apAgingSearchTerm) {
    params.set('search', apAgingSearchTerm);
  }
  if (apAgingJobSearchTerm) {
    params.set('job', apAgingJobSearchTerm);
  }
  
  // Add PM filter from tabs
  const pmFilter = getSelectedPmForPage('apa');
  if (pmFilter) {
    params.set('pm', pmFilter);
  }
  
  fetch(`/api/ap-aging?${params.toString()}`)
    .then(r => r.json())
    .then(data => {
      if (data.success) {
        renderApAgingTable(data.vendors || [], data.totals || {});
        updateApAgingSummary(data.totals || {});
      } else {
        showApAgingError('Failed to load AP aging data');
      }
      if (loadingOverlay) loadingOverlay.classList.add('hidden');
    })
    .catch(err => {
      console.error('Error loading AP aging:', err);
      showApAgingError('Error loading AP aging data');
      if (loadingOverlay) loadingOverlay.classList.add('hidden');
    });
}

// Track expanded vendors
const apAgingExpandedVendors = new Set();

function renderApAgingTable(vendors, totals) {
  const tbody = document.getElementById('apAgingTableBody');
  if (!tbody) return;
  
  totals = totals || {};
  
  // Filter out vendors with total_due under $1,000
  const filteredVendors = (vendors || []).filter(v => Math.abs(v.total_due || 0) >= 1000);
  
  // Totals row at top (after header)
  const totalsRow = `<tr class="totals-row">
    <td><strong>Totals (${filteredVendors.length} vendors)</strong></td>
    <td class="text-right"><strong>${formatCurrency(totals.total_due || 0)}</strong></td>
    <td class="text-right"><strong>${formatCurrency(totals.current || 0)}</strong></td>
    <td class="text-right"><strong>${formatCurrency(totals.days_31_60 || 0)}</strong></td>
    <td class="text-right"><strong>${formatCurrency(totals.days_61_90 || 0)}</strong></td>
    <td class="text-right"><strong>${formatCurrency(totals.days_90_plus || 0)}</strong></td>
    <td class="text-right"><strong>${formatCurrency(totals.retainage || 0)}</strong></td>
  </tr>`;
  
  if (!filteredVendors || filteredVendors.length === 0) {
    tbody.innerHTML = totalsRow + '<tr><td colspan="7" class="empty-cell">No outstanding AP balances found</td></tr>';
    return;
  }
  
  const dataRows = filteredVendors.map((v, idx) => `
    <tr class="ap-vendor-row" data-vendor="${escapeHtml(v.vendor_name)}" data-idx="${idx}">
      <td>
        <span class="ap-expand-toggle" title="Click to expand">
          <svg class="ap-expand-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="9 18 15 12 9 6"></polyline>
          </svg>
        </span>
        <span class="vendor-name">${escapeHtml(v.vendor_name)}</span>
      </td>
      <td class="text-right">${formatCurrency(v.total_due)}</td>
      <td class="text-right">${formatCurrency(v.current)}</td>
      <td class="text-right">${formatCurrency(v.days_31_60)}</td>
      <td class="text-right">${formatCurrency(v.days_61_90)}</td>
      <td class="text-right ${v.days_90_plus > 0 ? 'negative' : ''}">${formatCurrency(v.days_90_plus)}</td>
      <td class="text-right">${formatCurrency(v.retainage)}</td>
    </tr>
    <tr class="ap-invoice-container" id="ap-invoices-${idx}" style="display: none;">
      <td colspan="7" class="ap-invoice-cell">
        <div class="ap-invoice-loading">Loading invoices...</div>
      </td>
    </tr>
  `).join('');
  
  tbody.innerHTML = totalsRow + dataRows;
  
  // Add click handlers for expandable rows
  tbody.querySelectorAll('.ap-vendor-row').forEach(row => {
    row.addEventListener('click', () => {
      const vendorName = row.dataset.vendor;
      const idx = row.dataset.idx;
      toggleApVendorExpand(vendorName, idx, row);
    });
  });
}

function toggleApVendorExpand(vendorName, idx, row) {
  const invoiceContainer = document.getElementById(`ap-invoices-${idx}`);
  if (!invoiceContainer) return;
  
  const isExpanded = invoiceContainer.style.display !== 'none';
  
  if (isExpanded) {
    // Collapse
    invoiceContainer.style.display = 'none';
    row.classList.remove('ap-expanded');
    apAgingExpandedVendors.delete(vendorName);
  } else {
    // Expand and load invoices
    invoiceContainer.style.display = '';
    row.classList.add('ap-expanded');
    apAgingExpandedVendors.add(vendorName);
    loadApVendorInvoices(vendorName, idx);
  }
}

function loadApVendorInvoices(vendorName, idx) {
  const container = document.getElementById(`ap-invoices-${idx}`);
  if (!container) return;
  
  const cell = container.querySelector('.ap-invoice-cell');
  cell.innerHTML = '<div class="ap-invoice-loading">Loading invoices...</div>';
  
  fetch(`/api/ap-aging/vendor?vendor=${encodeURIComponent(vendorName)}`)
    .then(r => r.json())
    .then(data => {
      if (data.success && data.invoices && data.invoices.length > 0) {
        renderApInvoiceRows(data.invoices, cell);
      } else {
        cell.innerHTML = '<div class="ap-invoice-empty">No invoices found</div>';
      }
    })
    .catch(err => {
      console.error('Error loading vendor invoices:', err);
      cell.innerHTML = '<div class="ap-invoice-error">Error loading invoices</div>';
    });
}

function renderApInvoiceRows(invoices, cell) {
  // Build invoice rows table
  let html = `<table class="ap-invoice-table">
    <thead>
      <tr>
        <th>Invoice #</th>
        <th>Invoice Date</th>
        <th>Job #</th>
        <th>Job Desc.</th>
        <th>PM</th>
        <th class="text-right">Total Due</th>
        <th class="text-right">0-30</th>
        <th class="text-right">31-60</th>
        <th class="text-right">61-90</th>
        <th class="text-right">90+</th>
        <th class="text-right">Retainage</th>
      </tr>
    </thead>
    <tbody>`;
  
  invoices.forEach(inv => {
    const collectible = inv.collectible || 0;
    const retainage = inv.retainage || 0;
    const totalDue = collectible + retainage;
    const bucket = inv.aging_bucket || 'current';
    
    // Place collectible in appropriate bucket column
    const current = bucket === 'current' ? collectible : 0;
    const days31_60 = bucket === 'days_31_60' ? collectible : 0;
    const days61_90 = bucket === 'days_61_90' ? collectible : 0;
    const days90_plus = bucket === 'days_90_plus' ? collectible : 0;
    
    html += `<tr class="ap-invoice-row">
      <td class="ap-inv-num">${escapeHtml(inv.invoice_number || '')}</td>
      <td class="ap-inv-date">${escapeHtml(inv.invoice_date || '')}</td>
      <td class="ap-inv-job">${escapeHtml(inv.job_number || '')}</td>
      <td class="ap-inv-desc" title="${escapeHtml(inv.job_description || '')}">${escapeHtml(inv.job_description || '')}</td>
      <td class="ap-inv-pm" title="${escapeHtml(inv.project_manager || '')}">${escapeHtml(inv.project_manager || '')}</td>
      <td class="text-right">${totalDue > 0 ? formatCurrency(totalDue) : ''}</td>
      <td class="text-right">${current > 0 ? formatCurrency(current) : ''}</td>
      <td class="text-right">${days31_60 > 0 ? formatCurrency(days31_60) : ''}</td>
      <td class="text-right">${days61_90 > 0 ? formatCurrency(days61_90) : ''}</td>
      <td class="text-right ${days90_plus > 0 ? 'negative' : ''}">${days90_plus > 0 ? formatCurrency(days90_plus) : ''}</td>
      <td class="text-right">${retainage > 0 ? formatCurrency(retainage) : ''}</td>
    </tr>`;
  });
  
  html += '</tbody></table>';
  cell.innerHTML = html;
}

function updateApAgingSummary(totals) {
  const currencyIds = {
    'apAgingTotalDue': totals.total_due || 0,
    'apAgingCurrent': totals.current || 0,
    'apAging31to60': totals.days_31_60 || 0,
    'apAging61to90': totals.days_61_90 || 0,
    'apAging90plus': totals.days_90_plus || 0,
    'apAgingRetainage': totals.retainage || 0
  };
  
  for (const [id, value] of Object.entries(currencyIds)) {
    const el = document.getElementById(id);
    if (el) el.textContent = formatCurrencyCompact(value);
  }
  
  // avgDays display removed per user request
  
  // Update chart
  updateApAgingChart(totals);
}

function updateApAgingChart(totals) {
  const ctx = document.getElementById('apAgingChart');
  if (!ctx) return;
  
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#e2e8f0' : '#374151';
  const gridColor = isDark ? '#334155' : '#e5e7eb';
  
  // Calculate max value for Y-axis padding (to show data labels above highest bar)
  const values = [
    totals.current || 0,
    totals.days_31_60 || 0,
    totals.days_61_90 || 0,
    totals.days_90_plus || 0,
    totals.retainage || 0
  ];
  const maxValue = Math.max(...values);
  const yMax = maxValue > 0 ? maxValue * 1.15 : undefined; // 15% padding above max
  
  // Aging bucket colors: green, yellow, orange, red, blue (retainage)
  // Colors go from darker (bottom) to lighter (top) for consistency with other charts
  const agingColors = [
    { start: '#15803d', end: '#4ade80' },  // 0-30 days - green (dark→light)
    { start: '#a16207', end: '#fde047' },  // 31-60 days - yellow (dark→light)
    { start: '#c2410c', end: '#fdba74' },  // 61-90 days - orange (dark→light)
    { start: '#b91c1c', end: '#fca5a5' },  // 90+ days - red (dark→light)
    { start: '#1d4ed8', end: '#93c5fd' }   // Retainage - blue (dark→light)
  ];
  
  const data = {
    labels: ['0-30 Days', '31-60 Days', '61-90 Days', '90+ Days', 'Retainage'],
    datasets: [{
      label: 'Amount',
      data: values,
      backgroundColor: (context) => {
        const chart = context.chart;
        const { ctx: canvasCtx, chartArea } = chart;
        const colorSet = agingColors[context.dataIndex] || agingColors[0];
        if (!chartArea) return colorSet.start;
        return createBarGradient(canvasCtx, chartArea, colorSet.start, colorSet.end);
      },
      borderRadius: 4,
      barPercentage: 0.9,
      categoryPercentage: 0.85
    }]
  };
  
  const options = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: { display: false },
      tooltip: {
        backgroundColor: "rgba(31, 41, 55, 0.95)",
        callbacks: {
          label: (context) => formatCurrency(context.raw)
        }
      },
      datalabels: {
        display: true,
        anchor: 'end',
        align: 'top',
        color: textColor,
        font: { size: 10, weight: 'bold' },
        formatter: (val) => formatCurrencyCompact(val)
      }
    },
    scales: {
      x: {
        ticks: { color: textColor, font: { size: 11 } },
        grid: { display: false }
      },
      y: {
        max: yMax,
        ticks: {
          color: textColor,
          font: { size: 10 },
          callback: (val) => formatCurrencyCompact(val)
        },
        grid: { color: gridColor }
      }
    }
  };
  
  if (apAgingChart) {
    apAgingChart.data = data;
    apAgingChart.options = options;
    apAgingChart.update();
  } else {
    apAgingChart = new Chart(ctx, {
      type: 'bar',
      data: data,
      options: options,
      plugins: [ChartDataLabels]
    });
  }
}

function updateApAgingFooter(totals) {
  const ids = {
    'apAgingFooterTotal': totals.total_due || 0,
    'apAgingFooterCurrent': totals.current || 0,
    'apAgingFooter31to60': totals.days_31_60 || 0,
    'apAgingFooter61to90': totals.days_61_90 || 0,
    'apAgingFooter90plus': totals.days_90_plus || 0,
    'apAgingFooterRetainage': totals.retainage || 0
  };
  
  for (const [id, value] of Object.entries(ids)) {
    const el = document.getElementById(id);
    if (el) el.textContent = formatCurrency(value);
  }
}

function updateApAgingSortIndicators() {
  document.querySelectorAll('#apAgingTable .sort-btn').forEach(btn => {
    btn.classList.remove('active');
    if (btn.dataset.sort === apAgingSortColumn && btn.dataset.dir === apAgingSortDirection) {
      btn.classList.add('active');
    }
  });
}

function showApAgingError(message) {
  const tbody = document.getElementById('apAgingTableBody');
  if (tbody) {
    tbody.innerHTML = `<tr><td colspan="7" class="error-cell">${escapeHtml(message)} <button onclick="loadApAgingData()" class="retry-btn">Retry</button></td></tr>`;
  }
}

/* ------------------------------------------------------------
   AR AGING REPORT
------------------------------------------------------------ */
let arAgingInitialized = false;
let arAgingSortColumn = 'days_90_plus';
let arAgingSortDirection = 'desc';
let arAgingSearchTerm = '';
let arAgingChart = null;

function initArAging() {
  if (!arAgingInitialized) {
    setupArAgingEventHandlers();
    loadArAgingFilters();
    arAgingInitialized = true;
  }
  
  loadArAgingData();
  
  const now = new Date();
  const dateStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  
  const dataAsOf = document.getElementById('arAgingDataAsOf');
  if (dataAsOf) dataAsOf.textContent = dateStr;
  
  const chartDate = document.getElementById('arAgingChartDate');
  if (chartDate) chartDate.textContent = dateStr;
}

function loadArAgingFilters() {
  fetch('/api/ar-aging/filters')
    .then(r => r.json())
    .then(data => {
      if (data.success) {
        const pms = data.pms || [];
        buildPmTabs('arAgingPmTabs', pms, 'ara', () => {
          loadArAgingData();
        });
      }
    })
    .catch(err => console.error('Error loading AR aging filters:', err));
}

function setupArAgingEventHandlers() {
  const searchInput = document.getElementById('arAgingSearch');
  if (searchInput) {
    searchInput.addEventListener('input', debounce(() => {
      arAgingSearchTerm = searchInput.value.trim();
      loadArAgingData();
    }, 300));
  }
  
  const table = document.getElementById('arAgingTable');
  if (table) {
    table.querySelectorAll('.sort-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const col = btn.dataset.sort;
        const dir = btn.dataset.dir;
        arAgingSortColumn = col;
        arAgingSortDirection = dir;
        updateArAgingSortIndicators();
        loadArAgingData();
      });
    });
  }
}

function loadArAgingData() {
  const loadingOverlay = document.getElementById('arAgingLoadingOverlay');
  if (loadingOverlay) loadingOverlay.classList.remove('hidden');
  
  const params = new URLSearchParams({
    sortColumn: arAgingSortColumn,
    sortDirection: arAgingSortDirection
  });
  
  if (arAgingSearchTerm) {
    params.set('search', arAgingSearchTerm);
  }
  
  const pmFilter = getSelectedPmForPage('ara');
  if (pmFilter && pmFilter !== '__ALL__') {
    params.set('pm', pmFilter);
  }
  
  fetch(`/api/ar-aging?${params.toString()}`)
    .then(r => r.json())
    .then(data => {
      if (data.success) {
        renderArAgingTable(data.customers || [], data.totals || {});
        updateArAgingSummary(data.totals || {});
      } else {
        showArAgingError('Failed to load AR aging data');
      }
      if (loadingOverlay) loadingOverlay.classList.add('hidden');
    })
    .catch(err => {
      console.error('Error loading AR aging:', err);
      showArAgingError('Error loading AR aging data');
      if (loadingOverlay) loadingOverlay.classList.add('hidden');
    });
}

// Track expanded customers
const arAgingExpandedCustomers = new Set();

function renderArAgingTable(customers, totals) {
  const tbody = document.getElementById('arAgingTableBody');
  if (!tbody) return;
  
  totals = totals || {};
  
  const totalsRow = `<tr class="totals-row">
    <td><strong>Totals (${customers.length} customers)</strong></td>
    <td class="text-right"><strong>${formatCurrency(totals.total_due || 0)}</strong></td>
    <td class="text-right"><strong>${formatCurrency(totals.current || 0)}</strong></td>
    <td class="text-right"><strong>${formatCurrency(totals.days_31_60 || 0)}</strong></td>
    <td class="text-right"><strong>${formatCurrency(totals.days_61_90 || 0)}</strong></td>
    <td class="text-right"><strong>${formatCurrency(totals.days_90_plus || 0)}</strong></td>
    <td class="text-right"><strong>${formatCurrency(totals.retainage || 0)}</strong></td>
  </tr>`;
  
  if (!customers || customers.length === 0) {
    tbody.innerHTML = totalsRow + '<tr><td colspan="7" class="empty-cell">No outstanding AR balances found</td></tr>';
    return;
  }
  
  const dataRows = customers.map((c, idx) => `
    <tr class="ar-customer-row" data-customer="${escapeHtml(c.customer_name)}" data-idx="${idx}">
      <td>
        <span class="ar-expand-toggle" title="Click to expand">
          <svg class="ar-expand-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="9 18 15 12 9 6"></polyline>
          </svg>
        </span>
        <span class="customer-name">${escapeHtml(c.customer_name)}</span>
      </td>
      <td class="text-right">${formatCurrency(c.total_due)}</td>
      <td class="text-right">${formatCurrency(c.current)}</td>
      <td class="text-right">${formatCurrency(c.days_31_60)}</td>
      <td class="text-right">${formatCurrency(c.days_61_90)}</td>
      <td class="text-right ${c.days_90_plus > 0 ? 'negative' : ''}">${formatCurrency(c.days_90_plus)}</td>
      <td class="text-right">${formatCurrency(c.retainage)}</td>
    </tr>
    <tr class="ar-invoice-container" id="ar-invoices-${idx}" style="display: none;">
      <td colspan="7" class="ar-invoice-cell">
        <div class="ar-invoice-loading">Loading invoices...</div>
      </td>
    </tr>
  `).join('');
  
  tbody.innerHTML = totalsRow + dataRows;
  
  // Add click handlers for expandable rows
  tbody.querySelectorAll('.ar-customer-row').forEach(row => {
    row.addEventListener('click', () => {
      const customerName = row.dataset.customer;
      const idx = row.dataset.idx;
      toggleArCustomerExpand(customerName, idx, row);
    });
  });
}

function toggleArCustomerExpand(customerName, idx, row) {
  const invoiceContainer = document.getElementById(`ar-invoices-${idx}`);
  if (!invoiceContainer) return;
  
  const isExpanded = invoiceContainer.style.display !== 'none';
  
  if (isExpanded) {
    // Collapse
    invoiceContainer.style.display = 'none';
    row.classList.remove('ar-expanded');
    arAgingExpandedCustomers.delete(customerName);
  } else {
    // Expand and load invoices
    invoiceContainer.style.display = '';
    row.classList.add('ar-expanded');
    arAgingExpandedCustomers.add(customerName);
    loadArCustomerInvoices(customerName, idx);
  }
}

function loadArCustomerInvoices(customerName, idx) {
  const container = document.getElementById(`ar-invoices-${idx}`);
  if (!container) return;
  
  const cell = container.querySelector('.ar-invoice-cell');
  cell.innerHTML = '<div class="ar-invoice-loading">Loading invoices...</div>';
  
  fetch(`/api/ar-aging/customer?customer=${encodeURIComponent(customerName)}`)
    .then(r => r.json())
    .then(data => {
      if (data.success && data.invoices && data.invoices.length > 0) {
        renderArInvoiceRows(data.invoices, cell);
      } else {
        cell.innerHTML = '<div class="ar-invoice-empty">No invoices found</div>';
      }
    })
    .catch(err => {
      console.error('Error loading invoices:', err);
      cell.innerHTML = '<div class="ar-invoice-error">Error loading invoices</div>';
    });
}

function renderArInvoiceRows(invoices, cell) {
  // Build invoice rows table
  let html = `<table class="ar-invoice-table">
    <thead>
      <tr>
        <th>Invoice #</th>
        <th>Job #</th>
        <th>Job Desc.</th>
        <th>PM</th>
        <th>Invoice Date</th>
        <th class="text-right">Total Due</th>
        <th class="text-right">0-30</th>
        <th class="text-right">31-60</th>
        <th class="text-right">61-90</th>
        <th class="text-right">90+</th>
        <th class="text-right">Retainage</th>
      </tr>
    </thead>
    <tbody>`;
  
  invoices.forEach(inv => {
    const collectible = inv.collectible || 0;
    const retainage = inv.retainage || 0;
    const totalDue = collectible + retainage;
    const bucket = inv.aging_bucket || 'current';
    
    // Place collectible in appropriate bucket column
    const current = bucket === 'current' ? collectible : 0;
    const days31_60 = bucket === 'days_31_60' ? collectible : 0;
    const days61_90 = bucket === 'days_61_90' ? collectible : 0;
    const days90_plus = bucket === 'days_90_plus' ? collectible : 0;
    
    html += `<tr class="ar-invoice-row">
      <td class="ar-inv-num">${escapeHtml(inv.invoice_number || '')}</td>
      <td class="ar-inv-job">${escapeHtml(inv.job_number || '')}</td>
      <td class="ar-inv-desc" title="${escapeHtml(inv.job_description || '')}">${escapeHtml(inv.job_description || '')}</td>
      <td class="ar-inv-pm" title="${escapeHtml(inv.project_manager || '')}">${escapeHtml(inv.project_manager || '')}</td>
      <td class="ar-inv-date">${escapeHtml(inv.invoice_date || '')}</td>
      <td class="text-right">${totalDue > 0 ? formatCurrency(totalDue) : ''}</td>
      <td class="text-right">${current > 0 ? formatCurrency(current) : ''}</td>
      <td class="text-right">${days31_60 > 0 ? formatCurrency(days31_60) : ''}</td>
      <td class="text-right">${days61_90 > 0 ? formatCurrency(days61_90) : ''}</td>
      <td class="text-right ${days90_plus > 0 ? 'negative' : ''}">${days90_plus > 0 ? formatCurrency(days90_plus) : ''}</td>
      <td class="text-right">${retainage > 0 ? formatCurrency(retainage) : ''}</td>
    </tr>`;
  });
  
  html += '</tbody></table>';
  cell.innerHTML = html;
}

function updateArAgingSummary(totals) {
  const currencyIds = {
    'arAgingTotalDue': totals.total_due || 0,
    'arAgingCurrent': totals.current || 0,
    'arAging31to60': totals.days_31_60 || 0,
    'arAging61to90': totals.days_61_90 || 0,
    'arAging90plus': totals.days_90_plus || 0,
    'arAgingRetainage': totals.retainage || 0
  };
  
  for (const [id, value] of Object.entries(currencyIds)) {
    const el = document.getElementById(id);
    if (el) el.textContent = formatCurrencyCompact(value);
  }
  
  updateArAgingChart(totals);
}

function showCustomerInvoicesModal(customerName) {
  const modal = document.getElementById('arAgingCustomerModal');
  const title = document.getElementById('arAgingCustomerModalTitle');
  const loading = document.getElementById('arAgingCustomerModalLoading');
  const content = document.getElementById('arAgingCustomerModalContent');
  const closeBtn = document.getElementById('arAgingCustomerModalClose');
  
  if (!modal) return;
  
  title.textContent = customerName;
  loading.classList.remove('hidden');
  content.classList.add('hidden');
  modal.classList.remove('hidden');
  
  const closeModal = () => modal.classList.add('hidden');
  closeBtn.onclick = closeModal;
  modal.onclick = (e) => { if (e.target === modal) closeModal(); };
  
  fetch(`/api/ar-aging/customer?customer=${encodeURIComponent(customerName)}`)
    .then(r => r.json())
    .then(data => {
      if (data.success) {
        renderCustomerInvoicesModal(data.invoices || [], data.totals || {});
      } else {
        document.getElementById('customerInvoicesTableBody').innerHTML = 
          '<tr><td colspan="10" class="empty-cell">Error loading invoices</td></tr>';
      }
      loading.classList.add('hidden');
      content.classList.remove('hidden');
    })
    .catch(err => {
      console.error('Error loading customer invoices:', err);
      document.getElementById('customerInvoicesTableBody').innerHTML = 
        '<tr><td colspan="10" class="empty-cell">Error loading invoices</td></tr>';
      loading.classList.add('hidden');
      content.classList.remove('hidden');
    });
}

function renderCustomerInvoicesModal(invoices, totals) {
  const tbody = document.getElementById('customerInvoicesTableBody');
  const summary = document.getElementById('customerInvoiceSummary');
  
  if (!tbody) return;
  
  if (summary) {
    summary.innerHTML = `
      <div class="summary-item">
        <span class="label">Invoices</span>
        <span class="value">${totals.count || 0}</span>
      </div>
      <div class="summary-item">
        <span class="label">Invoice Total</span>
        <span class="value">${formatCurrency(totals.invoice_amount || 0)}</span>
      </div>
      <div class="summary-item">
        <span class="label">Amount Paid</span>
        <span class="value">${formatCurrency(totals.amount_paid || 0)}</span>
      </div>
      <div class="summary-item">
        <span class="label">Amount Due</span>
        <span class="value">${formatCurrency(totals.amount_due || 0)}</span>
      </div>
      <div class="summary-item">
        <span class="label">Retainage</span>
        <span class="value">${formatCurrency(totals.retainage || 0)}</span>
      </div>
    `;
  }
  
  if (!invoices || invoices.length === 0) {
    tbody.innerHTML = '<tr><td colspan="10" class="empty-cell">No invoices found</td></tr>';
    return;
  }
  
  const rows = invoices.map(inv => `
    <tr>
      <td>${escapeHtml(inv.invoice_number || '')}</td>
      <td>${escapeHtml(inv.invoice_date || '')}</td>
      <td>${escapeHtml(inv.job_number || '')}</td>
      <td>${escapeHtml(inv.job_description || '')}</td>
      <td>${escapeHtml(inv.project_manager || '')}</td>
      <td class="text-right">${formatCurrency(inv.invoice_amount || 0)}</td>
      <td class="text-right">${formatCurrency(inv.amount_paid || 0)}</td>
      <td class="text-right">${formatCurrency(inv.amount_due || 0)}</td>
      <td class="text-right">${formatCurrency(inv.retainage || 0)}</td>
      <td class="text-right ${inv.days_outstanding > 90 ? 'negative' : ''}">${inv.days_outstanding}</td>
    </tr>
  `).join('');
  
  tbody.innerHTML = rows;
}

function updateArAgingChart(totals) {
  const ctx = document.getElementById('arAgingChart');
  if (!ctx) return;
  
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || document.body.classList.contains('dark-mode');
  const textColor = isDark ? '#e2e8f0' : '#374151';
  const gridColor = isDark ? '#334155' : '#e5e7eb';
  
  const values = [
    totals.current || 0,
    totals.days_31_60 || 0,
    totals.days_61_90 || 0,
    totals.days_90_plus || 0,
    totals.retainage || 0
  ];
  const maxValue = Math.max(...values);
  const yMax = maxValue > 0 ? maxValue * 1.15 : undefined;
  
  // Aging bucket colors: green, yellow, orange, red, blue (retainage)
  // Colors go from darker (bottom) to lighter (top) for consistency with other charts
  const agingColors = [
    { start: '#15803d', end: '#4ade80' },  // 0-30 days - green (dark→light)
    { start: '#a16207', end: '#fde047' },  // 31-60 days - yellow (dark→light)
    { start: '#c2410c', end: '#fdba74' },  // 61-90 days - orange (dark→light)
    { start: '#b91c1c', end: '#fca5a5' },  // 90+ days - red (dark→light)
    { start: '#1d4ed8', end: '#93c5fd' }   // Retainage - blue (dark→light)
  ];
  
  const data = {
    labels: ['0-30 Days', '31-60 Days', '61-90 Days', '90+ Days', 'Retainage'],
    datasets: [{
      label: 'Amount',
      data: values,
      backgroundColor: (context) => {
        const chart = context.chart;
        const { ctx: canvasCtx, chartArea } = chart;
        const colorSet = agingColors[context.dataIndex] || agingColors[0];
        if (!chartArea) return colorSet.start;
        return createBarGradient(canvasCtx, chartArea, colorSet.start, colorSet.end);
      },
      borderRadius: 4,
      barPercentage: 0.9,
      categoryPercentage: 0.85
    }]
  };
  
  const options = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: { display: false },
      tooltip: {
        backgroundColor: "rgba(31, 41, 55, 0.95)",
        callbacks: {
          label: (context) => formatCurrency(context.raw)
        }
      },
      datalabels: {
        display: true,
        anchor: 'end',
        align: 'top',
        color: textColor,
        font: { size: 10, weight: 'bold' },
        formatter: (val) => formatCurrencyCompact(val)
      }
    },
    scales: {
      x: {
        ticks: { color: textColor, font: { size: 11 } },
        grid: { display: false }
      },
      y: {
        max: yMax,
        ticks: {
          color: textColor,
          font: { size: 10 },
          callback: (val) => formatCurrencyCompact(val)
        },
        grid: { color: gridColor }
      }
    }
  };
  
  if (arAgingChart) {
    arAgingChart.data = data;
    arAgingChart.options = options;
    arAgingChart.update();
  } else {
    arAgingChart = new Chart(ctx, {
      type: 'bar',
      data: data,
      options: options,
      plugins: [ChartDataLabels]
    });
  }
}

function updateArAgingSortIndicators() {
  document.querySelectorAll('#arAgingTable .sort-btn').forEach(btn => {
    btn.classList.remove('active');
    if (btn.dataset.sort === arAgingSortColumn && btn.dataset.dir === arAgingSortDirection) {
      btn.classList.add('active');
    }
  });
}

function showArAgingError(message) {
  const tbody = document.getElementById('arAgingTableBody');
  if (tbody) {
    tbody.innerHTML = `<tr><td colspan="7" class="error-cell">${escapeHtml(message)} <button onclick="loadArAgingData()" class="retry-btn">Retry</button></td></tr>`;
  }
}
